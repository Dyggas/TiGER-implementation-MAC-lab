\chapter{\large{Вступне слово}}
\label{chapter:1}

\textbf{Мета роботи} (власне, для чого ми тут зібралися):

Дослідити особливостей реалізації сучасних алгебраїчних криптосистем на прикладі учасників першого раунду
національного конкурсу з постквантової криптографії в Кореї (KpqC).

\noindent \textbf{Наші задачі на комп'ютерний практикум та порядок їх виконання:}
\begin{enumerate}[label=\arabic*)]
    \item Роздітися на бригади. Визначили хто за що відповідатиме. Богдан -- займається реалізацією алгоритму TiGER,
        Олексій -- теоретичною частиною і звітом загалом.
    \item Провести теоретичне дослідження теми, надавши вичерпний та повний опис теоретичної сторони алгоритму з усіма
        деталями та відомими результатами досліджень; провести аналіз вже існуючих атак на алгоритм TiGER, а також
        загалом можливих атак; виконати порівняльний аналіз нашого алгоритму зi схожими та дослідити можливість
        перенесення та застосування відомих атак на нього.
    \item Реалізувати алгоритм програмно та всі(нє, ну ми постараємося) можливі варіанти цього алгоритму;
    \item Перевірити коректність -- підтвердити правильність реалізації за допомогою тестів, використавши тестові
        дані з офіційної реалізації;
    \item Зробити аналіз продуктивності алгоритму та, знову ж таки, провести порівняння та аналіз швидкодії за різних
        умов, дослідити вплив модифікацій окремих його складових частин на ефективність.
\end{enumerate}

\chapter{\large{Загальне теоретичне дослідження}}
\label{chapter:2}
\section{Постквантова криптографія}
\label{sec:2-1}

Сучасна криптографія з відкритим ключем, зокрема RSA та криптографія на еліптичних кривих -- Elliptic Curve
Cryptography (ECC), базується на обчислювальній складності задач факторизації великих чисел та дискретного логарифмування.
Однак у 1994 році Пітер Шор~\cite{shor1994} продемонстрував квантові алгоритми, здатні розв'язувати ці задачі за
поліноміальний час на достатньо потужному квантовому комп'ютері. Це створює критичну загрозу для існуючої криптографічної
інфраструктури.

Постквантова криптографія (Post-Quantum Cryptography, PQC) -- це галузь криптографії, що розробляє алгоритми, стійкі
як до класичних, так і до квантових атак. Серед основних напрямків PQC виділяють криптографію на решітках, криптографію
на кодах виправлення помилок, багатовимірну поліноміальну(квадратичну) криптографію та криптографію на основі
геш-функцій~\cite{WikiPQC}.

\section{Передумови створення TiGER}
\label{sec:2-2}

Механізм інкапсуляції ключа (Key Encapsulation Mechanism, KEM) є одним з найважливіших криптографічних примітивів для
захищеного обміну ключами. У контексті заміни класичних протоколів, таких як Diffie-Hellman (DH) або Elliptic Curve
Diffie-Hellman ECDH, постквантові KEM повинні забезпечувати не лише високий рівень безпеки, але й бути ефективними за
розміром даних та залишатися обчислювано складними для зламу зловмисником.

Криптографія на решітках, зокрема алгоритми на основі задач Learning With Errors (LWE)~\cite{regev2005} та Ring Learning
With Errors (RLWE)~\cite{lyubashevsky2010}, продемонструвала перспективність у створенні ефективних постквантових
схем. Розвиток цього напрямку призвів до появи сімейства алгоритмів, що використовують детермінований варіант --
Learning With Rounding (LWR)~\cite{banerjee2012}, який замінює випадкову помилку округленням, що покращує як
продуктивність, так і довжину шифротексту.

Серед попередніх розробок слід відзначити алгоритми Lizard~\cite{lizard2018} та RLizard~\cite{rlizard2018}, які
комбінували RLWE для генерації ключів з RLWR для шифрування, досягаючи балансу між безпекою та ефективністю. Однак
ці схеми мали певні обмеження щодо розміру відкритого ключа та шифротексту, що ускладнювало їх інтеграцію в існуючі протоколи.

TiGER (Tiny bandwidth key encapsulation mechanism for easy miGration based on RLWE(R))~\cite{tiger2022} був розроблений
командою дослідників з метою створення компактного та ефективного KEM, придатного для легкої інтеграції в існуючі системи
безпеки. Основні задачі, які ставили перед собою науковці це:

\begin{itemize}
    \item \textbf{Мінімізація розміру шифротексту та відкритого ключа}
    \item \textbf{Висока обчислювальна ефективність} --- використання в якості модуля число, яке є степенем двійки ($q = 2^{k}$)
        (для оптимізації операцій округлення через побітові зсуви);
    \item \textbf{Відмова від NTT} --- алгоритм не використовує Number Theoretic Transform, що спрощує реалізацію;
    \item \textbf{Використання розріджених секретів (з малою вагою Геммінга)} --- зменшення розміру секретного ключа та прискорення
        множення многочленів;
    \item \textbf{Корекція помилок} --- застосування кодів XEf та D2 для зниження ймовірності помилки розшифрування.
\end{itemize}

Конструкція TiGER базується на комбінації RLWR для генерації відкритого ключа та RLWE для шифрування, з подальшим застосуванням перетворення Fujisaki-Okamoto~\cite{fo1999, fo2013} для досягнення IND-CCA безпеки.

\section{Участь у KpqC та злиття з SMAUG}
\label{sec:2-3}

У 2022 році Національна служба розвідки Республіки Корея ініціювала Korean Post-Quantum Cryptography Competition
скорочено -- KpqC~\cite{kpqc2023}. Це національний конкурс для стандартизації постквантових криптографічних алгоритмів.

Обраний нами для аналізу алгоритм TiGER був поданий на перший раунд конкурсу KpqC у категорії механізмів інкапсуляції
ключа (KEM) і був одним з чотирьох алгоритмів, які пройшли до другого раунду.

\subsection{Злиття TiGER та SMAUG}
Команди TiGER та SMAUG об'єдналися для створення спільного алгоритму SMAUG-T~\cite{smaugt2024}. Метою злиття було
поєднання переваг обох підходів:

\begin{itemize}
    \item Від \textbf{TiGER}: Компактність шифротексту, використання RLWE/RLWR на кільцевому рівні, корекція помилок
        через D2 кодування (для параметра TiMER);
    \item Від \textbf{SMAUG}: Модульна структура (MLWE/MLWR), розріджені секрети через використання гаусівського
        шуму, покращена безпека за рахунок збільшення розмірності.
\end{itemize}

Результатом злиття став алгоритм SMAUG-T версії 3.0 (лютий 2024), який включає в себе:
\begin{itemize}
    \item Три основні набори параметрів: \textbf{SMAUG-T128}, \textbf{SMAUG-T192}, \textbf{SMAUG-T256}
        (відповідають рівням безпеки NIST 1, 3, 5);
    \item Додатковий набір параметрів \textbf{TiMER} (Tiny SMAUG using Error Reconciliation) -- оптимізований для
        IoT(Internet of Thing)-пристроїв з мінімальним шифротекстом завдяки використанню D2 кодування з TiGER.
\end{itemize}

\subsection{Результати KpqC 2023}

У січні 2025 року було оголошено фінальні результаті конкурсу KpqC. Переможцями стали:
\begin{itemize}
    \item У категорії KEM: \textbf{SMAUG-T} та \textbf{NTRU+};
    \item У категорії цифрового підпису: \textbf{HAETAE} (до речі, також від команди SMAUG).
\end{itemize}

Таким чином, ідеї та технології TiGER увійшли до складу національного стандарту постквантової криптографії Кореї
через алгоритм SMAUG-T.

\chapter{\large{Теоретична база алгоритму TiGER}}
\label{chapter:3}

\section{Алгебраїчні структури}
\label{sec:3-1}
Критографія на решітках (Lattice-based cryptography) використовує алгебраїчні структури для забезпечення ефективності
обчислень та компактності представлення даних. У цьому розділі я розпишу основні алгебраїчні об'єкти, що застосовуються
в алгоритмі TiGER.

\subsection{Кільця та многочлени}
\label{subsec:3-1-1}

\begin{definition}[Кільце]
    \label{def:3-1-1}
    ~\par Кільце $(R, +, \cdot)$ -- це множина з двома операціями: додавання $(+)$ та множення $(\cdot)$, що задовольняє
    наступні властивості:
    \begin{enumerate}
        \item $(R, +)$ є абелевою групою за додаванням. Нейтральний елемент $0$;
        \item Множення є асоціативним: $(a \cdot b) \cdot c = a \cdot (b \cdot c)$, $\forall \, a, b, c \in R$;
        \item Дистрибутивність: $a \cdot (b + c) = a \cdot b + a \cdot c$ та $(b + c) \cdot a = b \cdot a + c \cdot a$,
            $\forall \, a, b, c \in R$;
        \item Існує нейтральний елемент за множенням: $1 \in R$ такий, що $1 \cdot a = a \cdot 1 = a$, $\forall\, a \in R$.
    \end{enumerate}
    Якщо ще $a \cdot b = b \cdot a$, $\forall \, a, b \in R$, то таке кільце називається \textit{комутативним}.
\end{definition}

\begin{definition}[Кільце многочленів]
    \label{def:3-1-2}
    ~\par Нехай $R$ -- комутативне кільце з одиницею. Кільце многочленів $R[x]$ складається з усіх виразів виду
    \begin{equation*}
        f(x) = a_{n} x^{n} + a_{n-1} x^{n-1} + \ldots + a_{1} x + a_{0},
    \end{equation*}
    де $\forall \, i : a_{i} \in \mathbb{R}$, $a_{n} \neq 0$ та $n \in \mathbb{Z}$.

    Число $n$ називається \textit{степенем} многочлена $f(x)$, позначається $\deg(f)$.
\end{definition}

Операції додавання та множення многочленів наступним чином:
\begin{itemize}
    \item $(f + g)(x) = \sum\limits_{i=0}^{\max(\deg(f), \deg(g))} (a_i + b_i) x^i$, де $a_i, b_i$ -- коефіцієнти $f$ та $g$ відповідно;
    \item $(f \cdot g)(x) = \sum\limits_{k=0}^{\deg(f) + \deg(g)} c_k x^k$, де $c_k = \sum\limits_{i=0}^{k} a_i b_{k-i}$.
\end{itemize}

\subsection{Факторкільця многочленів}
\label{subsec:3-1-2}

\begin{definition}[Факторкільце]
    \label{def:3-1-3}
    ~\par Нехай $R$ -- кільце та $I$ -- його ідеал. Факторкільце $R/I$ складається з класів еквівалентності
    $a + I = \{a + r : r \in I\}$ для $a \in R$, з операціями:
    \begin{equation*}
        (a + I) + (b + I) = (a + b) + I, \quad (a + I) \cdot (b + I) = (a \cdot b) + I.
    \end{equation*}
\end{definition}

\noindent У Lattice-based cryptography найчастіше використовується факторкільце многочленів за ідеалом, що породжений
циклотомічним многочленом.

\begin{definition}[Циклотомічний многочлен]
    \label{def:3-1-4}
    ~\par $n$-ий циклотомічний многочлен (Cyclotomic polynomial) $\Phi_n(x)$ визначається як мінімальний многочлен над $\mathbb{Q}$, коренями
    якого є примітивні корені $n$-го степеня з одиниці:
    \begin{equation*}
        \Phi_n(x) = \prod_{\substack{1 \leq k \leq n \\ \gcd(k, n) = 1}} \left(x - e^{2\pi i k / n}\right).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{lemma:3-1-1}
    Для $n = 2^k$, де $k \in \mathbb{N}$, циклотомічний многочлен має вигляд:
    \begin{equation*}
        \Phi_n(x) = x^{n/2} + 1.
    \end{equation*}
\end{lemma}

\begin{proof}
    При $n = 2^k$ примітивними коренями $n$-го степеня з одиниці є $e^{2\pi i m / n}$ для непарних $m$. З
    $(x^{n/2} + 1) = (x^n - 1)/(x^{n/2} - 1)$ випливає твердження леми.
\end{proof}

\subsection{Кільце многочленів у TiGER}
\label{subsec:3-1-3}

В алгоритмі TiGER використовується кільце многочленів виду:
\begin{equation*}
    \label{eq:3-1-1}
    R_q = \frac{\mathbb{Z}_q[x]}{(x^n + 1)},
\end{equation*}
де $n$ -- степінь двійки (зазвичай $n = 512$ або $n = 1024$), а $q$ -- модуль, що також є степенем двійки
($q = 256$ у всіх варіаціях алгоритму TiGER).

Елементами $R_q$ є многочлени степеня не вище $n-1$ з коефіцієнтами з $\mathbb{Z}_q$:
\begin{equation*}
    f(x) = \sum\limits_{i=0}^{n-1} a_i x^i, \quad a_i \in \mathbb{Z}_q.
\end{equation*}

Вибір саме такого $n$ та многочлена $x^n + 1$ забезпечує:
\begin{itemize}
    \item Ефективність множення многочленів (без потреби в NTT);
    \item Редукцію за модулем $x^n + 1$, що спрощує обчислення;
    \item Зв'язок з циклотомічними многочленами та решітковими задачами.
\end{itemize}

\subsection{Операції в кільці \texorpdfstring{$R_q$}{ring Q}}
\label{subsec:3-1-4}

Для $f(x), g(x) \in R_q$ операції в кільці визначаються наступним чином:

\textbf{Додавання:} покоефіцієнтне за модулем $q$:
\begin{equation*}
    (f + g)(x) = \sum_{i=0}^{n-1} ((f_i + g_i) \bmod q) x^i.
\end{equation*}

\textbf{Множення:} спочатку виконується звичайне множення многочленів, потім взяття за модулем $(x^n + 1)$ та $q$.
Оскільки $x^n \equiv -1 \pmod{x^n + 1}$, то маємо:
\begin{equation*}
    \label{eq:3-1-2}
    h_i = \left(\sum_{j=0}^{i} f_j g_{i-j} - \sum_{j=i+1}^{n-1} f_j g_{n+i-j}\right) \bmod q,
\end{equation*}
де $h(x) = (f \cdot g)(x) = \sum_{i=0}^{n-1} h_i x^i$.

\section{Задачі на решітках}
\label{sec:3-2}

Безпека TiGER базується на обчислювальній складності певних задач на решітках. У цьому підпункті зазначимо основні
решіткові задачі, що лежать в основі постквантової криптографії.

\subsection{Решітки та базові задачі}
\label{subsec:3-2-1}

\begin{definition}[Решітка]
    \label{def:3-2-1}
    ~\par Нехай $\mathbf{b}_1, \mathbf{b}_2, \ldots, \mathbf{b}_m \in \mathbb{R}^n$ -- лінійно незалежні вектори.
    Решітка $\Lambda$, породжена цими векторами, визначається як:
    \begin{equation*}
        \Lambda = \Lambda(\mathbf{b}_1, \ldots, \mathbf{b}_m) = \left\{ \sum_{i=1}^{m} a_i \mathbf{b}_i : a_i \in \mathbb{Z} \right\}.
    \end{equation*}
    Вектори $\mathbf{b}_1, \ldots, \mathbf{b}_m$ називаються базисом решітки, а $m$ -- розмірністю решітки.
\end{definition}

\begin{definition}[Мінімальна відстань решітки(shortest vector)]
    \label{def:3-2-2}
    ~\par Мінімальна відстань решітки $\Lambda$ визначається як:
    \begin{equation*}
        \lambda_1(\Lambda) = \min_{\mathbf{v} \in \Lambda \setminus \{\mathbf{0}\}} \|\mathbf{v}\|,
    \end{equation*}
    де $\|\cdot\|$ -- евклідова норма.
\end{definition}

\begin{definition}[SVP]
    \label{def:3-2-3}
    ~\par \textit{Shortest Vector Problem (SVP):} Для заданого базису решітки $\Lambda$ знайти ненульовий вектор
    $\mathbf{v} \in \Lambda$ такий, що $\|\mathbf{v}\| = \lambda_1(\Lambda)$.
\end{definition}

\noindent SVP є NP-складною задачею~\cite{ajtai1998}. Для криптографічних цілей часто використовується наступна версія:

\begin{definition}[Апроксимаційна задача SVP]
    \label{def:3-2-4}
    ~\par \textit{$\gamma$-approximate SVP ($\gamma$-SVP):} Для заданого базису решітки $\Lambda$ та параметра
    наближення $\gamma \geq 1$, знайти ненульовий вектор $\mathbf{v} \in \Lambda$ такий, що
    $\|\mathbf{v}\| \leq \gamma \cdot \lambda_1(\Lambda)$.
\end{definition}

\subsection{Задача Learning With Errors (LWE)}
\label{subsec:3-2-2}

Задача Learning With Errors була введена Одедом Регєвим у 2005 році~\cite{regev2005} і стала основою для багатьох
постквантових криптосистем.

\begin{definition}[LWE задача (search version)]
    \label{def:3-2-5}
    ~\par Нехай $n, q \geq 1$ -- цілі числа, $\chi$ -- розподіл ймовірностей на $\mathbb{Z}_q$. Пошукова задача
    $\text{LWE}_{n,q,\chi}$ визначається наступним чином:

    Для невідомого секрету $\mathbf{s} \in \mathbb{Z}_q^n$ та заданої послідовності пар $(\mathbf{a}_i, b_i) \in \mathbb{Z}_q^n \times \mathbb{Z}_q$,
    де
    \begin{equation*}
        b_i = \langle \mathbf{a}_i, \mathbf{s} \rangle + e_i \pmod{q},
    \end{equation*}
    з випадково обраними $\mathbf{a}_i \in \mathbb{Z}_q^n$, $\langle \cdot, \cdot \rangle$ -- операція векторного
    добутку та $e_i \xleftarrow{p} \chi$, знайти секрет $\mathbf{s}$.
\end{definition}

\begin{definition}[LWE задача (detection version)]
    \label{def:3-2-6}
    ~\par Розпізнавальна задача $\text{Decision-LWE}_{n,q,\chi}$ полягає у розрізненні наступних двох розподілів:
    \begin{itemize}
        \item $(\mathbf{a}, \langle \mathbf{a}, \mathbf{s} \rangle + e \bmod q)$, де
            $\mathbf{a} \leftarrow \mathbb{Z}_q^n$, $\mathbf{s} \in \mathbb{Z}_q^n$ фіксоване,
            $e \xleftarrow{p} \chi$;
        \item $(\mathbf{a}, u)$, де $\mathbf{a}, u$ -- рівноймовірно розподілені на $\mathbb{Z}_q^n$ та $\mathbb{Z}_q$ відповідно.
    \end{itemize}
\end{definition}

\begin{theorem}[Регєва]
    \label{theorem:3-2-1}
    ~\par Для певних параметрів $n, q, \chi$, розв'язання задачі Decision-LWE за поліноміальний час у середньому
    випадку еквівалентно розв'язанню наближеної задачі $\gamma$-SVP за квантовий поліноміальний час у найгіршому
    випадку для деякого $\gamma = \tilde{O}(n/\sigma)$.
\end{theorem}

\subsection{Задача Ring Learning With Errors (RLWE)}
\label{subsec:3-2-3}

Ring-LWE є алгебраїчною версією LWE, що вже використовує кільця многочленів для більшої
ефективності~\cite{lyubashevsky2010}.

\begin{definition}[RLWE задача]
    \label{def:3-2-7}
    ~\par Нехай $R = \mathbb{Z}[x]/(x^n + 1)$, $R_q = \mathbb{Z}_q[x]/(x^n + 1)$, та $\chi$ -- розподіл ймовірностей
    на $R_q$. Розпізнавальна задача $\text{Decision-RLWE}_{n,q,\chi}$ полягає у розрізненні наступних розподілів:
    \begin{itemize}
        \item $(a, a \cdot s + e)$, де обрано $a \in R_q$ (рівномірний розподіл), $s \in R_q$ фіксоване, $e \xleftarrow{p} \chi$;
        \item $(a, u)$, де $a, u$ обрані рівномірно з $R_q$.
    \end{itemize}
\end{definition}

Важливим є те, що RLWE дозволяє представляти $n$ секретів (LWE-зразків) у вигляді одного многочлена в $R_q$, що
значно зменшує розмір ключів та шифротекстів. Для TiGER використовується $n \in \{512, 1024\}$ та $q = 256$.

\subsection{Задача Learning With Rounding (LWR)}
\label{subsec:3-2-4}

Learning With Rounding є детермінованим варіантом LWE, де замість додавання випадкової помилки використовується
округлення~\cite{banerjee2012}.

\begin{definition}[LWR задача]
    \label{def:3-2-8}
    ~\par Нехай $n, q, p$ -- цілі числа, $p < q$. Визначимо функцію округлення $\lfloor \cdot \rceil_p : \mathbb{Z}_q \to \mathbb{Z}_p$ як
    \begin{equation*}
        \lfloor x \rceil_p = \left\lfloor \frac{p}{q} \cdot x \right\rceil \bmod p,
    \end{equation*}
    де $\lfloor \cdot \rceil$ позначатиме округлення до найближчого цілого.

    Розпізнавальна задача $\text{Decision-LWR}_{n,q,p}$ полягає у розрізненні наступних розподілів:
    \begin{itemize}
        \item $(\mathbf{a}, \lfloor \langle \mathbf{a}, \mathbf{s} \rangle \rceil_p)$, де
            $\mathbf{a} \leftarrow \mathbb{Z}_q^n$, $\mathbf{s} \in \mathbb{Z}_q^n$ -- фіксоване;
        \item $(\mathbf{a}, u)$, де $\mathbf{a} \leftarrow \mathbb{Z}_q^n$, $u \leftarrow \mathbb{Z}_p$.
    \end{itemize}
\end{definition}

\begin{theorem}[Редукція (взяття за модулем) LWR до LWE~\cite{banerjee2012}]
    \label{theorem:3-2-2}
    Для відповідних параметрів $n, q, p$ та достатньо малого розподілу помилок $\chi$, задача Decision-LWR$_{n,q,p}$
    зводиться до задачі Decision-LWE$_{n,q,\chi}$.
\end{theorem}

\begin{remark}
    (Ідея теореми) При достатньо великому відношенні $q/p$, округлення $\lfloor \langle \mathbf{a}, \mathbf{s} \rangle \rceil_p$
    стає еквівалентно до додавання малої помилки округлення, яка розподілена майже рівномірно на інтервалі $(-q/(2p), q/(2p)]$.
\end{remark}

\subsection{Задача Ring Learning With Rounding (RLWR)}
\label{subsec:3-2-5}

RLWR поєднує переваги RLWE (компактність -- за рахунок алгебраїчної структури) та LWR (детермінованість,
та відсутність потреби у відборі помилок(sampling)).

\begin{definition}[RLWR задача]
    \label{def:3-2-9}
    ~\par Нехай $R_q = \mathbb{Z}_q[x]/(x^n + 1)$, $R_p = \mathbb{Z}_p[x]/(x^n + 1)$, де $p < q$. Функція округлення
    застосовуються для кожного коефіцієнта окремо:
    \begin{equation*}
        \lfloor f \rceil_p = \sum\limits_{i=0}^{n-1} \left\lfloor \frac{p}{q} \cdot f_i \right\rceil x^i \bmod p.
    \end{equation*}

    Розпізнавальна задача $\text{Decision-RLWR}_{n,q,p}$ полягає у розрізненні:
    \begin{itemize}
        \item $(a, \lfloor a \cdot s \rceil_p)$, де $a \in R_q$ обрано рівномірно, $s \in R_q$ фіксоване;
        \item $(a, u)$, де $a \in R_q$, $u \in R_p$ обрані рівномірно.
    \end{itemize}
\end{definition}

\begin{claim}
    \label{claim:3-2-1}
    ~\par При певних параметрах $n,q,p$, задача RLWR$_{n,q,p}$ є не легшою за задачу RLWE$_{n,q,\chi}$ з розподілом помилок
    $\chi$, що відповідає помилці округлення.
\end{claim}

У TiGER використовується комбінація: RLWR -- для генерації відкритого ключа (компактність) та RLWE -- для шифрування
(гнучкості у контролі помилок). Модулі обираються як степені двійки: $q = 256$, $p \in \{64, 128\}$, що дозволяє
реалізувати округлення через побітові зсуви. Про це поговоримо детальніше наступному,~\ref{chapter:4} розділі.

\section{"Сімейство"{} алгоритмів на базі RLWE/RLWR}
\label{sec:3-3}

TiGER належить до сімейства алгоритмів на решітках, які базуються на задачах RLWE та RLWR. Опишемо основні алгоритми
цього сімейства, які вплинули на дизайн TiGER (далі). Далі їх буде порівняно у розділі~\ref{chapter:6} та попередньо
у таблиці~\ref{table:3-3-1}.

\subsection{Lizard}
\label{subsec:3-3-1}

Lizard~\cite{lizard2018} був одним з перших алгоритмів, що комбінував у собі LWE та LWR для досягнення балансу між
безпекою та ефективністю.

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} LWE для генерації відкритого ключа, LWR для шифрування;
    \item \textbf{Простір:} Цілочисельні решітки над $\mathbb{Z}_q^n$ без використання кільцевої структури;
    \item \textbf{Модуль:} Малий модуль $q$ для покращення коректності;
    \item \textbf{Розміри:} Великі ключі (через відсутність алгебраїчної структури).
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Консервативна безпека (базується на стандартній LWE);
    \item Низька ймовірність помилки розшифрування.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Великі розміри ключів та шифротекстів;
    \item Повільніше множення векторів (порівняно з кільцевими варіантами).
\end{itemize}

\subsection{RLizard}
\label{subsec:3-3-2}

RLizard~\cite{rlizard2018} є кільцевою версією попереднього алгоритму, оптимізованою для IoT-пристроїв.

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} RLWE для генерації ключів, RLWR для шифрування;
    \item \textbf{Простір:} $R_q = \mathbb{Z}_q[x]/(x^n + 1)$, $n = 512$ або $n = 1024$;
    \item \textbf{Модуль:} Малий модуль $q$ (наприклад, $q = 1024$);
    \item \textbf{Помилки:} Дискретний гаусівський розподіл помилок з високою точністю (CDT-sampling).
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Компактні ключі та шифротексти завдяки кільцевій структурі;
    \item Швидке шифрування/розшифрування;
    \item Висока коректність;
    \item Підходить для пристроїв з обмеженим ресурсом.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Відносно велика пропускна здатність порівняно з найкомпактнішими схемами;
    \item Залежність від якісного(справді випадкового) семплювання гаусівських помилок.
\end{itemize}

\subsection{CRYSTALS-Kyber}
\label{subsec:3-3-3}

Kyber~\cite{kyber2018} є одним з фіналістів конкурсу NIST PQC і базується на Module-LWE (MLWE).

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} MLWE для обох операцій -- генерації ключів та шифрування повідомлення;
    \item \textbf{Простір:} Модульні решітки $R_q^k$, де $k \in \{2, 3, 4\}$ (залежно від рівня безпеки);
    \item \textbf{Модуль:} $q = 3329$ (просте число для ефективного NTT);
    \item \textbf{Оптимізація:} Number Theoretic Transform (NTT) для швидкого множення многочленів (хах, тут
        порівнюючи з чим саме і що вважати швидко);
    \item \textbf{Компресія:} Агресивне "стиснення"{} шифротексту.
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Стандартизовано під NIST (FIPS 203);
    \item Непоганий баланс між розмірами, швидкістю та безпекою;
    \item Ефективна реалізація з NTT.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Використання простого модуля ускладнює деякі оптимізації;
    \item Більший шифротекст порівняно з деякими MLWR-схемами.
\end{itemize}

\subsection{Saber}
\label{subsec:3-3-4}

Saber~\cite{saber2018} є Module-LWR схемою, фіналістом NIST PQC Round 3.

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} MLWR для обох операцій;
    \item \textbf{Простір:} Модульні решітки $R_q^k$, $k \in \{2, 3, 4\}$;
    \item \textbf{Модуль:} $q = 8192 = 2^{13}$;
    \item \textbf{Оптимізація:} Відсутність NTT (округлення завдяки побітовим операціям);
    \item \textbf{Помилки:} Детермініновані (через застосування округлення).
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Компактний шифротекст;
    \item Простота реалізації (без потреби в NTT чи гаусівському семплюванні);
    \item Ефективні побітові операції;
    \item Хороша стійкість до side-channel атак.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Більший(за розміром) відкритий ключ порівняно з Kyber;
\end{itemize}

\newpage %FORCED
\subsection{Порівняння алгоритмів, і що з них взяв TiGER}
\label{subsec:3-3-5}

\begin{table}[ht]
    \centering
    \begin{tblr}{
            colspec = {Q[l,m] Q[c,m] Q[c,m] Q[c,m] Q[c,m]},
            hlines, vlines,
            row{1} = {font=\bfseries}
        }
        Характеристика & Lizard  & RLizard   & Kyber             & Saber        \\
        Структура      & LWE/LWR & RLWE/RLWR & MLWE              & MLWR         \\
        Розмірність    & $n$     & $n$       & $n \times k$      & $n \times k$ \\
        Модуль $q$     & малий   & малий     & 3329              & 8192         \\
        NTT            & Ні      & Ні        & Так               & Ні           \\
        Семплювання    & Гаусс   & Гаусс/CDT & Centered binomial & Округлення   \\
        Компресія      & Помірна & Помірна   & Агресивна         & Помірна      \\
    \end{tblr}
    \caption{Порівняння підходів у сімействі RLWE/RLWR алгоритмів}
    \label{table:3-3-1}
\end{table}

\noindent TiGER об'єднує в собі найкращі ідеї з попередніх доробок:

\textbf{Позиція TiGER:}
\begin{itemize}
    \item Базується на \textbf{RLWE/RLWR} (як RLizard);
    \item Використовує \textbf{степені двійки} для $q, p$ (як Saber);
    \item \textbf{Розріджені секрети} для ефективності;
    \item \textbf{Корекція помилок} (XEf, D2) для мінімізації DFP/R;
    \item \textbf{Без NTT} для простоти;
    \item Фокусування на \textbf{мінімальному шифротексті} для легшого впровадження в існуючі протоколи.
\end{itemize}

\section{Криптографічні примітиви}
\label{sec:3-4}

У цій частині розділу розглянемо базові криптографічні примітиви, що використовуються для безпосередньо при побудові
TiGER: схеми шифрування з відкритим ключем (PKE) та механізми інкапсуляції ключа (KEM).

\subsection{Схема шифрування з відкритим ключем (PKE)}
\label{subsec:3-4-1}

\begin{definition}[PKE схема]
    \label{def:3-4-1}
    ~\par Схема шифрування з відкритим ключем (Public Key Encryption, PKE) складається з трьох алгоритмів:
    \begin{itemize}
        \item $\mathsf{KeyGen}(1^\lambda) \to (\mathsf{pk}, \mathsf{sk})$ --- ймовірнісний алгоритм генерації
            ключів, що на вході приймає параметр безпеки $\lambda$ і повертає пару: відкритий ключ $\mathsf{pk}$ та
            секретний ключ $\mathsf{sk}$;
        \item $\mathsf{Enc}(\mathsf{pk}, m; r) \to c$ --- ймовірнісний алгоритм шифрування, що приймає відкритий
            ключ $\mathsf{pk}$, повідомлення $m$ з простору повідомлень $\mathcal{M}$ та випадкове число $r$, і
            повертає шифротекст $c$;
        \item $\mathsf{Dec}(\mathsf{sk}, c) \to m'$ --- детермінінований алгоритм розшифрування, що приймає
            секретний ключ $\mathsf{sk}$ і шифротекст $c$, та повертає повідомлення $m'$ або помилку -- $\bot$.
    \end{itemize}
\end{definition}

\begin{definition}[Коректність PKE]
    \label{def:3-4-2}
    ~\par PKE схема є $(1-\delta)$-коректною, якщо для будь-якої пари ключів
    $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ та будь-якого повідомлення $m \in \mathcal{M}$ виконується:
    \begin{equation*}
        \mathbb{P}[\mathsf{Dec}(\mathsf{sk}, \mathsf{Enc}(\mathsf{pk}, m)) \neq m] \leq \delta,
    \end{equation*}
    де ймовірність визначається через випадковість алгоритму $\mathsf{Enc}$. Параметр $\delta$ називається
    \textit{ймовірністю помилки розшифрування} (Decryption Failure Probability/Rate, DFP/R)
\end{definition}

У задачах на решітках, через наявність помилок у RLWE/RLWR, коректність не завжди є ідеальною. Тому для практичних
застосувань необхідно, щоб $\delta$ було незначним ($\delta \leq 2^{-128}$).

\subsection{Механізм інкапсуляції ключа (KEM)}
\label{subsec:3-4-2}

\begin{definition}[KEM схема]
    \label{def:3-4-3}
    ~\par Механізм інкапсуляції ключа (Key Encapsulation Mechanism, KEM) складається з трьох кроків:
    \begin{itemize}
        \item $\mathsf{KeyGen}(1^\lambda) \to (\mathsf{pk}, \mathsf{sk})$ --- алгоритм генерації ключів
            (аналогічно до PKE);
        \item $\mathsf{Encaps}(\mathsf{pk}) \to (c, K)$ --- ймовірнісний алгоритм інкапсуляції, що приймає
            відкритий ключ $\mathsf{pk}$ і повертає шифротекст $c$ та спільний секретний ключ $K \in \mathcal{K}$;
        \item $\mathsf{Decaps}(\mathsf{sk}, c) \to K'$ --- детермінований алгоритм декапсуляції, що приймає
            секретний ключ $\mathsf{sk}$ і шифротекст $c$, та повертає прихований секретний ключ $K'$ або символ
            помилки $\bot$.
    \end{itemize}
\end{definition}

\begin{definition}[Коректність KEM]
    \label{def:3-4-4}
    ~\par KEM схема є $(1-\delta)$-коректною, якщо для будь-якої пари ключів
    $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ справджується таке:
    \begin{equation*}
        \mathbb{P}[\mathsf{Decaps}(\mathsf{sk}, c) \neq K : (c, K) \gets \mathsf{Encaps}(\mathsf{pk})] \leq \delta.
    \end{equation*}
\end{definition}

\subsection{Побудова KEM з PKE}
\label{subsec:3-4-3}

Стандартний спосіб побудови KEM з PKE полягає у шифруванні випадкового повідомлення та використанні геш-функції
для отримання спільного ключа.

\begin{claim}[Нативна побудова KEM]
    \label{claim:3-4-1}
    ~\par Нехай $\mathsf{PKE} = (\mathsf{KeyGen}, \mathsf{Enc}, \mathsf{Dec})$ -- PKE це ось така трійка, що містить
    у собі простір повідомлень $\mathcal{M}$, та $H: \mathcal{M} \to \mathcal{K}$ -- деяка геш-функція. Тоді можна
    побудувати KEM
    таким способом:
    \begin{itemize}
        \item Спосіб генерації $\mathsf{KeyGen}$ такий же, як у PKE;
        \item $\mathsf{Encaps}(\mathsf{pk})$: обирають $m \in \mathcal{M}$, а далі обчислюють
            $c \gets \mathsf{Enc}(\mathsf{pk}, m)$ та $K \gets H(m)$. На виході отримано пару: $(c, K)$;
        \item $\mathsf{Decaps}(\mathsf{sk}, c)$: обчислюють $m' \gets \mathsf{Dec}(\mathsf{sk}, c)$ та на виході
            отримуємо $K' \gets H(m')$.
    \end{itemize}
\end{claim}

Така побудова не забезпечує IND-CCA безпеки навіть якщо базова PKE схема є IND-CPA безпечною, але для нас головне
щоб було зрозуміло як цей механізм працює). А для досягнення IND-CCA безпеки вже необхідно застосувати перетворення
Fujisaki-Okamoto (розглянемо його у секції~\ref{sec:3-6}).

\subsection{Криптографічні геш-функції}
\label{subsec:3-4-4}

\begin{definition}[Криптографічна геш-функція]
    \label{def:3-4-5}
    ~\par Функція $H: \{0,1\}^* \to \{0,1\}^n$ називається криптографічною геш-функцією, якщо вона задовольняє
    наступні умови:
    \begin{enumerate}
        \item \textbf{Стійкість до знаходження прообразу:} Для випадкового $y \in \{0,1\}^n$ обчислювально
            важко знайти $x$ такий, що $H(x) = y$;
        \item \textbf{Стійкість до знаходження другого прообразу:} Для заданого $x$ обчислювально важко знайти
            $x' \neq x$ такий, що $H(x') = H(x)$;
        \item \textbf{Стійкість до колізій:} Обчислювально важко знайти дві різні величини $x, x'$
            такі, що $H(x) = H(x')$.
    \end{enumerate}
\end{definition}

У TiGER використовуються геш-функції з сімейства SHA-3 -- SHAKE256 (або SHA3-256) для генерації випадковості, обчислення
спільних ключів та інших криптографічних операцій. SHAKE256 є функцією з розширеним виходом (XOF), що дозволяє
генерувати вихід довільної довжини.

\subsection{Зв'язок PKE та KEM у TiGER}
\label{subsec:3-4-5}

TiGER складається з двох рівнів:
\begin{enumerate}
    \item \textbf{TiGER.PKE} -- являє собою базову IND-CPA безпечну схему шифрування, що базується на RLWE(R);
    \item \textbf{TiGER.KEM} -- KEM, отриманий застосуванням перетворення Fujisaki-Okamoto (FO) до TiGER.PKE
        для досягнення IND-CCA безпеки.
\end{enumerate}
Це дозволяє:
\begin{itemize}
    \item Окремо аналізувати безпеку PKE (на базі RLWE/RLWR);
    \item Використовувати загальні результати про перетворення FO для доведення IND-CCA безпеки KEM;
\end{itemize}

\section{Основні поняття безпеки, що стосуються TiGER}
\label{sec:3-5}

\subsection{IND-CPA безпека}
\label{subsec:3-5-1}

\begin{definition}[IND-CPA (Indistinguishability under Chosen-Plaintext Attack) гра для PKE]
    \label{def:3-5-1}
    ~\par Розглянемо наступну "гру"{} між претендентом (challenger) $\mathcal{C}$ та супротивником (adversary) $\mathcal{A}$:
    \begin{enumerate}
        \item $\mathcal{C}$ генерує $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ і передає
            $\mathsf{pk}$ супротивнику $\mathcal{A}$;
        \item $\mathcal{A}$ обирає два повідомлення $m_0, m_1 \in \mathcal{M}$ однакової довжини і передає їх
            $\mathcal{C}$;
        \item $\mathcal{C}$ Випадковим чином обирає біт $b \xleftarrow{p} \{0,1\}$, обчислює
            $c \gets \mathsf{Enc}(\mathsf{pk}, m_b)$ і передає $c$ супротивнику $\mathcal{A}$;
        \item $\mathcal{A}$ виводить біт $b'$.
    \end{enumerate}
    Перевага супротивника визначається наступним чином:
    \begin{equation*}
        \mathsf{Adv}^{\text{IND-CPA}}_{\mathsf{PKE}}(\mathcal{A}) = \left| \mathbb{P}[b' = b] - \frac{1}{2} \right|
        + \varepsilon(\lambda).
    \end{equation*}

    PKE схема є IND-CPA безпечною, якщо для будь-якого ефективного (PPT) супротивника $\mathcal{A}$ перевага
    $\mathsf{Adv}^{\text{IND-CPA}}_{\mathsf{PKE}}(\mathcal{A})$ є незначною функцією від $\lambda$.
\end{definition}

IND-CPA безпечність означає нерозрізненість шифротекстів: супротивник маючи доступ до відкритого ключа (а отже,
має можливість шифрувати будь-які повідомлення), не може визначити, яке з двох повідомлень було зашифроване. Це
вимагає від шифрування, щоб воно було ймовірнісним.

\begin{definition}[IND-CPA (Indistinguishability under Chosen-Plaintext Attack) безпека для KEM]
    \label{def:3-5-2}
    ~\par Для KEM "гра"{} IND-CPA визначається аналогічно:
    \begin{enumerate}
        \item $\mathcal{C}$ генерує пару $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ і
            передає $\mathsf{pk}$ супротивнику $\mathcal{A}$;
        \item $\mathcal{C}$ обирає $b \xleftarrow{p} \{0,1\}$. Якщо обрано $b = 0$, то обчислює
            $(c, K_0) \gets \mathsf{Encaps}(\mathsf{pk})$; а якщо $b = 1$, обчислює
            $(c, K_0) \gets \mathsf{Encaps}(\mathsf{pk})$ та $K_1 \xleftarrow{p} \mathcal{K}$.
            Опісля передає пару $(c, K_b)$ супротивнику;
        \item $\mathcal{A}$ виводить біт $b'$.
    \end{enumerate}
    Перевага cупротивника $\mathsf{Adv}^{\text{IND-CPA}}_{\mathsf{KEM}}(\mathcal{A})$ визначається аналогічно як і в PKE.
\end{definition}

Безпека KEM тісно пов'язана з:
\begin{itemize}
    \item IND-CPA безпекою базової PKE схеми;
    \item Ймовірністю помилки розшифрування $\varepsilon$;
    \item Параметрами випадкових оракулів (про трохи далі).
\end{itemize}

Важливим є те, що навіть за наявності помилок розшифрування (що неминуче для схем на решітках), можна довести
IND-CCA безпеку за умови достатньо малого $\varepsilon(\lambda)$.

\subsection{IND-CCA безпека}
\label{subsec:3-5-2}

\begin{definition}[IND-CCA для PKE]
    \label{def:3-5-3}
    ~\par "Гра"{} IND-CCA відрізняється від IND-CPA тим, що противник $\mathcal{A}$ має додатково доступ до оракула
    дешифратора (decryption oracle) $\mathsf{Dec}(\mathsf{sk}, \cdot)$:
    \begin{enumerate}
        \item $\mathcal{C}$ генерує $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ і передає
            $\mathsf{pk}$ супротивнику $\mathcal{A}$;
        \item $\mathcal{A}$ робить запити до оракула дешифрування, подаючи на вхід довільні шифротексти $c_i$ і
            отримувати $m_i = \mathsf{Dec}(\mathsf{sk}, c_i)$;
        \item $\mathcal{A}$ обирає $m_0, m_1$ і отримує challenge шифротекст
            $c^{*} \gets \mathsf{Enc}(\mathsf{pk}, m_b)$ для випадкового $b$;
        \item $\mathcal{A}$ продовжує робити запити до оракула дешифрування, але не може запитувати $c^{*}$ -- випадок
            \textbf{IND-CCA2} (а якщо запити заборонені вже після отримання $c^{*}$ -- це \textbf{IND-CCA1});
        \item $\mathcal{A}$ виводить біт $b'$.
    \end{enumerate}
    Перевага $\mathsf{Adv}^{\text{IND-CCA}}_{\mathsf{PKE}}(\mathcal{A})$ визначається аналогічно.
\end{definition}

\begin{definition}[IND-CCA безпека для KEM]
    \label{def:3-5-4}
    ~\par Для KEM схеми противник має доступ до оракула декапсуляції $\mathsf{Decaps}(\mathsf{sk}, \cdot)$ і
    \textbf{не може} запитувати challenge шифротекст $c^*$ після його отримання.
\end{definition}

IND-CCA (Indistinguishability under Chosen Ciphertext Attack) безпека є значно сильнішою, ніж IND-CPA, оскільки
моделює активного противника, який може маніпулювати шифротекстами та спостерігати результати дешифрування. Для
практичних застосувань зазвичай потрібна IND-CCA2 безпека.

\subsection{Ймовірність помилки розшифрування (DFP/R)}
\label{subsec:3-5-3}

\begin{definition}[Decryption Failure Probability/Rate]
    \label{def:3-5-5}
    ~\par Для PKE схеми ймовірність помилки розшифрування (DFP/R) визначається як:
    \begin{equation*}
        \delta = \max_{m \in \mathcal{M}} \mathbb{P}_{(\mathsf{pk},\mathsf{sk}),r}
        [\mathsf{Dec}(\mathsf{sk}, \mathsf{Enc}(\mathsf{pk}, m; r)) \neq m],
    \end{equation*}
    де ймовірність береться за випадковістю генерації ключів та шифрування.

    Для KEM схеми:
    \begin{equation*}
        \delta = \mathbb{P}_{(\mathsf{pk},\mathsf{sk}),(c,K)}[\mathsf{Decaps}(\mathsf{sk}, c) \neq K].
    \end{equation*}
\end{definition}

У решіткових схемах помилки розшифрування виникають природнім шляхом (наявність шуму у RLWE/RLWR), тому параметри
схеми (розміри модулів, розподіл помилок, коефіцієнт стиснення) мають бути підібрані так, щоб забезпечити мале $\delta$.

\noindent (!) Висока ймовірність помилки розшифрування може призвести до наступних атак:
\begin{itemize}
    \item \textbf{Failure boosting attacks~\cite{dhooghe2018}:} Супротивник може ітеративно створювати шифротексти,
        що мають високу ймовірність помилки, щоб витягувати поступово інформацію про секретний ключ;
    \item \textbf{Multi-target attacks~\cite{danvers2022}:} При наяності багатьох публічних ключів або сесій,
        навіть відносно мала DFP/R може стати проблемою.
\end{itemize}

\noindent Для реалізацій TiGER цільова DFP/R становить:
\begin{itemize}
    \item TiGER128: $\delta \approx 2^{-120}$;
    \item TiGER192: $\delta \approx 2^{-136}$;
    \item TiGER256: $\delta \approx 2^{-167}$.
\end{itemize}
P.S. Ці значення вважаються достатньо малими для практичного застосування.

\subsection{Квантова безпека a.k.a. QROM}
\label{subsec:3-5-4}

\begin{definition}[Quantum Random Oracle Model]
    \label{def:3-5-6}
    ~\par Модель квантового випадкового оракула (скорочено QROM) -- це розширення класичної моделі випадкового
    оракула (ROM), де противник має квантовий доступ до геш-функцій, тобто може ще робити запити у суперпозиції.
\end{definition}

\noindent Для TiGER необхідно, щоб перетворення Fujisaki-Okamoto забезпечувало IND-CCA безпеку у QROM, це гарантуватиме
стійкість проти квантових атак.

\section{Перетворення Fujisaki-Okamoto}
\label{sec:3-6}

Перетворення Fujisaki-Okamoto (скорочено FO)~\cite{fo1999,fo2013} є загальним методом перетворення IND-CPA безпечної
PKE схеми у IND-CCA безпечну KEM схему. В цьому підпункті наведемо просте класичне FO перетворення та його модифікацію --
варіант з неявним відхиленням, що використовується в TiGER.

\subsection{Класичне перетворення FO}
\label{subsec:3-6-1}

\begin{theorem}[Fujisaki-Okamoto]
    \label{theorem:3-6-1}
    ~\par Нехай $\mathsf{PKE} = (\mathsf{KeyGen}, \mathsf{Enc}, \mathsf{Dec})$ -- IND-CPA безпечна PKE схема з
    однозначним детермінованим розшифруванням. Нехай $G: \mathcal{M} \to \mathcal{R} \times \mathcal{K}$ та
    $H: \mathcal{M} \times \mathcal{C} \to \mathcal{K}$ -- випадкові оракули. Тоді наступна конструкція є
    IND-CCA безпечною KEM у моделі випадкового оракула~\cite{fo1999}:
    \begin{algorithm}[H]
        \caption{KeyGen()}
        \begin{algorithmic}[1]
            \State Generate $(pk, sk) \gets $ PKE.KeyGen$(1^\lambda)$
            \State \Return $(pk, sk)$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Encaps$(pk)$}
        \begin{algorithmic}[1]
            \State Choose $m \xleftarrow{p} \mathcal{M}$
            \State Calculate $(r, K) \gets G(m)$
            \State Calculate $c \gets$ PKE.Enc$(pk, m; r)$
            \State \Return $(c, K)$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Decaps$(sk, c)$}
        \begin{algorithmic}[1]
            \State Calculate $m' \gets$ PKE.Dec$(sk, c)$
            \State Calculate $(r', K') \gets G(m')$
            \State Calculate $c' \gets$ PKE.Enc$(pk, m'; r')$
            \If{$c = c'$}
            \State \Return $K'$
            \Else
            \State \Return $\bot$
            \EndIf
        \end{algorithmic}
    \end{algorithm}
\end{theorem}

\noindent \textbf{Ключова ідея перетворення FO} полягає у \textbf{\textit{повторному шифруванні}} (re-encryption):
після розшифрування повідомлення $m'$ воно повторно шифрується з тією ж випадковістю, і результат порівнюється з
отриманим шифротекстом. Це дозволяє виявити модифікації шифротексту.

\subsection{Перетворення \texorpdfstring{$\mathsf{FO}^{\not\bot}_m$}{FO} з неявним відхиленням}
\label{subsec:3-6-2}

Для схем на решітках з ненульовою ймовірністю помилки розшифрування було розроблено модифікацію -- варіант FO з
\textit{неявним відхиленням} (implicit rejection)~\cite{hofheinz2017}.

\begin{definition}[Перетворення $\mathsf{FO}^{\not\bot}_m$]
    \label{def:3-6-1}
    ~\par Нехай $\mathsf{PKE}$ -- IND-CPA безпечна PKE схема. Конструкція $\mathsf{FO}^{\not\bot}_m$ відрізняється
    від класичного FO у додатковій декапсуляції:

    \begin{algorithm}[H]
        \caption{KeyGen()}
        \begin{algorithmic}[1]
            \State Generate $(pk, sk') \gets$ PKE.KeyGen$(1^\lambda)$
            \State Choose $z \xleftarrow{p} \mathcal{Z}$ \Comment{Додатковий випадковий ключ}
            \State \Return $(pk, sk = (sk', z))$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Encaps$(pk)$}
        \begin{algorithmic}[1]
            \State Choose $m \xleftarrow{p} \mathcal{M}$
            \State Calculate $r \gets G(m, pk)$
            \State Calculate $c \gets$ PKE.Enc$(pk, m; r)$
            \State Calculate $K \gets H(m, c)$
            \State \Return $(c, K)$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Decaps$(sk, c)$}
        \begin{algorithmic}[1]
            \State Split $sk = (sk', z)$
            \State Calculate $m' \gets$ PKE.Dec$(sk', c)$
            \State Calculate $r' \gets G(m', pk)$
            \State Calculate $c' \gets$ PKE.Enc$(pk, m'; r')$
            \If{$c = c'$}
            \State \Return $K' \gets H(m', c)$
            \Else
            \State \Return $\overline{K} \gets H(z, c)$ \Comment{Неявне відхилення}
            \EndIf
        \end{algorithmic}
    \end{algorithm}
\end{definition}

\noindent \textbf{Ключова відмінність:} замість повернення $\bot$ при невдалій перевірці, алгоритм повертає
псевдовипадковий ключ $\overline{K} = H(z, c)$, де $z$ -- секретний випадковий ключ. Це має дві переваги:
\begin{itemize}
    \item \textbf{Захист від side-channel атак:} Оскільки зовнішньому спостерігачу стає важче визначити, чи
        відбулася помилка при декапсуляції;
    \item \textbf{Постійний час виконання:} Обидва варіанти (успіх/невдача) тепер виконують однакові операції гешування.
\end{itemize}

\subsection{Застосування у алгоритмі TiGER}
\label{subsec:3-6-4}

TiGER.KEM побудовано із застосуванням варіанту перетворення $\mathsf{FO}^{\not\bot}_m$ до TiGER.PKE:

\begin{itemize}
    \item \textbf{TiGER.PKE:} Базується на RLWR (для відкритого ключа) та RLWE (для шифрування), забезпечує
        IND-CPA безпеку;
    \item \textbf{Геш-функції:} Використовуються $G = H = \mathsf{SHAKE256}$ (функція з розширеним виходом)
        для генерації випадковості та спільних ключів;
    \item \textbf{Додаткове гешування:} Відкритий ключ $\mathsf{pk}$ гешується разом з повідомленням:
        $r \gets G(m, H(\mathsf{pk}))$, що забезпечує захист від multi-target атак;
    \item \textbf{Неявне відхилення:} При невдалій декапсуляції повертається $\overline{K} = H(z, c)$, що захищає від
        витоку інформації про помилки та розкритті хоч і мізерної, та інформації, про ключ.
\end{itemize}

\chapter{\large{Повний опис алгоритму TiGER}}
\label{chapter:4}

\section{Загальна структура алгоритму}
\label{sec:4-1}

TiGER має модульну архітектуру, що складається з двох рівнів: базової схеми шифрування з відкритим ключем
(TiGER.PKE) та механізму інкапсуляції ключа (TiGER.KEM), отриманого застосуванням перетворення Fujisaki-Okamoto
до PKE схеми.

\subsection{Модульна побудова алгоритму}
\label{subsec:4-1-1}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[node distance=2cm, >=stealth, thick]
        % Nodes
        \node[draw, rectangle, minimum width=3cm, minimum height=1cm] (pke) {TiGER.PKE};
        \node[draw, rectangle, minimum width=3cm, minimum height=1cm, below=of pke] (fo) {Перетворення FO$^{\not\bot}_m$};
        \node[draw, rectangle, minimum width=3cm, minimum height=1cm, below=of fo] (kem) {TiGER.KEM};

        % Arrows
        \draw[->] (pke) -- (fo) node[midway, right] {IND-CPA};
        \draw[->] (fo) -- (kem) node[midway, right] {IND-CCA};

        % Side labels
        \node[left=2cm of pke] (rlwe) {RLWE/RLWR};
        \draw[->] (rlwe) -- (pke);

        \node[right=2cm of fo] (hash) {Hash функції};
        \draw[->] (hash) -- (fo);
    \end{tikzpicture}
    \caption{Модульна структура TiGER}
    \label{fig:4-1-1}
\end{figure}

Конструкція TiGER базується на трьох наступних принципах:

\begin{enumerate}
    \item \textbf{Перший крок -- TiGER.PKE:} Схема шифрування з відкритим ключем, що використовує комбінацію RLWR
        для генерації відкритого ключа та RLWE для шифрування повідомлень. На припущення складності RLWE та RLWR
        задач маємо IND-CPA безпеку.
    \item \textbf{Перетворення FO$^{\not\bot}_m$:} Варіант перетворення Fujisaki-Okamoto з неявним відхиленням, що
        перетворює IND-CPA безпечну PKE схему в IND-CCA безпечну KEM схему використовує геш-функції SHAKE256 та
        SHA3-256 як випадкові оракули $H: \mathcal{M} \times \mathcal{C} \to \mathcal{K}$.
    \item \textbf{Вихід -- TiGER.KEM:} Повний механізм інкапсуляції ключа з IND-CCA безпекою у моделі
        квантового випадкового оракула (QROM), придатний для практичного використання у постквантових протоколах.
\end{enumerate}

\subsection{Взаємодія між компонентами TiGER}
\label{subsec:4-1-2}

Взаємодія між компонентами відбувається наступним чином:

\textbf{Генерація ключів:}
\begin{itemize}
    \item TiGER.PKE генерує пару $(\mathsf{pk}, \mathsf{sk}')$ використовуючи RLWR;
    \item TiGER.KEM додає випадковий ключ $z$ до секретного ключа: $\mathsf{sk} = (\mathsf{sk}', z)$;
    \item Відкритий ключ $\mathsf{pk}$ гешується для захисту від multi-target атак.
\end{itemize}

\textbf{Інкапсуляція:}
\begin{itemize}
    \item Генерується випадкове повідомлення $m$;
    \item геш-функція $G$ обчислює детерміновану випадковість $r$ з $m$ та гешу $\mathsf{pk}$;
    \item TiGER.PKE шифрує $m$ з випадковістю $r$ і видає шифротекст $c$;
    \item Спільний ключ $K$ обчислюється як $H(m, c)$.
\end{itemize}

\textbf{Декапсуляція:}
\begin{itemize}
    \item TiGER.PKE розшифровує шифротекст $c$ та повертає повідомлення $m'$;
    \item Виконується повторне шифрування (re-encryption) $m'$ для перевірки цілісності;
    \item Якщо перевірка успішна, повертається $K' = H(m', c)$;
    \item Якщо перевірка невдала, повертається псевдовипадковий ключ $\overline{K} = H(z, c)$ (неявне відхилення).
\end{itemize}

\section{Публічні параметри}
\label{sec:4-2}

TiGER визначає три набори параметрів, що відповідають трьом рівням безпеки згідно з класифікацією NIST: 
TiGER128 (рівень 1), TiGER192 (рівень 3) та TiGER256 (рівень 5). Розглянемо детальніше значення кожного 
параметра та обґрунтування їх вибору.

\newpage % FORCED
\begin{table}[ht]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Параметр}                & \textbf{TiGER128} & \textbf{TiGER192} & \textbf{TiGER256} \\
        \hline
        \hline
        $n$                              & 512               & 1024              & 1024              \\
        \hline
        $q$                              & $2^{14}$          & $2^{15}$          & $2^{16}$          \\
        \hline
        $p$                              & $2^{10}$          & $2^{11}$          & $2^{11}$          \\
        \hline
        $k_1$ (бітів для $\mathbf{b}$)   & 10                & 11                & 11                \\
        \hline
        $k_2$ (бітів для $\mathbf{c}_1$) & 4                 & 4                 & 5                 \\
        \hline
        $h_s$                            & 274               & 284               & 274               \\
        \hline
        $h_r$                            & 274               & 284               & 274               \\
        \hline
        $h_e$                            & 274               & 284               & 274               \\
        \hline
        $d$ (для XEf)                    & 8                 & 8                 & 9                 \\
        \hline
        $f$ (для D2)                     & 2                 & 2                 & 2                 \\
        \hline
        \hline
        $|\mathsf{pk}|$ (кількість байт) & 804               & 1568              & 1568              \\
        \hline
        $|\mathsf{sk}|$ (кількість байт) & 1876              & 3680              & 3680              \\
        \hline
        $|\mathsf{ct}|$ (кількість байт) & 804               & 1408              & 1600              \\
        \hline
        Рівень безпеки NIST              & 1                 & 3                 & 5                 \\
        \hline
        Класична безпека (кількість біт) & 143               & 207               & 272               \\
        \hline
        Квантова безпека (кількість біт) & 128               & 192               & 256               \\
        \hline
        DFP                              & $2^{-120}$        & $2^{-136}$        & $2^{-167}$        \\
        \hline
    \end{tabular}
    \caption{Параметри TiGER для різних рівнів безпеки}
    \label{table:4-2-1}
\end{table}

\textbf{Структурні параметри:}
\begin{itemize}
    \item \textbf{$n$} --- степінь многочлена, що визначає розмірність поліноміального кільця $R = \mathbb{Z}[x]/(x^n + 1)$. 
        Більше $n$ забезпечує вищу безпеку, але і водночас збільшує обчислювальну складність та розміри ключів;
    \item \textbf{$q$} --- основний модуль, що визначає кільце $R_{q} = R/qR$. В даному алгоритмі обрано як степінь 
        двійки для оптимізації операцій модульної арифметики.
    \item \textbf{$p$} --- модуль для RLWR округлення при генерації відкритого ключа. Задовольняє $p < q$ та 
        також є степенем двійки. Відношення $q/p$ визначає рівень "шуму"{} від округлення.
\end{itemize}

\textbf{Параметри для стиснення:}
\begin{itemize}
    \item \textbf{$k_{1}$} --- кількість біт для представлення компонент вектора $\mathbf{b}$ у відкритому ключі. 
        Стиснення з $\log_{2} q$ до $k_{1}$ біт зменшує розмір відкритого ключа;
    \item \textbf{$k_{2}$} --- кількість біт для представлення першої частини шифротексту $\mathbf{c}_1$. 
        Агресивніша компресія зменшує розмір шифротексту, але збільшує ймовірність помилки розшифрування(!).
\end{itemize}

\textbf{Параметри розподілів помилок:}
\begin{itemize}
    \item \textbf{$h_s$} --- вага Геммінга (Hamming weight) секретного ключа $\mathbf{s}$. TiGER використовує 
        розріджені тернарні многочлени з коефіцієнтами $\{-1, 0, 1\}$, де рівно $h_s$ коефіцієнтів є ненульовими;
    \item \textbf{$h_r$} --- вага Геммінга помилки $\mathbf{r}$ при генерації відкритого ключа (RLWR);
    \item \textbf{$h_e$} --- вага Геммінга для помилок $\mathbf{e}_1, \mathbf{e}_2$ при шифруванні (RLWE).
\end{itemize}

\textbf{Параметри кодів корекції помилок:}
\begin{itemize}
    \item \textbf{$d$} --- параметр коду XEf (extended XOR-based error correction). Визначає кількість біт 
        повідомлення, які кодуються разом. Чим більше $d$, тим краща корекція помилок, але при цьому збільшуються 
        обчислення;
    \item \textbf{$f$} --- параметр коду D2 (duplication code). Визначає частоту дублювання бітів повідомлення для 
        додаткового захисту від помилок DFP/R.
\end{itemize}

\noindent Фактичні бітові розміри криптографічних об'єктів обчислюються наступним чином:

\textbf{Відкритий ключ} $\mathsf{pk} = (\rho, \mathbf{b})$:
\begin{equation*}
    |\mathsf{pk}| = 32 + n \cdot k_1 / 8 \text{ байт},
\end{equation*}
де 32 байти -- розмір seed $\rho$, який використовується для генерації випадкового многочлена 
$\mathbf{a} \in R_q$. Замість зберігання повного многочлена $\mathbf{a}$ (що займало б $n \log_2 q$ біт) пам'яті, 
зберігається лише seed, з якого $\mathbf{a}$ відновлюється за потреби. Компонента $\mathbf{b}$ -- це результат 
RLWR обчислення $\mathbf{b} = \lfloor \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \rfloor_p$, стиснута до $k_{1}$ 
біта на кожен коефіцієнт.

\textbf{Секретний ключ} $\mathsf{sk} = (\mathsf{sk}', z, h, \mathsf{pk})$:
\begin{equation*}
    |\mathsf{sk}| = |\mathsf{sk}'| + 32 + 32 + |\mathsf{pk}| \text{ байт},
\end{equation*}
де $\mathsf{sk}'$ -- зжате представлення розрідженого секретного ключа $\mathbf{s}$, $z$ та $h$ --- 32-байтові 
значення для FO перетворення.

\textbf{Шифротекст} $\mathsf{ct} = (\mathbf{c}_1, \mathbf{c}_2)$:
\begin{equation*}
    |\mathsf{ct}| = n \cdot k_2 / 8 + n / 8 \text{ байт}.
\end{equation*}

Параметри TiGER були підібрані розробниками з урахуванням наступних критеріїв:

\begin{enumerate}
    \item \textbf{Безпека:} Забезпечують стійкість до відомих атак на RLWE/RLWR, включаючи атаки з використанням 
        решіткових алгоритмів (BKZ, LatticeSieve) на класичних та квантових комп'ютерах. Запас безпеки становить 
        10-15 біт понад нормово;
    \item \textbf{Коректність:} Ймовірність помилки розшифрування (DFP/R) не перевищує $2^{-120}$ для всіх наборів 
        параметрів, що є достатнім для практичного використання;
    \item \textbf{Ефективність:} Вибір степенів двійки для модулів дозволяє використовувати швидкі побітові 
        операції, а розріджені секрети прискорюють множення многочленів;
    \item \textbf{Компактність:} Параметри компресії ($k_1, k_2$) обрані так, щоб мінімізувати розміри при 
        збереженні прийнятного рівня DFP/R. Коди корекції помилок дозволяють застосовувати агресивнішу компресію 
        без погіршення коректності.
\end{enumerate}

\section{Допоміжні алгоритми}
\label{sec:4-3}

TiGER використовує набір допоміжних алгоритмів для генерації випадкових величин, розширення seed-значень та 
корекції помилок.

\begin{enumerate}
    \item \textbf{Алгоритм $\mathsf{HWT}_h$} відповідає за генерацію розрідженого тернарного многочлена з 
        фіксованою вагою Геммінга.
        \begin{algorithm}[H]
            \caption{$\mathsf{HWT}_h$}
            \begin{algorithmic}[1]
                \State Input: Seed $\sigma \in \{0,1\}^{256}$, weight $h \leq n$.
                \State Output: Поліном $\mathbf{s} \in R$ з коефіцієнтами $\{-1, 0, 1\}$ та рівно $h$ ненульовими коефіцієнтами.
            \end{algorithmic}
        \end{algorithm}
        Алгоритм використовує SHAKE256 для генерації послідовності випадкових індексів та знаків. Спочатку обираються 
        $h$ різних позицій в діапазоні $[0, n-1]$, потім для кожної позиції генерується випадковий знак $\pm 1$. 
        Використовується метод rejection sampling для забезпечення рівномірного розподілу індексів. Виконується 
        за константний час (з точністю до rejection sampling).
    \item \textbf{Алгоритм $\mathsf{expandA}$} --- генерація псевдовипадкового многочлена $\mathbf{a}$ з seed.
        \begin{algorithm}[H]
            \caption{$\mathsf{HWT}_h$}
            \begin{algorithmic}[1]
                \State Input: Seed $\rho \in \{0,1\}^{256}$.
                \State Output: Многочлен $\mathbf{a} \in R_q$ з рівномірно розподіленими коефіцієнтами.
            \end{algorithmic}
        \end{algorithm}
        Тут також використовується SHAKE256 як додаткова псевдовипадковость (PRG). Seed $\rho$ розширюється до 
        послідовності байтів, які інтерпретуються як коефіцієнти многочлена в $\mathbb{Z}_q$. Застосовується 
        rejection sampling для забезпечення рівномірності: якщо згенероване значення $\geq q$, воно відкидається і 
        генерується нове. Многочлен $\mathbf{a}$ використовується у RLWR для обчислення відкритого ключа: 
        $\mathbf{b}$ та у RLWE при шифруванні.

        Цей підхід дозволяє зберігати у відкритому ключі лише 32 байти seed замість повного многочлена, що займав 
        би $n \log_2 q$ біт --- для TiGER256 це 1024 × 16 = 16384 біт = 2048 байт). 
        Обидві сторони (відправник і отримувач) можуть незалежно відновити $\mathbf{a}$ з $\rho$.
    \item \textbf{Алгоритми корекції помилок $\mathsf{eccENC}$ та $\mathsf{eccDEC}$} --- кодування та декодування 
        повідомлення для зниження DFP/R.
        \begin{itemize}
            \item Код XEf (XOR-based error correction with extension): Повідомлення розбивається на блоки по $d$ 
                біт. Для кожного блоку обчислюється біт парності як ксор (XOR) усіх біт блоку та додається до 
                закодованого повідомлення. Це дозволяє виявити та виправити одиночні помилки в кожному блоці. При 
                декодуванні для кожного блоку перевіряється цей біт парності. Якщо він не збігається, алгоритм 
                намагається виправити помилку перебором всіх $d$ позицій у блоці.
                \item Код D2 (Duplication code): Додатковий рівень захисту, що дублює кожен біт повідомлення $f$ 
                разів. При декодуванні використовується мажоритарне голосування (majority voting): якщо більшість 
                копій біта мають значення 1, результат буде 1, інакше -- 0.
        \end{itemize}
        TiGER застосовує спочатку код XEf, потім код D2, що дає двоетапну систему корекції помилок. Це дозволяє 
        використовувати агресивнішу компресію шифротексту при збереженні низької DFP/R.
    \item \textbf{Геш-функції} --- використовуються для генерації випадковостей та обчислення спільних ключів у перетворенні FO.
        \begin{itemize}
            \item \textit{SHAKE256:} Функція з розширеним виходом (XOF) зі стандарту SHA-3. Використовується першочергово 
                як генератор псевдовипадковості (PRG) у $\mathsf{expandA}$ та $\mathsf{HWT}_h$, функція $G$ у перетворенні 
                FO для отримання детермінованої випадковості з повідомлення та для генерації довгих послідовностей 
                псевдовипадкових байтів.
            \item \textit{SHA3-256:} Криптографічна геш-функція зі стандарту SHA-3. Використовується як функція 
                $H$ у перетворенні Fujisaki-Okamoto для обчислення спільного ключа $K = H(m, c)$, гешуванні відкритого 
                ключа для захисту від multi-target атак та для генерації фінального спільного ключа фіксованого 
                розміру (256 біт).
        \end{itemize}
        Обидві ці функції є частиною стандарту FIPS 202 (2015 р) та мають формальний аналіз безпеки. У моделі 
        квантового випадкового оракула (QROM) вони моделюються як ідеальні випадкові функції та доступними супротивнику.
\end{enumerate}

\section{TiGER.PKE}
\label{sec:4-4}

TiGER.PKE це базова схема шифрування з відкритим ключем, що забезпечує IND-CPA безпеку. Схема використовує 
комбінацію RLWR для генерації відкритого ключа та RLWE для шифрування повідомлень.

\subsection{KeyGen -- генерація ключів}
\label{subsec:4-4-1}

Алгоритм генерації ключів створює пару відкритий\&секретний ключ на основі RLWR.

\begin{algorithm}[H]
    \caption{TiGER.PKE.KeyGen()}
    \label{alg:4-4-1}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Параметри $(n, q, p, h_s, h_r, k_1)$
        \State \textbf{Output:} Відкритий ключ $pk$, секретний ключ $sk$
        \State
        \State Generate seed $\rho \xleftarrow{p} \{0,1\}^{256}$
        \State Generate seed $\sigma_s \xleftarrow{p} \{0,1\}^{256}$
        \State Generate seed $\sigma_r \xleftarrow{p} \{0,1\}^{256}$
        \State
        \State $\mathbf{a} \gets \mathsf{expandA}(\rho)$ \Comment{Expand seed в многочлен}
        \State $\mathbf{s} \gets \mathsf{HWT}_{h_s}(\sigma_s)$ \Comment{Sparse секретний ключ}
        \State $\mathbf{r} \gets \mathsf{HWT}_{h_r}(\sigma_r)$ \Comment{Sparse error}
        \State
        \State $\mathbf{b}' \gets \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \in R_q$ \Comment{RLWR обчислення}
        \State $\mathbf{b}' \gets \lfloor \mathbf{b}' \cdot (p/q) \rceil \in R_p$ \Comment{Округлення за$\mod p$}
        \State $\mathbf{b} \gets \mathsf{Compress}(\mathbf{b}', k_1)$ \Comment{Компресія до $k_1$ біт}
        \State
        \State $pk \gets (\rho, \mathbf{b})$
        \State $sk \gets \sigma_s$ \Comment{Save secret seed(!)}
        \State \Return $(pk, sk)$
    \end{algorithmic}
\end{algorithm}

Кроки алгоритму (якщо словами):

\begin{enumerate}
    \item \textbf{Генерація seeds:} Спершу створюються три незалежні 256-бітні seeds:
        \begin{itemize}
            \item $\rho$ --- для генерації публічного многочлена $\mathbf{a}$;
            \item $\sigma_s$ --- для генерації секретного ключа $\mathbf{s}$;
            \item $\sigma_r$ --- для генерації помилки $\mathbf{r}$.
        \end{itemize}
    \item \textbf{Expand $\mathbf{a}$:} Використовується алгоритм $\mathsf{expandA}$ для детермінованої генерації 
        рівномірно випадкового многочлена $\mathbf{a} \in R_q$ з seed $\rho$.
    \item \textbf{Генерація розріджених многочленів:}
        \begin{itemize}
            \item Секретний ключ $\mathbf{s}$ генерується як тернарний многочлен з вагою Геммінга $h_s$;
            \item Помилка $\mathbf{r}$ аналогічно генерується з вагою $h_r$.
        \end{itemize}
    \item \textbf{RLWR:} Обчислюється $\mathbf{b}' = \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \in R_q$, після чого 
        виконується округлення до найближчого цілого модуля $p$: $\lfloor \mathbf{b}' \cdot (p/q) \rceil$. Операція 
        округлення вводить детермінований "шум"{}, що замінює явну помилку в класичному RLWE.
    \item \textbf{Компресія:} Многочлен $\mathbf{b}'$ стискається з $\log_{2} p$ біт до $k_{1}$ біт на коефіцієнт 
        для зменшення розміру відкритого ключа.
    \item \textbf{Формування ключів:} Відкритий ключ містить seed $\rho$ та стиснений $\mathbf{b}'$, а секретний 
        ключ зберігається у вигляді seed $\sigma_s$, з якого можна відновити $\mathbf{s}$ за потреби.
\end{enumerate}

\subsection{Encryption -- шифрування}
\label{subsec:4-4-2}

Алгоритм шифрування перетворює повідомлення в шифротекст використовуючи RLWE.

\begin{algorithm}[H]
    \caption{TiGER.PKE.Enc$(pk, m; r)$}
    \label{alg:4-4-2}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Відкритий ключ $pk = (\rho, \mathbf{b})$, повідомлення $m \in \{0,1\}^{256}$, 
            випадковість $r$
        \State \textbf{Output:} Шифротекст $ct = (\mathbf{c}_1, \mathbf{c}_2)$
        \State
        \State Parse seeds from $r$: $(\sigma_{e_1}, \sigma_{e_2}) \gets r$
        \State
        \State $\mathbf{a} \gets \mathsf{expandA}(\rho)$ \Comment{Відновлення $\mathbf{a}$ з seed}
        \State $\mathbf{b}' \gets \mathsf{Decompress}(\mathbf{b}, k_1)$ \Comment{Декомпресія відкритого ключа}
        \State
        \State $\mathbf{e}_1 \gets \mathsf{HWT}_{h_e}(\sigma_{e_1})$ \Comment{Генерація "помилок"{}}
        \State $\mathbf{e}_2 \gets \mathsf{HWT}_{h_e}(\sigma_{e_2})$
        \State
        \State $m' \gets \mathsf{eccENC}(m)$ \Comment{Кодування з корекцією помилок}
        \State $\mathbf{m} \gets \mathsf{Encode}(m')$ \Comment{Перетворення біт в многочлен}
        \State
        \State $\mathbf{c}_1' \gets \mathbf{a} \cdot \mathbf{e}_1 + \mathbf{e}_2 \in R_q$ \Comment{RLWE компонента}
        \State $\mathbf{c}_1 \gets \mathsf{Compress}(\mathbf{c}_1', k_2)$ \Comment{Агресивна компресія}
        \State
        \State $\mathbf{c}_2' \gets \mathbf{b}' \cdot \mathbf{e}_1 + \mathbf{m} \cdot \lfloor q/2 \rfloor \in R_q$ \Comment{Повідомлення + шум}
        \State $\mathbf{c}_2 \gets \mathsf{Compress}(\mathbf{c}_2', 1)$ \Comment{Компресія до 1 біт}
        \State
        \State \Return $ct = (\mathbf{c}_1, \mathbf{c}_2)$
    \end{algorithmic}
\end{algorithm}

Кроки алгоритму:

\begin{enumerate}
    \item \textbf{Парсинг випадковості:} З детермінованої випадковості $r$ (згенерованої через геш-функцію $G$ 
        у FO) отримуємо seeds для генерації помилок $\mathbf{e}_1, \mathbf{e}_2$.
    \item \textbf{Відновлення відкритого ключа:}
        \begin{itemize}
            \item Многочлен $\mathbf{a}$ відновлюється з $\rho$ seed;
            \item Компресований $\mathbf{b}$ декомпресується до $\mathbf{b}' \in R_p$.
        \end{itemize}
    \item \textbf{Генерація "помилок"{}:} Створюються два розріджених тернарних многочлена $\mathbf{e}_1, \mathbf{e}_2$ 
        з вагою Геммінга $h_e$ кожен.
    \item \textbf{Підготовка повідомлення:}
    \begin{itemize}
        \item Повідомлення $m$ кодується через $\mathsf{eccENC}$ (коди XEf та D2) для захисту від помилок;
        \item Закодоване повідомлення перетворюється в многочлен $\mathbf{m} \in R$ з коефіцієнтами з $\{0,1\}$;
        \item Множиться на $\lfloor q/2 \rfloor$ для розміщення в "середині"{} модуля $q$.
    \end{itemize}
    \item \textbf{RLWE шифрування:}
    \begin{itemize}
        \item $\mathbf{c}_1' = \mathbf{a} \cdot \mathbf{e}_1 + \mathbf{e}_2$ --- "маскування"{} помилки $\mathbf{e}_1$;
        \item $\mathbf{c}_2' = \mathbf{b}' \cdot \mathbf{e}_1 + \mathbf{m} \cdot \lfloor q/2 \rfloor$ --- зашифроване повідомлення.
    \end{itemize}
    \item \textbf{Компресія шифротексту:}
    \begin{itemize}
        \item $\mathbf{c}_1$ стискається до $k_2$ біт на коефіцієнт (агресивна компресія);
        \item $\mathbf{c}_2$ стискається до 1 біт на коефіцієнт (зберігається лише знак).
    \end{itemize}
\end{enumerate}

\subsection{Decryption -- розшифрування}
\label{subsec:4-4-3}

Алгоритм розшифрування відновлює повідомлення з шифротексту використовуючи секретний ключ.

\begin{algorithm}[H]
    \caption{TiGER.PKE.Dec$(sk, ct)$}
    \label{alg:4-4-3}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Секретний ключ $sk = \sigma_s$, шифротекст $ct = (\mathbf{c}_1, \mathbf{c}_2)$
        \State \textbf{Output:} Повідомлення $m \in \{0,1\}^{256}$ або $\bot$
        \State
        \State $\mathbf{s} \gets \mathsf{HWT}_{h_s}(\sigma_s)$ \Comment{Відновлення sk з seed}
        \State
        \State $\mathbf{c}_1' \gets \mathsf{Decompress}(\mathbf{c}_1, k_2)$ \Comment{Декомпресія шифротексту}
        \State $\mathbf{c}_2' \gets \mathsf{Decompress}(\mathbf{c}_2, 1)$
        \State
        \State $\mathbf{v} \gets \mathbf{c}_2' - \mathbf{c}_1' \cdot \mathbf{s} \in R_q$ \Comment{Видалення маски}
        \State
        \State $\mathbf{m}' \gets \mathsf{Round}(\mathbf{v})$ \Comment{Округлення до \{0,1\}}
        \State $m' \gets \mathsf{Decode}(\mathbf{m}')$ \Comment{Розбиття многочлена на біти}
        \State
        \State $m \gets \mathsf{eccDEC}(m')$ \Comment{Декодування з корекцією помилок}
        \State
        \If{$m = \bot$}
            \State \Return $\bot$ \Comment{Помилка розшифрування}
        \Else
            \State \Return $m$
        \EndIf
    \end{algorithmic}
\end{algorithm}

Покроково маємо:

\begin{enumerate}
    \item \textbf{Відновлення секретного ключа:} З seed $\sigma_s$ відновлюється розріджений многочлен $\mathbf{s}$.
    \item \textbf{Декомпресія шифротексту:} Обидві компоненти $\mathbf{c}_1, \mathbf{c}_2$ декомпресуються до повного 
        розміру в $R_q$.
    \item \textbf{Видалення маски:} Обчислюється $\mathbf{v} = \mathbf{c}_2' - \mathbf{c}_1' \cdot \mathbf{s}$, 
        що має бути близьким до $\mathbf{m} \cdot \lfloor q/2 \rfloor$ (за наявності малої помилки).
    \item \textbf{Округлення:} Функція $\mathsf{Round}$ округлює кожен коефіцієнт $\mathbf{v}$ до найближчого з чисел: 
        $0$ або $\lfloor q/2 \rfloor$, потім нормалізує до $\{0,1\}$:
    \begin{equation*}
        \mathsf{Round}(v_i) = 
        \begin{cases}
            0, & \text{якщо } |v_i| < q/4 \\
            1, & \text{якщо } |v_i - \lfloor q/2 \rfloor| < q/4 \\
            \text{error}, & \text{інакше}
        \end{cases}
    \end{equation*}
    \item \textbf{Декодування:} Многочлен $\mathbf{m}'$ перетворюється в послідовність біт $m'$, після чого 
        застосовується $\mathsf{eccDEC}$ для виправлення помилок та отримання повідомлення $m$. 
    \item \textbf{Перевірка коректності:} Якщо $\mathsf{eccDEC}$ виявляє unexpect error, повертається $\bot$.
\end{enumerate}

Джерела помилок розшифрування можуть виникнути завдяки:
\begin{itemize}
    \item Помилка $\mathbf{r}$ від RLWR при генерації $\mathbf{b}$;
    \item Помилки $\mathbf{e}_1, \mathbf{e}_2$ від RLWE при шифруванні;
    \item Помилки від компресії/декомпресії $\mathbf{b}, \mathbf{c}_1, \mathbf{c}_2$ відповідно;
\end{itemize}

Параметри TiGER підібрані так, щоб сумарна помилка залишалась в межах $\pm q/4$ з високою ймовірністю, забезпечуючи 
коректне розшифрування. Коди корекції помилок XEf та D2 додатково підвищують надійність.

\section{TiGER.KEM}
\label{sec:4-5}

TiGER.KEM -- механізм інкапсуляції ключа, отриманий застосуванням перетворення Fujisaki-Okamoto з неявним відхиленням 
до TiGER.PKE. Забезпечує IND-CCA безпеку у моделі квантового випадкового оракула.

\subsection{KeyGen -- генерація ключів}
\label{subsec:4-5-1}

Алгоритм генерації ключів розширює TiGER.PKE.KeyGen додатковою компонентою -- FO перетворенням.

\begin{algorithm}[H]
    \caption{TiGER.KEM.KeyGen()}
    \label{alg:4-5-1}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Параметри $(n, q, p, h_s, h_r, k_1)$
        \State \textbf{Output:} Відкритий ключ $pk$, секретний ключ $sk$
        \State
        \State $(pk', sk') \gets$ TiGER.PKE.KeyGen() \Comment{Базова генерація ключів}
        \State
        \State $z \xleftarrow{p} \{0,1\}^{256}$ \Comment{Випадковий ключ для implicit rejection}
        \State $h \gets \text{SHA3-256}(pk')$ \Comment{Геш відкритого ключа}
        \State
        \State $pk \gets pk'$
        \State $sk \gets (sk', z, h, pk')$ \Comment{Розширений секретний ключ}
        \State
        \State \Return $(pk, sk)$
    \end{algorithmic}
\end{algorithm}

\textbf{Компоненти секретного ключа:}

\begin{itemize}
    \item $sk'$ --- секретний ключ TiGER.PKE (правду кажучи це seed $\sigma_s$);
    \item $z$ --- випадковий 256-бітний ключ для обчислення псевдовипадкового спільного ключа при невдалій 
        декапсуляції (неявне відхилення);
    \item $h$ --- геш відкритого ключа, використовується геш-функцією $G$ для генерації випадковості шифрування;
    \item $pk'$ --- копія відкритого ключа (для можливості повторного шифрування при декапсуляції).
\end{itemize}

\subsection{Encapsulation -- інкапсуляція}
\label{subsec:4-5-2}

Алгоритм інкапсуляції генерує спільний ключ та його зашифровану форму.

\begin{algorithm}[H]
    \caption{TiGER.KEM.Encaps$(pk)$}
    \label{alg:4-5-2}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Відкритий ключ $pk$
        \State \textbf{Output:} Шифротекст $ct$ та спільний ключ $K \in \{0,1\}^{256}$
        \State
        \State $m \xleftarrow{p} \{0,1\}^{256}$ \Comment{Вибираємо випадкове повідомлення}
        \State
        \State $h \gets \text{SHA3-256}(pk)$ \Comment{Гешування відкритого ключа}
        \State $r \gets \text{SHAKE256}(m \| h)$ \Comment{Детермінована випадковість}
        \State
        \State $ct \gets$ TiGER.PKE.Enc$(pk, m; r)$ \Comment{Шифрування повідомлення}
        \State
        \State $K \gets \text{SHA3-256}(m \| ct)$ \Comment{Спільний ключ обчислюється через геш}
        \State
        \State \Return $(ct, K)$
    \end{algorithmic}
\end{algorithm}

\textbf{Ключові аспекти:}

\begin{enumerate}
    \item \textbf{Випадкове повідомлення:} Генерується рівномірно (розподілене) випадкове $m \in \{0,1\}^{256}$, яке 
        буде зашифроване.
    \item \textbf{Детермінована випадковість:} Замість використання нової випадковості для шифрування, $r$ обчислюється 
        детермінована як $r = \text{SHAKE256}(m \| h)$. Це критично для можливості повторного шифрування при декапсуляції.
    \item \textbf{Гешування відкритого ключа:} Включення $h = \text{SHA3-256}(pk)$ в обчислення $r$ забезпечує взаємозв'язок 
        шифротексту до конкретного відкритого ключа, що захищає від multi-target атак.
    \item \textbf{Спільний ключ:} Обчислюється як $K = \text{SHA3-256}(m \| ct)$, як можна бачити є залежність як від 
        повідомлення так і від шифротексту. Це є важливим для безпеки алгоритму загалом: противник не може обчислити 
        $K$ без знання $m$, навіть якщо перехопив шифротекст $ct$.
\end{enumerate}

\subsection{Decapsulation -- декапсуляція}
\label{subsec:4-5-3}

Декапсуляція застосовується для відновлення спільного ключ з шифротексту, виконуючи перевірку цілісності через 
повторне шифрування.

\begin{algorithm}[H]
    \caption{TiGER.KEM.Decaps$(sk, ct)$}
    \label{alg:4-5-3}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Секретний ключ $sk = (sk', z, h, pk)$, шифротекст $ct$
        \State \textbf{Output:} Спільний ключ $K \in \{0,1\}^{256}$
        \State
        \State $m' \gets$ TiGER.PKE.Dec$(sk', ct)$ \Comment{Розшифрування}
        \State
        \If{$m' = \bot$}
            \State \Return $\overline{K} \gets \text{SHA3-256}(z \| ct)$ \Comment{Implicit rejection}
        \EndIf
        \State
        \State $r' \gets \text{SHAKE256}(m' \| h)$ \Comment{Створення "випадковості"{}}
        \State $ct' \gets$ TiGER.PKE.Enc$(pk, m'; r')$ \Comment{Повторне шифрування}
        \State
        \If{$ct' = ct$}
            \State \Return $K \gets \text{SHA3-256}(m' \| ct)$ \Comment{Успішна декапсуляція}
        \Else
            \State \Return $\overline{K} \gets \text{SHA3-256}(z \| ct)$ \Comment{Implicit rejection}
        \EndIf
    \end{algorithmic}
\end{algorithm}

\begin{enumerate}
    \item \textbf{Розшифрування:} Спершу -- звичайне розшифрування через TiGER.PKE.Dec. Якщо розшифрування 
        видало помилку ($m' = \bot$), одразу повертається псевдовипадковий ключ.
    \item \textbf{Re-encryption:} Розшифроване повідомлення $m'$ повторно шифрується з тією ж визначеною випадковістю 
        $r' = \text{SHAKE256}(m' \| h)$ (є критичном кроком для забезпечення IND-CCA безпеки).
    \item \textbf{Перевірка цілісності:} Отриманий $ct'$ порівнюється з оригінальним $ct$:
        \begin{itemize}
            \item Якщо $ct' = ct$, це означає, що шифротекст не був модифікований противником, і тоді повертається 
                справжній спільний ключ $K = \text{SHA3-256}(m' \| ct)$;
            \item Якщо $ct' \neq ct$, це сигналізує про атаку або помилку, і повертається псевдовипадковий ключ, щоб 
                заплутати зловмисника.
        \end{itemize}
    \item \textbf{Неявне відхилення (implicit rejection):} Замість явного повернення помилки $\bot$, алгоритм повертає 
        псевдовипадковий ключ $\overline{K} = \text{SHA3-256}(z \| ct)$. Це має дві такі переваги:
        \begin{itemize}
            \item \textbf{Захист від side-channel атак:} Зовнішньому спостерігачу важко визначити, чи відбулась успішна 
                декапсуляція чи ні, оскільки в обох випадках повертається деякий 256-бітний ключ;
            \item \textbf{Константний час:} Що при успішному output, що пои failed виконується однакова кількість 
                геш-операцій.
        \end{itemize}
    \item \textbf{Роль секретного ключа $z$:} Випадковий ключ $z$ є унікальним для кожної пари ключів та невідомим 
        противнику. Це гарантує, що $\overline{K}$ буде непередбачуваним для противника навіть за наявності багатьох 
        невдалих декапсуляцій.
\end{enumerate}

\noindent \textbf{Ключові моменти безпеки або ж чому це безпечно}

Перетворення FO$^{\not\bot}_m$ з повторним шифруванням перетворює будь-яку IND-CPA безпечну PKE схему в IND-CCA 
безпечну KEM.

\begin{itemize}
    \item \textbf{Детермінована випадковість:} Використання $r = \text{SHAKE256}(m \| h)$ замість нової випадковості 
        робить шифрування детермінованим для даного $m$ та $pk$, що дозволяє виконати перевірку через повторне шифрування;
    \item \textbf{Гешування спільного ключа:} $K = \text{SHA3-256}(m \| ct)$ робить спільний ключ непередбачуваним 
        без знання $m$, навіть якщо $ct$ скомпроментовано супротивником;
    \item \textbf{Захист від атак вибраного шифротексту:} Противник може подавати довільні модифіковані шифротексти 
        $ct^*$ до оракула декапсуляції, але:
        \begin{itemize}
            \item Якщо $ct^*$ не є валідним шифруванням деякого $m^*$, перевірка умови $ct' \neq ct^*$ виявить це;
            \item Противник отримає лише $\overline{K} = \text{SHA3-256}(z \| ct^*)$, що не надає жодної інформації про 
                справжній спільний ключ через випадковість $z$ та властивості геш-функції.
        \end{itemize}
\end{itemize}

\section{Аналіз коректності}
\label{sec:4-6}

Коректність вимагає від TiGER, того щоб розшифрування майже завжди повертало правильне повідомлення. У цій секції 
проаналізуємо джерела помилок та обчислимо ймовірність помилки розшифрування.

\subsection*{Математичний аналіз помилок}

При розшифруванні повідомлення обчислюється величина:
\begin{equation*}
    \mathbf{v} = \mathbf{c}_2' - \mathbf{c}_1' \cdot \mathbf{s} = \mathbf{m} \cdot \lfloor q/2 \rfloor + \mathbf{err},
\end{equation*}
де $\mathbf{err}$ -- сумарна помилка з декількох джерел.

\noindent \textbf{Джерела помилок є наступними:}

\begin{enumerate}
    \item \textbf{Помилка від RLWR:} При генерації відкритого ключа:
        \begin{equation*}
            \mathbf{b} = \lfloor (\mathbf{a} \cdot \mathbf{s} + \mathbf{r}) \cdot (p/q) \rceil,
        \end{equation*}
        що вносить помилку округлення $\mathbf{err}_{\text{RLWR}}$, де $\mathbf{err}_{\text{RLWR}} \approx \mathbf{r} \cdot (p/q)$.
    \item \textbf{Помилка від RLWE:} При шифруванні:
        \begin{equation*}
            \mathbf{c}_1' = \mathbf{a} \cdot \mathbf{e}_1 + \mathbf{e}_2, \quad \mathbf{c}_2' = \mathbf{b}' \cdot \mathbf{e}_1 + \mathbf{m} \cdot \lfloor q/2 \rfloor,
        \end{equation*}
        що вносить помилку $\mathbf{err}_{\text{RLWE}} = -\mathbf{e}_2 \cdot \mathbf{s} + \mathbf{err}_{\text{RLWR}} \cdot \mathbf{e}_1$.
    \item \textbf{Помилка від компресії відкритого ключа:} Компресія $\mathbf{b}$ ($\log_2 p$ \to $k_1$) біт 
        вносить наступну помилку округлення:
        \begin{equation*}
            \mathbf{err}_{\text{comp},\mathbf{b}} \approx \mathbf{U}([-p/2^{k_1+1}, p/2^{k_1+1}]).
        \end{equation*}
    \item \textbf{Помилка від компресії шифротексту:} Компресія $\mathbf{c}_1$ до $k_2$ біт та $\mathbf{c}_2$ до 1 біт:
        \begin{equation*}
            \mathbf{err}_{\text{comp},\mathbf{c}_1} \approx \mathbf{U}([-q/2^{k_2+1}, q/2^{k_2+1}]), \quad 
            \mathbf{err}_{\text{comp},\mathbf{c}_2} \approx \mathbf{U}([-q/4, q/4]).
        \end{equation*}
\end{enumerate}

\noindent \textbf{Сумарна помилка складатиме:} помилку в кожному коефіцієнті многочлена $\mathbf{v}$:
\begin{equation*}
    \begin{aligned}
    \mathbf{err} &= \mathbf{err}_{\text{comp},\mathbf{c}_2} + \mathbf{err}_{\text{comp},\mathbf{c}_1} \cdot \mathbf{s} \\
    &\quad + (\mathbf{err}_{\text{comp},\mathbf{b}} \cdot \mathbf{e}_1 - \mathbf{e}_2 \cdot \mathbf{s} + \mathbf{r} \cdot \mathbf{e}_1 \cdot (p/q)).
    \end{aligned}
\end{equation*}

\noindent Помилка розшифрування виникає, коли $|\mathbf{err}_i| \geq q/4$ для якогось коефіцієнта $i$, і це призводить до 
неправильного округлення.

\subsection*{Оцінка ймовірності помилки}

Для оцінки DFP/R необхідно обчислити ймовірність того, що хоча б один коефіцієнт має помилку $\geq q/4$.

\textbf{Статистичний аналіз:}

\begin{enumerate}
    \item \textbf{Розподіл помилок:} Кожна компонента помилки має рівномірний розподіл в заданих межах.
    \item \textbf{Дисперсія:} Для розрідженого тернарного многочлена $\mathbf{s}$ з вагою $h_s$:
        \begin{equation*}
            \text{Var}(\mathbf{s}) \approx h_s, \quad \text{Var}(\mathbf{s} \cdot \mathbf{e}) \approx h_s \cdot h_e / 3,
        \end{equation*}
        де ділення враховує коефіцієнти $\{-1, 0, 1\}$.
    \item \textbf{Максимальна помилка складає:}
        \begin{equation*}
            \sigma^2_{\text{err}} \approx h_s \cdot h_e / 3 + h_r \cdot h_e \cdot (p/q)^2 + (q/2^{k_2+1})^2 + (q/2)^2 + \ldots
        \end{equation*}
    \item \textbf{DFP/R для одного коефіцієнта:} Ймовірність помилки в одному з коефіцієнтів:
        \begin{equation*}
            P(\text{помилка в } i\text{-му коефіцієнті}) \approx 2 \cdot Q(q/4 / \sigma_{\text{err}}),
        \end{equation*}
        де $Q(x) = \frac{1}{\sqrt{2\pi}} \int_x^\infty e^{-t^2/2} dt$ -- функція розподілу помилок для нормального розподілу.
    \item \textbf{Тоді DFP/R для всього повідомлення:}
        \begin{equation*}
            \text{DFP/R} \leq n \cdot P(\text{помилка в одному коефіцієнті}) = n \cdot 2 \cdot Q(q/4 / \sigma_{\text{err}}).
        \end{equation*}
\end{enumerate}

\noindent \textbf{Різні параметри мають різний вплив на DFP/R:}

\begin{enumerate}
    \item \textbf{Модулі $q$ та $p$:}
        \begin{itemize}
            \item Більше $q$ збільшує інтервал ($q/4$ стає більшим), зменшуючи DFP/R;
            \item Менше відношення $q/p$ зменшує помилку від RLWR, але при цьому збільшує розмір відкритого ключа.
        \end{itemize}
    \item \textbf{Ваги Геммінга $h_s, h_r, h_e$:}
        \begin{itemize}
            \item Більші ваги збільшують дисперсію помилки, підвищуючи DFP/R;
            \item Менші ваги зменшують безпеку (легше атакувати розріджені ключі);
        \end{itemize}
    \item \textbf{Параметри компресії $k_1, k_2$:}
        \begin{itemize}
            \item Менші $k_1, k_2$ краще зменшують розміри ключів/шифротексту, збільшуючи помилку компресії;
        \end{itemize}
    \item \textbf{Коди корекції помилок (XEf, D2):}
        \begin{itemize}
            \item Коди XEf можуть виправити одиночні помилки в блоках по $d$ біт, знижуючи доволі DFP/R доволі 
                добре (у $d$ разів) для таких помилок;
            \item Код D2 з $f = 2$ дублює кожен біт, дозволяючи виправляти помилки через мажоритарне голосування.
        \end{itemize}
\end{enumerate}

\subsection*{Експериментальні результати}

Автори TiGER провели обчислювальні експерименти для верифікації теоретичних оцінок DFP/R і отримали:

\begin{itemize}
    \item \textbf{TiGER128:} DFP/R $\approx 2^{-120}$ (теоретична), $< 2^{-128}$ (експериментальна після $2^{40}$ тестів);
    \item \textbf{TiGER192:} DFP/R $\approx 2^{-136}$ (теоретична), не виявлено помилок після $2^{45}$ тестів;
    \item \textbf{TiGER256:} DFP/R $\approx 2^{-167}$ (теоретична), не виявлено помилок після $2^{48}$ тестів.
\end{itemize}

Експерименти підтверджують, що практична DFP/R не перевищує теоретичних оцінок і є достатньо малою для будь-яких 
реалістичних сценаріїв використання.

\section{Особливості реалізації}
\label{sec:4-7}

TiGER розроблявся з ухилом на ефективність та безпеку.

Конструкція TiGER має наступні риси, що забезпечують компактність, ефективність та безпеку реалізації. 

\textbf{Компактність} досягається через використання RLWR та агресивної компресії, що дозволяє отримати малі 
розміри відкритого ключа та шифротексту порівняно з аналогами. Наприклад, TiGER128 має відкритий ключ розміром 
лише 804 байти та шифротекст 804 байти, що менше ніж у Kyber512 (800 + 768 байт) та Saber (672 + 736 байт). 
Економія місця особливо важлива для протоколів з обмеженою пропускною здатністю, таких як TLS, де кожен байт має 
значення. Також зберігання seed замість повних многочленів (як у $\mathbf{a}$) економить до 2 КБ для TiGER256.

\textbf{Висока обчислювальна ефективність} забезпечується через використання модулів які є степенями двійки ($q = 2^k$), 
що дозволяє виконувати операції модульної арифметики через прості побітові зсуви:
\begin{itemize}
    \item Округлення $\lfloor x \cdot (p/q) \rceil$ виконується як побітовий зсув вправо: оскільки $q = 2^{14}$ та 
        $p = 2^{10}$ для TiGER128, ділення на $q/p = 2^4$ еквівалентне зсуву на 4 біти;
    \item  Операції за $\bmod q$ виконуються через побітовий AND з числом $q - 1$. Це значно швидше ніж модульні 
        операції, що використовуються в деяких інших схемах. 
    \item Розріджені секрети ($h_s \ll n$) прискорюють множення многочленів: замість $O(n^2)$ операцій для множення, 
        потрібно лише $O(h_s \cdot n)$ операцій, що дає прискорення приблизно в $n/h_s \approx 2$ рази.
\end{itemize}

\textbf{Простота в реалізації} є важливою перевагою TiGER. Відмова від використання Number Theoretic Transform (NTT) 
спрощує імплементацію, оскільки NTT вимагає специфічних модулів виду $q = 1 \bmod 2n$ та bit-reversal permutation
(якийсь жах, я таки не вдуплив що це). TiGER використовує множення многочленів, яке, хоч і має вищу асимптотичну 
складність $O(n^2)$ порівняно з $O(n \log n)$ для NTT, але є простішим для людського сприйняття та реалізації. Для 
розріджених многочленів складність знижується до $O(h \cdot n)$, що робить це множення конкурентоспроможним.
При реалізації важливо уникати умовних переходів та операцій індексації масивів, які залежать від секретних значень, 
оскільки це може призвести до витоку інформації через timing або cache атаки.

\textbf{Захист від атак} забезпечується кількома механізмами:
\begin{itemize}
    \item Неявне відхилення (implicit rejection) у TiGER.KEM захищає від витоку інформації через помилки розшифрування. 
        Це протидіє failure boosting attacks, де противник ітеративним підходом підбирає шифротексти з високою ймовірністю 
        помилки для витягування інформації про секретний ключ. (адаптивна атака на основі вибраного шифротекста)
    \item Гешування відкритого ключа ($r = G(m, H(pk))$) забезпечує стійкість до multi-target атак, прив'язуючи кожен 
        шифротекст до конкретного відкритого ключа.
    \item Детермінована випадковість шифрування через $G$ дозволяє виконати перевірку цілісності через повторне шифрування, 
        що є основою IND-CCA безпеки.
\end{itemize} 

\textbf{Коди корекції помилок} є ключовою інновацією вTiGER. Застосування кодів XEf та D2 значно знижує ймовірність 
помилки розшифрування без збільшення розміру шифротексту. Код XEf може виправити одиночні помилки в блоках по $d$ 
біт та відповідно підвищує стійкість у стільки ж разів. Без кодів корекції довелося або використовувати менш 
агресивне стиснення (більший шифротекст), або змиритися з вищим DFP/R, що неприйнятно для практичних застосувань.

\textbf{Константний час виконання} є критичним для захисту від атак через побічні канали (side-channel attacks). 
Генерація розріджених многочленів через $\mathsf{HWT}_h$ використовує rejection sampling, при цьому загальна 
кількість ітерацій обмежена та не залежить від секретних даних. Операції з многочленами виконуються за фіксований 
час незалежно від значень коефіцієнтів. Плюс неявне відхилення гарантує, що (не)успішна декапсуляція виконуються 
з використанням однакової кількості геш-операцій.

\textbf{Практичні переваги} Модульна структура (PKE + FO) дозволяє окремо тестувати та оптимізувати різні компоненти. 
Відсутність складних математичних операцій (як pairing у криптографії на еліптичних кривих) робить TiGER перспективним 
для впровадження на пристроях з обмеженим ресурсом (embedded systems, IoT).

У таблиці~\ref{table:4-7-1} підсумуємо ключові технічні рішення TiGER та їх вплив на характеристики алгоритму.

\begin{longtblr}[
    caption = {Порівняльна таблиця покращень TiGER},
    label = {table:4-7-1},
]{
    colspec = {| X[1,l] | X[1.2,l] | X[1.2,l] |},
    rowhead = 1,
    hlines,
    row{1} = {c}, % Заголовки таблиці по центру
}
    % Заголовок
    \textbf{Технічне рішення} & \textbf{Переваги} & \textbf{Компроміси} \\
    \hline

    % Вміст
    \textbf{RLWR замість RLWE} (відкритий ключ) &
    \textit{+} Менший розмір $pk$ через детерміністичне округлення &
    \textit{-} Необхідність балансування $q/p$ \\

    \textbf{Модулі -- степені двійки} ($q = 2^k$, $p = 2^k$) &
    \textit{+} Швидкі побітові операції \newline
    \textit{+} Простота в реалізації \newline
    \textit{+} Const час виконання &
    \textit{-} Трохи менша безпека на біт порівняно з простим $q$ \\

    \textbf{Розріджені секрети} ($h_s, h_r, h_e \ll n$) &
    \textit{+} Швидке множення: $O(h \cdot n)$ замість $O(n^2)$ \newline
    \textit{+} Менша дисперсія помилок &
    \textit{-} Потенційна вразливість до комбінованих атак \newline
    \textit{-} Невипадковий вибір $h$ для збереження safety balance \\

    \textbf{Відсутність NTT} &
    \textit{+} Свобода у виборі модулів $p$, $q$ \newline
    \textit{+} Менше ризиків для side-channel attacks &
    \textit{-} Повільніше множення: $O(n^2)$ vs $O(n \log n)$ \newline
    \textit{-} Компенсується розрідженістю \\

    \textbf{Агресивна компресія} ($k_1 = 10$-$11$, $k_2 = 4$-$5$) &
    \textit{+} Компактні розміри $pk$ і $ct$ \newline
    \textit{+} Ефективність у протоколах з обмеженою пропускною здатністю &
    \textit{-} Збільшення помилок компресії \newline
    \textit{-} Вища DFP без корекції помилок \\

    \textbf{Коди корекції помилок} (XEf + D2) &
    \textit{+} Дуже низька DFP ($\leq 2^{-120}$) \newline
    \textit{+} Дозволяє агресивнішу компресію \newline
    \textit{+} Надійність decryption &
    \textit{-} Невелике збільшення обчислень \newline
    \textit{-} Складніша логіка реалізації коду \\

    \textbf{Неявне відхилення} (implicit rejection) &
    \textit{+} Захист від failure boosting атак \newline
    \textit{+} Константний час (успіх = невдача) &
    \textit{-} Складніша декапсуляція \\

    \textbf{Seed-based генерація} ($\rho$ для $\mathbf{a}$, $\sigma$ для $\mathbf{s}$) &
    \textit{+} Малі розміри ключів (256 біт seed замість $n \log q$ біт) \newline
    \textit{+} Детерміністичність і повторюваність &
    \textit{-} Потреба регенерувати многочлени при використанні \newline
    \textit{-} Вимоги до якісного PRNG \\

    \textbf{FO$^{\not\bot}_m$ перетворення} &
    \textit{+} IND-CCA безпека з IND-CPA PKE \newline
    \textit{+} Стандартизований підхід \newline
    \textit{+} Забезпечення безпеки в QROM &
    \textit{-} Потреба повторного шифрування \newline
    \textit{-} Додаткові геш-обчислення \\

    \textbf{Детерміністична випадковість} ($r = G(m, h)$) &
    \textit{+} Можливість перевірки через re-encryption \newline
    \textit{+} Відсутність потреби у новій випадковості при Enc &
    \textit{-} Критична залежність від стійкості самих геш-функцій \newline
    \textit{-} І вразливість при компрометації $G$ \\
\end{longtblr}

Як видно з таблиці, більшість технічних рішень TiGER представляють собою компроміси між різними характеристиками. 
Ключовою перевагою є досягнення балансу між безпекою, ефективністю та компактністю при збереженні практичності 
реалізації. Особливо цінною є комбінація агресивної компресії з кодами корекції помилок -- це унікальність TiGER 
порівняно з багатьма конкурентами.

\chapter{\large{Аналіз безпеки}}
\label{chapter:5}

\section{Теоретичні основи безпеки}
\label{sec:5-1}

TiGER.PKE та TiGER.KEM забезпечують різні рівні криптографічної безпеки завдяки застосуванню добре вивчених 
криптографічних перетворень.

\subsection{IND-CPA безпека TiGER.PKE}
\label{subsec:5-1-1}

Базова схема TiGER.PKE забезпечує безпеку проти атаки з використанням відкритого тексту -- IND-CPA (Indistinguishability 
under Chosen Plaintext Attack). Формально, це означає, що противник, може обирати повідомлення та отримувати їх шифрування, 
але при цьому не може відрізнити шифротексти двох обраних ним повідомлень з ймовірністю суттєво більшою за $1/2$.

\begin{claim}[про IND-CPA безпеку]
    ~\par У припущенні складності RLWE та RLWR проблем, TiGER.PKE є IND-CPA безпечною схемою шифрування з відкритим ключем 
    у моделі випадкового оракула.
\end{claim}

\noindent \textit{Ідея доведення:} Безпека TiGER.PKE зводиться до складності двох задач: RLWR (для відкритого ключа) 
та RLWE (для шифротексту). Відкритий ключ $\mathbf{b} = \lfloor (\mathbf{a} \cdot \mathbf{s} + \mathbf{r}) \cdot (p/q) \rceil$ 
є RLWR зразком, який не розкриває інформацію про $\mathbf{s}$ за припущення складності RLWR. А шифротекст 
$(\mathbf{c}_1, \mathbf{c}_2)$ складається з RLWE зразків: $\mathbf{c}_1' = \mathbf{a} \cdot \mathbf{e}_1 + \mathbf{e}_2$ 
є RLWE зразком відносно $\mathbf{e}_1$, а $\mathbf{c}_2' = \mathbf{b}' \cdot \mathbf{e}_1 + \mathbf{m} \cdot \lfloor q/2 \rfloor$ 
маскує повідомлення $\mathbf{m}$ через RLWE. Зловмисник, який здатний розрізняти шифротексти, міг би вирішити 
RLWE/RLWR задачі, а це суперечить припущенню їх складності.

\subsection{IND-CCA безпека TiGER.KEM}
\label{subsec:5-1-2}

TiGER.KEM досягає значно кращої безпеки. Він має стійкість до атак з виборним шифротекстом --IND-CCA 
(Indistinguishability under Chosen Ciphertext Attack). У цій моделі противник має доступ до оракула декапсуляції 
і може подавати довільні шифротексти для розшифрування (за винятком цільового шифротексту).

\begin{claim}[про IND-CCA безпеку] 
    ~\par За припущенням IND-CPA безпеки TiGER.PKE та моделювання геш-функцій $G$, $H$, як квантових випадкових оракулів, 
    TiGER.KEM є IND-CCA безпечною в моделі квантового випадкового оракула (QROM).
\end{claim}

\noindent \textit{Ідея доведення:} Безпека досягається через перетворення Fujisaki-Okamoto з неявним відхиленням 
(FO$^{\not\bot}_m$). Доведення використовує послідовність game-hopping (гібридних експериментів), де в кожному 
наступному експерименті протокол модифікується незначним чином, і в результаті зловмисник не може відрізнити 
сусідні експерименти. Заключний експеримент відповідає ситуації, де спільний ключ є повністю випадковим і незалежним 
від шифротексту.

\subsection{Важливість моделі QROM}
\label{subsec:5-1-3}

Класичні доведення безпеки FO перетворення використовують модель випадкового оракула (ROM), де геш-функції моделюються 
як справжні випадкові функції, доступні лише через класичні запити(??). Однак зловмисник з квантовим комп'ютером може 
виконувати \textit{квантові запити} до оракулів, що являють собою суперпозиції багатьох входів одночасно, що потенційно 
дає переваги в атаках.

Модель квантового випадкового оракула (QROM) враховує цю загрозу, моделюючи геш-функції як квантові оракули, доступні 
для квантових запитів. TiGER.KEM має формальне доведення безпеки в QROM, що підтверджує його стійкість навіть проти 
зловмисників з доступом до квантових обчислень геш-функцій.

\section{Квантова стійкість}
\label{sec:5-2}

Основна мотивація постквантової криптографії -- захист від появи квантових комп'ю\-терів, які становлять екзистенційну 
і доволі реальну загрозу для сучасних криптосистем на основі розв'язання задач факторизації та дискретного логарифму.

\subsection*{Квантові загрози класичній криптографії}

Квантові алгоритми: Шора (1994) та Гровера (1996) радикально змінили ландшафт криптографічної безпеки:

\textbf{Алгоритм Шора} вирішує задачі факторизації цілих чисел та дискретного логарифму за поліноміальний час на 
квантовому комп'ютері. Для числа $N$ складність факторизації становить $\exp(O((\log N)^{1/3}))$ (субекспоненційна), 
тоді як квантовий алгоритм Шора досягає $O((\log N)^3)$ (поліноміальна). Це означає повну компрометацію таких 
алгоритмів як:
\begin{itemize}
    \item \textbf{RSA:} Квантовий комп'ютер з $\sim$2000 логічних кубітів може факторизувати 2048-бітне число за 
        лічені години (трохи перебільшую, але все ж);
    \item \textbf{ECDSA/ECDH:} Дискретний логарифм на еліптичних кривих вирішується аналогічно ефективно;
    \item \textbf{Diffie-Hellman:} Класичний варіант DH також стає вразливим через полегшення обрахування дискретного 
        логарифму у скінченних полях.
\end{itemize}

\textbf{Алгоритм Гровера} забезпечує квадратичне(!) прискорення задачі пошуку в несортованих базах даних. Для 
звичаного пошуку розміру $N$, класична складність становила б $O(N)$, тоді як квантовий алгоритм досягає 
$O(\sqrt{N})$. Це має свій вплив на симетричну криптографію:
\begin{itemize}
    \item \textbf{AES-128:} Ефективна безпека знижується до $2^{64}$ операцій, що вже недостатньо;
    \item \textbf{SHA-256:} Collision resistance (стійкість до колізій) зменшується з $2^{128}$ до $2^{85}$, а 
        preimage resistance (стійкість до знаходження прообразу) -- з $2^{256}$ до $2^{128}$;
\end{itemize}
Як наслідок - треба подвоювати розмірів ключів (AES-256, SHA-512) для збереження еквівалентного рівня безпеки.

В той же час решіткові задачі є стійкими до квантових атак. На відміну від факторизації та дискретного логарифму, 
задачі на решітках (включно з RLWE та RLWR) не мають відомих ефективних квантових алгоритмів.

\noindent Ключові причини цього:
\begin{enumerate}
    \item \textbf{Відсутність прихованої підгрупової структури:} Алгоритм Шора використовує квантове перетворення 
        Фур'є (QFT) для виявлення періодичності в підгрупах кільця $\mathbb{Z}_N^*$ або серед точок еліптичної кривої. 
        Решіткові задачі не мають такої регулярної алгебраїчної структури, яка б дозволяла QFT виявляти корисну інформацію.
    \item \textbf{Геометрична проблема:} Задачі на решітках є геометричними проблемами -- пошук найближчого вектора решітки 
        або найкоротшого ненульового вектора. Ці задачі залишаються складними навіть для квантових алгоритмів, 
        оскільки не існує приведення до задач з експоненційною кількістю періодичних розв'язків.
    \item \textbf{Відомі квантові атаки неефективні:} Найкращі з відомих квантових алгоритми для решіткових задач 
        це квантові версії класичних BKZ (Basis Kernel Z) та sieving алгоритмів. Вони надають лише 
        \textit{поліномільно-логарифмічне} прискорення (наприклад, з $2^{0.292\beta}$ до $2^{0.265\beta}$ для просіювання, 
        де $\beta$ -- block dimension), що далеко від експоненційного прискорення алгоритму Шора.
\end{enumerate}

\subsection*{Оцінка квантової складності атак на TiGER}

Для оцінки безпеки TiGER проти квантових атак використовується модель Core-SVP (Short Vector Problem), що 
вимірює складність вирішення SVP на решітці розмірності $\beta$ (block dimension):

\noindent В класичній моделі обчислень найкращими класичними алгоритми (BKZ + sieving) досягається:
\begin{equation*}
    T_{\text{classical}} \approx 2^{0.292\beta + o(\beta)}
\end{equation*}

\noindent В квантовому всесвіті, при застосуванні квантових версії sieving алгоритмів (див. Laarhoven et al., 2015), 
складність досягає:
\begin{equation*}
    T_{\text{quantum}} \approx 2^{0.265\beta + o(\beta)}
\end{equation*}

\noindent Для TiGER параметри обиралися так, щоб при достатньо великому $\beta$ забезпечувався бажаний рівень безпеки:

\begin{itemize}
    \item \textbf{TiGER128:} $\beta_{\text{quantum}} \approx 483$, це дає $2^{128}$ квантових операцій для атаки;
    \item \textbf{TiGER192:} $\beta_{\text{quantum}} \approx 724$, що дає $2^{192}$ квантових операцій;
    \item \textbf{TiGER256:} $\beta_{\text{quantum}} \approx 966$, що дає $2^{256}$ квантових операцій.
\end{itemize}

\noindent Ці оцінки консервативні і враховують можливі майбутні покращення квантових алгоритмів. Навіть за наявності 
велитенського квантового комп'ютера/ів з мільйонами логічних кубітів, злам того ж TiGER128 вимагав би $2^{128}$ 
квантових операцій, що наразі є практично нереалістичним.

\subsection*{Стійкість головного у TiGER -- геш-функції}

TiGER використовує геш-функції SHA3-256 та SHAKE256, які також мають бути квантово стійкими:

\begin{itemize}
    \item \textbf{SHA3 (Keccak):} Базується на губчастій конструкції (sponge construction), яка не має відомих 
        квантових атак, ефективніших за атаку із застосуванням алгоритму Гровера. Для SHA3-256 квантова 
        collision resistance становить порядку $\approx 2^{85}$ операцій, а preimage resistance -- $2^{128}$ операцій. 
        Це є терпимим для використання у TiGER.KEM.
    \item \textbf{SHAKE256:} Як XOF (extendable-output function) з змінною довжиною виходу, SHAKE256 має аналогічну 
        як і SHA3. Використання $G$ для генерації детерміністичної випадковості не створює додаткових квантових 
        вразливостей.
\end{itemize}

\section{Рівні безпеки NIST}
\label{sec:5-3}

NIST (National Institute of Standards and Technology) визначив п'ять рівнів безпеки для стандартизації 
постквантових алгоритмів. Ці рівні дозволяють порівнювати стійкість різних алгоритмів з існуючими класичними 
еталонними схемами.

\subsection{Категорії безпеки згідно NIST}
\label{subsec:5-3-1}
Рівні безпеки NIST визначаються через мінімальну обчислювальну складність зламу, еквівалентну пошуку ключа в 
симетричних криптосистемах або зламу класичних асиметричних схем:

\begin{table}[H]
    \begin{tblr}{
            colspec = {| X[1,c] | X[3,l] | X[4,l] |},
            vlines,
            hlines,
            row{1} = {c},
        }
        \textbf{Рівень} & \textbf{Класичний еквівалент} & \textbf{Квантовий еквівалент}                                     \\
        \hline
        \textbf{1}      & Пошук ключа AES-128           & $2^{128}$ класичних або $2^{64}$ квантових операцій               \\
        \hline
        \textbf{2}      & Collision пошук в SHA-256     & $2^{128}$ класичних або $2^{64}$ квантових операцій (для колізій) \\
        \hline
        \textbf{3}      & Пошук ключа AES-192           & $2^{192}$ класичних або $2^{96}$ квантових операцій               \\
        \hline
        \textbf{4}      & Collision пошук в SHA-384     & $2^{192}$ класичних або $2^{96}$ квантових операцій (для колізій) \\
        \hline
        \textbf{5}      & Пошук ключа AES-256           & $2^{256}$ класичних або $2^{128}$ квантових операцій              \\
    \end{tblr}
    \caption{Рівні безпеки NIST}
    \label{table:5-3-1}
\end{table}

\noindent Насправді є 3 NIST anchor layers (1, 3, 5), а інші два -- містять проміжні значення.

\begin{enumerate}
    \item \textbf{TiGER128 (Рівень 1):} Призначений для загального використання, де потрібен баланс між безпекою та 
        ефективністю. Перший рівень достатній для захисту більшості даних на найближчі 10-15 років, враховуючи 
        поточний стан квантових технологій.
    \item \textbf{TiGER192 (Рівень 3):} Підвищена безпека для конфіденційних даних, що вимагають довгострокового 
        захисту (20-30 років). Квантова безпека $2^{192}$ операцій робить атаку практично неможливою навіть за 
        наявності значних прогресів у квантових обчисленнях.
    \item \textbf{TiGER256 (Рівень 5):} Максимальна безпека для критично важливих застосувань (державні секрети, 
        військові документи, фінансові інфраструктури і т.п.). Квантова безпека в $2^{256}$ операцій гарантує 
        захист навіть від гіпотетичних квантових комп'ютерів майбутнього з безпрецедентною обчислювальною потужністю, 
        але ми ще подивимося:).
\end{enumerate}

\noindent \textbf{Ключові принципи NIST:}
\begin{enumerate}
    \item Рівні безпеки NIST визначаються за складністю атаки квантовим комп'ютером. Наприклад, рівень 1 вимагає, 
        щоб квантова атака на алгоритм вимагала не менше ресурсів, ніж квантовий пошук ключа AES-128 
        (що становить $2^{64}$ квантових операцій через алгоритм Гровера s еквівалентно $2^{128}$ класичним).
    \item NIST вимагає консервативних оцінок безпеки, що враховують можливі майбутні покращення алгоритмів для атак. 
        Алгоритм вважається відповідним рівню безпеки, якщо найкраща відома атака (з урахуванням можливих покращень) 
        вимагатиме не менше ресурсів, ніж еталонна задача.
    \item Рівні NIST фокусуються також на практичній складності атак, враховуючи не лише теоретичну складність 
        алгоритмів, але й реальні обчислювальні обмеження.
\end{enumerate}

\subsection{Відповідність TiGER стандартам NIST}
\label{subsec:5-3-2}

TiGER має три набори (див. табл~\ref{table:4-2-1}) параметрів, що відповідають відповідно трьом рівням безпеки NIST:

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Характеристика}      & \textbf{TiGER128} & \textbf{TiGER192} & \textbf{TiGER256} \\
        \hline
        \hline
        Рівень NIST                  & \textbf{1}        & \textbf{3}        & \textbf{5}        \\
        \hline
        Класична безпека (біт)       & 143               & 207               & 272               \\
        \hline
        Квантова безпека (біт)       & 128               & 192               & 256               \\
        \hline
        Core-SVP $\beta$ (квантовий) & 483               & 724               & 966               \\
        \hline
        Складність атаки (кв. опер.) & $2^{128}$         & $2^{192}$         & $2^{256}$         \\
        \hline
        Еквівалент NIST              & AES-128           & AES-192           & AES-256           \\
        \hline
    \end{tabular}
    \caption{Відповідність параметрів TiGER рівням NIST}
    \label{table:5-3-2}
\end{table}

Важливою характеристикою також є \textit{запас безпеки} -- різниця між заявленим рівнем безпеки та фактичною складністю 
найкращої відомої атаки. TiGER має значний запас безпеки:

\begin{itemize}
    \item \textbf{TiGER128:} Класична безпека $\approx 143$ біт при заявлених 128 біт (запас $+15$ біт);
    \item \textbf{TiGER192:} Класична безпека $\approx 207$ біт при заявлених 192 біт (запас $+15$ біт);
    \item \textbf{TiGER256:} Класична безпека $\approx 272$ біт при заявлених 256 біт (запас $+16$ біт).
\end{itemize}

Цей запас забезпечує захист від можливих майбутніх покращень алгоритмів атак та надає впевненість у довгостроковій 
безпеці TiGER. Навіть якщо з'являться нові методи атак, що знижують складність на порядка $\sim 2^{10}$ операцій, 
TiGER лишатиметься безпечним на заявлених рівнях.

\chapter{\large{Порівняння з іншими алгоритмами}}
\label{chapter:6}

\section{TiGER vs RLizard}
\label{sec:6-1}

RLizard є безпосереднім попередником алгоритму TiGER, розробленим тією ж командою в 2018 році. TiGER успадковує 
багато ідей від RLizard і вносить значні покращення, що роблять його більш компактним та ефективним.

\subsection*{Спільні риси}

TiGER та RLizard мають багато спільного:

\begin{enumerate}
    \item \textbf{Поєднання RLWE/RLWR:} Обидва алгоритми використовують RLWR для генерації відкритого 
        ключа та RLWE для шифрування. Це дозволяє зменшити розмір відкритого ключа через округлення.
    \item \textbf{Модулі у вигляді степенів двійки:} Використання модуля виду $q = 2^k$ для оптимізації 
        модульних операцій через побітові операції зсуву та bitwise AND.
    \item \textbf{Відсутність NTT:} Обидва алгоритми не використовують Number Theoretic Trans\-form, що спрощує 
        програмну реалізацію, і при цьому ж зменшує ризики side-channel атак.
    \item \textbf{Розріджені секрети:} Секретні ключі та помилки є тернарними многочленами з малою вагою 
        Геммінга ($h \ll n$). Це прискорює прискорює множення многочленів.
    \item \textbf{FO перетворення:} Обидві схеми використовують перетворення Fujisaki-Okamoto для досягнення 
        IND-CCA безпеки KEM з IND-CPA безпечної PKE.
\end{enumerate}

\subsection*{Ключові відмінності}

TiGER вносить кілька суттєвих покращень порівняно з RLizard:

\begin{enumerate}
    \item \textbf{Зменшення степені многочлена ($n = 1024 \to 512$):}
    \begin{itemize}
        \item TiGER використовує половинний $n$ для рівня 1, що зменшує складність множення многочленів з 
            $O(1024^2) \approx 10^6$ до $O(512^2) \approx 2.6 \times 10^5$ операцій (прискорення у $\sim$4x);
        \item Зменшення $n$ також зменшує розміри всіх інших многочленів у $2$ рази;
        \item Безпека не на гіршому рівні за рахунок компенсації -- використання кодів корекції помилок.
    \end{itemize}
    \item \textbf{Зменшення модуля ($q = 2^{20} \to 2^{14}$):}
    \begin{itemize}
        \item Менший $q$ означає менше біт на кожен коефіцієнт многочлена: з 20 до 14 біт;
        \item Як наслідок -- зменшення розмірів всіх компонентів многочленів з $R_q$;
        \item Менший $q$ також прискорює операції модульної арифметики (менші числа).
    \end{itemize}
    \item \textbf{Агресивніша компресія:}
    \begin{itemize}
        \item TiGER застосовує агресивну компресію $k_2 = 4$ біт для $\mathbf{c}_1$ та 1 біт для $\mathbf{c}_2$;
        \item Агресивна компресія збільшує помилки, але TiGER компенсує це знову ж таки через коди корекції 
            помилок.
    \end{itemize}
    \item \textbf{Застосування кодів корекції помилок (XEf + D2):}
    \begin{itemize}
        \item \textit{Ключова інновація TiGER} --- використання двох методів для корекції помилок;
        \item Код XEf виправляє одиночні помилки в блоках по $d = 8$ біт, збільшуючи надійність приблизно в $d$ разів;
        \item Код D2 дублює кожен біт ($f = 2$), дозволяючи додатково виправляти помилки через мажоритарне голосування;
        \item Комбінація дозволяє TiGER використовувати агресивнішу компресію при збереженні дуже низької DFP/R ($2^{-120}$);
        \item В RLizard що того, що того немає.
    \end{itemize}
    \item \textbf{Неявне відхилення (implicit rejection):}
    \begin{itemize}
        \item TiGER використовує FO$^{\not\bot}_m$ варіант з неявним відхиленням: замість повернення $\bot$ при невдалій 
            декапсуляції, повертається псевдовипадковий ключ $\overline{K} = H(z, ct)$ -- захист від failure boosting атак
        \item RLizard використовує стандартний FO варіант з явним відхиленням, що є вразливішим до таких атак.
    \end{itemize}
    \item \textbf{Підвищення безпеки при менших параметрах:}
    \begin{itemize}
        \item Незважаючи на менший $n$ та $q$, TiGER128 має \textit{вищий} Core-SVP $\beta = 483$ порівняно з 
            RLizard $\beta = 450$ -- забезпечення кращої безпеки при значно менших розмірах;
        \item Це досягається через оптимізацію розподілу помилок, вибір ваг Геммінга, та консервативніші оцінки 
            безпеки;
    \end{itemize}
\end{enumerate}

\noindent Це можна підсумувати таблицею:

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Характеристика} & \textbf{RLizard} & \textbf{TiGER128} \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Параметри}}                       \\
        \hline
        Степінь многочлена $n$  & 1024             & 512               \\
        \hline
        Основний модуль $q$     & $2^{20}$         & $2^{14}$          \\
        \hline
        Модуль округлення $p$   & $2^{10}$         & $2^{10}$          \\
        \hline
        Вага секрету $h_s$      & 256              & 274               \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Розміри (байт)}}                  \\
        \hline
        Відкритий ключ $|pk|$   & 1472             & 804               \\
        \hline
        Шифротекст $|ct|$       & 1312             & 804               \\
        \hline
        Секретний ключ $|sk|$   & 1536             & 1876              \\
        \hline
        Загалом                 & 4320             & 3484              \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Безпека та надійність}}           \\
        \hline
        Core-SVP $\beta$        & 450              & 483               \\
        \hline
        DFP/R                   & $2^{-128}$       & $2^{-120}$        \\
        \hline
        Коди корекції помилок   & Немає            & XEf + D2          \\
        \hline
        Implicit rejection      & Відсутнє         & Є                 \\
        \hline
    \end{tabular}
    \caption{Порівняння RLizard та TiGER}
    \label{table:6-1-1}
\end{table}

\subsection*{Практичні наслідки}

Покращення TiGER мають значний практичний сенс:

\begin{itemize}
    \item \textbf{Компактність:} Зменшення $|pk| + |ct|$ на $\sim$35\% робить TiGER ефективнішим для протоколів 
        з обмеженою пропускною здатністю таких як TLS чи IoT;
    \item \textbf{Продуктивність:} Менший $n$ та $q$ прискорюють усі операції: генерацію ключів, шифрування, 
        дешифрування.
    \item \textbf{Надійність:} Коди корекції помилок роблять TiGER більш надійним у реальних умовах, де можливі 
        апаратні помилки;
    \item \textbf{Безпечність:} Implicit rejection та вищий Core-SVP $\beta$ роблять TiGER стійкішим до сучасних 
        атак.
\end{itemize}

\section{TiGER vs Kyber}
\label{sec:6-2}

Kyber (нині стандартизований ML-KEM) є переможцем конкурсу NIST з постквантової криптографії та де-факто слугує 
стандартом для KEM на основі решіток. Порівняння TiGER з Kyber дає розуміння переваг та компромісів обох підходів.

\subsection*{Архітектурні відмінності}

Kyber та TiGER базуються на різних варіантах решіткових задач та мають різне математичне підгрунтя:
\begin{enumerate}
    \item \textbf{MLWE vs RLWE:}
    \begin{itemize}
        \item \textit{Kyber} використовує Module-LWE --- узагальнення алгоритму LWE на вектори многочленів. Це компромісний 
            варіант між стандартним LWE та RLWE;
        \item \textit{TiGER} використовує чистий RLWE/RLWR на одному многочлені з кільцевої структури. Ця структура 
            дозволяє зменшити розміри, але потенційно зменшує запас безпеки;
    \end{itemize}
    \item \textbf{Модуль просте число vs степінь двійки:}
    \begin{itemize}
        \item \textit{Kyber} використовує $q = 3329$ --- спеціально обране просте число виду $q = 1 \bmod 2n$, що 
            дозволяє використовувати NTT;
        \item \textit{TiGER} використовує $q = 2^{14}$, що дозволяє швидкі побітові операції, але унеможливлює NTT 
            (оскільки $2^{14}$ не має примітивних коренів степеня $2n$);
    \end{itemize}
    \item \textbf{RLWR vs RLWE для відкритого ключа:}
    \begin{itemize}
        \item \textit{Kyber} генерує $\mathbf{pk} = \mathbf{A} \cdot \mathbf{s} + \mathbf{e}$ з явною помилкою 
            $\mathbf{e}$;
        \item \textit{TiGER} використовує RLWR: $\mathbf{pk} = \lfloor \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \rceil_{p/q}$ 
            з округленням, що вводить неявну помилку та економить місце (але це усього порядка декількох кілобайт);
    \end{itemize}
    \item \textbf{Секретні ключі:}
    \begin{itemize}
        \item \textit{Kyber} використовує Centered Binomial Distribution (CBD) з параметром $\eta = 3$. Коефіцієнти 
            многочленів беруться з множини $\{-3, -2, -1, 0, 1, 2, 3\}$. Це дає "природний"{} розподіл помилок;
        \item \textit{TiGER} використовує розріджені тернарні многочлени: коефіцієнти з $\{-1, 0, 1\}$, де рівно 
            $h_s = 274$ ненульових коефіцієнтів. Це прискорює множення, але розріджені секрети потенційно більш 
            вразливіші до комбінаторних атак. Необхідний консервативний вибір $h_s$.
    \end{itemize}
\end{enumerate}

Зведемо до таблиці:
\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Характеристика} & \textbf{Kyber512}                                & \textbf{TiGER128}                                                     \\
        \hline
        \hline
        \textbf{Базова проблема}& MLWE (Module-LWE)                                & RLWE + RLWR                                                           \\
                                & Вектори многочленів                              & Один многочлен                                                        \\
        \hline
        \textbf{Розмірність}    & $k = 2$ модулі                                   & $k = 1$ (тільки кільце)                                               \\
                                & $n = 256$ на модуль                              & $n = 512$                                                             \\
        \hline
        \textbf{Модуль $q$}     & 3329 (просте число)                              & $2^{14} = 16384$ (степінь 2)                                          \\
        \hline
        \textbf{Множення}       & NTT (FFT в $\mathbb{Z}_q$)                       & Пряме множення                                                        \\
                                & $O(kn \log n)$                                   & $O(hn)$ (розріджене)                                                  \\
        \hline
        \textbf{Відкритий ключ} & MLWE: $\mathbf{A} \cdot \mathbf{s} + \mathbf{e}$ & RLWR: $\lfloor \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \rceil_{p/q}$ \\
                                & Явна помилка $\mathbf{e}$                        & Округлення замість помилки                                            \\
        \hline
        \textbf{Шифрування}     & MLWE на векторах                                 & RLWE на многочленах                                                   \\
        \hline
        \textbf{Секрети}        & CBD розподіл ($\eta = 3$)                        & Розріджені тернарні                                                   \\
                                & Щільні (всі коеф. $\neq 0$)                      & Вага Геммінга $h_s = 274$                                             \\
        \hline
        \textbf{Коди корекції}  & Немає                                            & XEf + D2                                                              \\
        \hline
        \textbf{FO варіант}     & Стандартний                                      & Implicit rejection                                                    \\
        \hline
    \end{tabular}
    \caption{Архітектурні відмінності Kyber та TiGER}
    \label{table:6-2-1}
\end{table}

\noindent Також порівняємо їхні характеристик згідно (NIST рівень 1)

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Метрика}       & \textbf{Kyber512} & \textbf{TiGER128} \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Безпека}}                         \\
        \hline
        Квантова безпека (біт) & 128               & 128               \\
        \hline
        Core-SVP $\beta$       & 512               & 483               \\
        \hline
        Класична безпека (біт) & 143               & 143               \\
        \hline
        DFP/R                  & $2^{-139}$        & $2^{-120}$        \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Розміри в байтах}}                 \\
        \hline
        Відкритий ключ $|pk|$  & 800               & 804               \\
        \hline
        Шифротекст $|ct|$      & 768               & 804               \\
        \hline
        Секретний ключ $|sk|$  & 1632              & 1876              \\
        \hline
        $|pk| + |ct|$          & 1568              & 1608              \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Продуктивність на x86}}           \\
        \hline
        KeyGen                 & 55K               & 40K               \\
        \hline
        Encaps                 & 75K               & 65K               \\
        \hline
        Decaps                 & 80K               & 70K               \\
        \hline
    \end{tabular}
    \caption{Порівняння Kyber512 та TiGER128 згідно NIST 1}
    \label{table:6-2-2}
\end{table}

\noindent Ми бачимо, що:

\begin{enumerate}
    \item \textbf{По безпеці:}
    \begin{itemize}
        \item Kyber512 має трохи вищий Core-SVP $\beta = 512$ порівняно з TiGER128 ($\beta = 483$). Це дає 
            невеликий запас безпеки $(\sim6\%)$;
        \item Kyber має значно нижчу DFP/R ($2^{-139}$ vs $2^{-120}$), що робить його надійнішим.
    \end{itemize}
    \item \textbf{По пам'яті:}
    \begin{itemize}
        \item TiGER128 має майже однакові розміри з Kyber512: $|pk| + |ct| = 1608$ vs 1568 байт;
        \item Kyber трохи компактніший завдяки використанню модульної структурі MLWE та оптимізованій компресії;
        \item Секретний ключ TiGER більший (+15\%), що є компромісом за зберігання додаткових seed для відновлення 
            секретного ключа та ключа $z$ для implicit rejection;
    \end{itemize}
    \item \textbf{По швидкодії:}
    \begin{itemize}
        \item TiGER показує кращу продуктивність ($\sim$10-27\% швидше), особливо на генерації ключів. Це 
            завдячуючи використанню побітових операцій за модулем $2^{14}$;
        \item Kyber з NTT асимптотично швидший для доволі великих $n$, але для $n = 256$ (Kyber) vs $n = 512$ (TiGER) 
            різниця є невеликою;
    \end{itemize}
\end{enumerate}

\subsection*{Переваги та недоліки}

\textbf{Переваги Kyber:}
\begin{itemize}
    \item \textbf{Стандартизація:} Затверджений NIST як ML-KEM;
    \item \textbf{Консервативність:} MLWE менш структурований за RLWE, вищий Core-SVP $\beta$, нижча DFP/R;
    \item \textbf{Досвід:} Багато оптимізаційних реалізацій (більше років "на сцені"{} алгоритмів);
    \item \textbf{NTT:} Асимптотично швидше множення для великих розмірностей (чесно, ну така собі перевага).
\end{itemize}

\textbf{Переваги TiGER:}
\begin{itemize}
    \item \textbf{Простота:} Відсутність NTT спрощує реалізацію;
    \item \textbf{Ефективність:} Швидші побітові операції з модулем призводять до кращих показників на практиці 
        для малих $n$;
    \item \item \textbf{Застосування кодів коректування:} Інтеграція XEf + D2 дозволяє агресивніше стискання та 
        підвищує надійність;
    \item \textbf{Implicit rejection:} Додатковий захист від failure boosting атак;
\end{itemize}

\textbf{Недоліки TiGER:}
\begin{itemize}
    \item \textbf{Відсутність стандартизації:} Поки що затверджений NIST;
    \item \textbf{Нижчий $\beta$:} Трохи менший запас безпеки порівняно з Kyber;
    \item \textbf{Вища DFP/R:} $2^{-120}$ vs $2^{-139}$ (по факту змагання "хто ближче до нуля"{}, бо і так це майже нуль);
    \item \textbf{Менше досліджена:} Менше публічних аудитів та оптимізованих реалізацій.
\end{itemize}

Kyber та TiGER представляють різну, так би мовити, філософію реалізації у постквантових KEM. Kyber обирає консервативний 
підхід (MLWE, вищий $\beta$), а TiGER фокусується на практичній ефективності (степені двійки, коди корекції).

\section{TiGER vs Saber}
\label{sec:6-3}

\section{TiGER vs SMAUG}
\label{sec:6-4}

\section{Узагальнене порівняння перелічених алгоритмів}
\label{sec:6-5}

\chapter{\large{Перенесення атак та можливі покращення}}
\label{chapter:7}

7.1 Аналіз слабких місць \\
7.2 Можливі вразливості через DFP/R \\
7.2 Meet-LWE атака (Alexander May) \\
7.3 CCA атаки на PKE (з роботи von Berg) \\
7.4 Атака з доступом до проміжного виводу декодування \\
7.5 Атака з урахуванням XEf корекції помилок \\
7.5 Side-channel attacks \\
7.6 Застосовність атак з інших RLWE/RLWR схем до TiGER \\

% TODO: Заповнити розділ

\chapter{\large{Практичне застосування та висновки}}
\label{chapter:8}

8.1 Можливі сценарії використання TiGER (TLS, VPN, messaging) \\
8.2 Підсумки дослідження \\
8.3 Перспективи розвитку постквантової криптографії \\

% TODO: Заповнити розділ

\chapter{\large{Результати власної реалізації}}
\label{chapter:9}

% TODO: Заповнити розділ
