\chapter{\large{Вступне слово}}
\label{chapter:1}

\textbf{Мета роботи} (власне, для чого ми тут зібралися):

Дослідити особливостей реалізації сучасних алгебраїчних криптосистем на прикладі учасників першого раунду
національного конкурсу з постквантової криптографії в Кореї (KpqC).

\noindent \textbf{Наші задачі на комп'ютерний практикум та порядок їх виконання:}
\begin{enumerate}[label=\arabic*)]
    \item Роздітися на бригади. Визначили хто за що відповідатиме. Богдан -- займається реалізацією алгоритму TiGER,
        Олексій -- теоретичною частиною і звітом загалом.
    \item Провести теоретичне дослідження теми, надавши вичерпний та повний опис теоретичної сторони алгоритму з усіма
        деталями та відомими результатами досліджень; провести аналіз вже існуючих атак на алгоритм TiGER, а також
        загалом можливих атак; виконати порівняльний аналіз нашого алгоритму зi схожими та дослідити можливість
        перенесення та застосування відомих атак на нього.
    \item Реалізувати алгоритм програмно та всі(нє, ну ми постараємося) можливі варіанти цього алгоритму;
    \item Перевірити коректність -- підтвердити правильність реалізації за допомогою тестів, використавши тестові
        дані з офіційної реалізації;
    \item Зробити аналіз продуктивності алгоритму та, знову ж таки, провести порівняння та аналіз швидкодії за різних
        умов, дослідити вплив модифікацій окремих його складових частин на ефективність.
\end{enumerate}

\chapter{\large{Загальне теоретичне дослідження}}
\label{chapter:2}
\section{Постквантова криптографія}
\label{sec:2-1}

Сучасна криптографія з відкритим ключем, зокрема RSA та криптографія на еліптичних кривих -- Elliptic Curve
Cryptography (ECC), базується на обчислювальній складності задач факторизації великих чисел та дискретного логарифмування.
Однак у 1994 році Пітер Шор~\cite{shor1994} продемонстрував квантові алгоритми, здатні розв'язувати ці задачі за
поліноміальний час на достатньо потужному квантовому комп'ютері. Це створює критичну загрозу для існуючої криптографічної
інфраструктури.

Постквантова криптографія (Post-Quantum Cryptography, PQC) -- це галузь криптографії, що розробляє алгоритми, стійкі
як до класичних, так і до квантових атак. Серед основних напрямків PQC виділяють криптографію на решітках, криптографію
на кодах виправлення помилок, багатовимірну поліноміальну(квадратичну) криптографію та криптографію на основі
геш-функцій~\cite{WikiPQC}.

\section{Передумови створення TiGER}
\label{sec:2-2}

Механізм інкапсуляції ключа (Key Encapsulation Mechanism, KEM) є одним з найважливіших криптографічних примітивів для
захищеного обміну ключами. У контексті заміни класичних протоколів, таких як Diffie-Hellman (DH) або Elliptic Curve
Diffie-Hellman ECDH, постквантові KEM повинні забезпечувати не лише високий рівень безпеки, але й бути ефективними за
розміром даних та залишатися обчислювано складними для зламу зловмисником.

Криптографія на решітках, зокрема алгоритми на основі задач Learning With Errors (LWE)~\cite{regev2005} та Ring Learning
With Errors (RLWE)~\cite{lyubashevsky2010}, продемонструвала перспективність у створенні ефективних постквантових
схем. Розвиток цього напрямку призвів до появи сімейства алгоритмів, що використовують детермінований варіант --
Learning With Rounding (LWR)~\cite{banerjee2012}, який замінює випадкову помилку округленням, що покращує як
продуктивність, так і довжину шифротексту.

Серед попередніх розробок слід відзначити алгоритми Lizard~\cite{lizard2018} та RLizard~\cite{rlizard2018}, які
комбінували RLWE для генерації ключів з RLWR для шифрування, досягаючи балансу між безпекою та ефективністю. Однак
ці схеми мали певні обмеження щодо розміру відкритого ключа та шифротексту, що ускладнювало їх інтеграцію в існуючі протоколи.

TiGER (Tiny bandwidth key encapsulation mechanism for easy miGration based on RLWE(R))~\cite{tiger2022} був розроблений
командою дослідників з метою створення компактного та ефективного KEM, придатного для легкої інтеграції в існуючі системи
безпеки. Основні задачі, які ставили перед собою науковці це:

\begin{itemize}
    \item \textbf{Мінімізація розміру шифротексту та відкритого ключа}
    \item \textbf{Висока обчислювальна ефективність} --- використання в якості модуля число, яке є степенем двійки ($q = 2^{k}$)
        (для оптимізації операцій округлення через побітові зсуви);
    \item \textbf{Відмова від NTT} --- алгоритм не використовує Number Theoretic Transform, що спрощує реалізацію;
    \item \textbf{Використання розріджених секретів (з малою вагою Геммінга)} --- зменшення розміру секретного ключа та прискорення
        множення многочленів;
    \item \textbf{Корекція помилок} --- застосування кодів XEf та D2 для зниження ймовірності помилки розшифрування.
\end{itemize}

Конструкція TiGER базується на комбінації RLWR для генерації відкритого ключа та RLWE для шифрування, з подальшим 
застосуванням перетворення Fujisaki-Okamoto~\cite{fo1999, fo2013} для досягнення IND-CCA безпеки.

\section{Участь у KpqC та злиття з SMAUG}
\label{sec:2-3}

У 2022 році Національна служба розвідки Республіки Корея ініціювала Korean Post-Quantum Cryptography Competition
скорочено -- KpqC~\cite{kpqc2023}. Це національний конкурс для стандартизації постквантових криптографічних алгоритмів.

Обраний нами для аналізу алгоритм TiGER був поданий на перший раунд конкурсу KpqC у категорії механізмів інкапсуляції
ключа (KEM) і був одним з чотирьох алгоритмів, які пройшли до другого раунду.

\subsection{Злиття TiGER та SMAUG}
Команди TiGER та SMAUG об'єдналися для створення спільного алгоритму SMAUG-T~\cite{smaugt2024}. Метою злиття було
поєднання переваг обох підходів:

\begin{itemize}
    \item Від \textbf{TiGER}: Компактність шифротексту, використання RLWE/RLWR на кільцевому рівні, корекція помилок
        через D2 кодування (для параметра TiMER);
    \item Від \textbf{SMAUG}: Модульна структура (MLWE/MLWR), розріджені секрети через використання гаусівського
        шуму, покращена безпека за рахунок збільшення розмірності.
\end{itemize}

Результатом злиття став алгоритм SMAUG-T версії 3.0 (лютий 2024), який включає в себе:
\begin{itemize}
    \item Три основні набори параметрів: \textbf{SMAUG-T128}, \textbf{SMAUG-T192}, \textbf{SMAUG-T256}
        (відповідають рівням безпеки NIST 1, 3, 5);
    \item Додатковий набір параметрів \textbf{TiMER} (Tiny SMAUG using Error Reconciliation) -- оптимізований для
        IoT(Internet of Thing)-пристроїв з мінімальним шифротекстом завдяки використанню D2 кодування з TiGER.
\end{itemize}

\subsection{Результати KpqC 2023}

У січні 2025 року було оголошено фінальні результаті конкурсу KpqC. Переможцями стали:
\begin{itemize}
    \item У категорії KEM: \textbf{SMAUG-T} та \textbf{NTRU+};
    \item У категорії цифрового підпису: \textbf{HAETAE} (до речі, також від команди SMAUG).
\end{itemize}

Таким чином, ідеї та технології TiGER увійшли до складу національного стандарту постквантової криптографії Кореї
через алгоритм SMAUG-T.

\chapter{\large{Теоретична база алгоритму TiGER}}
\label{chapter:3}

\section{Алгебраїчні структури}
\label{sec:3-1}
Критографія на решітках (Lattice-based cryptography) використовує алгебраїчні структури для забезпечення ефективності
обчислень та компактності представлення даних. У цьому розділі я розпишу основні алгебраїчні об'єкти, що застосовуються
в алгоритмі TiGER.

\subsection{Кільця та многочлени}
\label{subsec:3-1-1}

\begin{definition}[Кільце]
    \label{def:3-1-1}
    ~\par Кільце $(R, +, \cdot)$ -- це множина з двома операціями: додавання $(+)$ та множення $(\cdot)$, що задовольняє
    наступні властивості:
    \begin{enumerate}
        \item $(R, +)$ є абелевою групою за додаванням. Нейтральний елемент $0$;
        \item Множення є асоціативним: $(a \cdot b) \cdot c = a \cdot (b \cdot c)$, $\forall \, a, b, c \in R$;
        \item Дистрибутивність: $a \cdot (b + c) = a \cdot b + a \cdot c$ та $(b + c) \cdot a = b \cdot a + c \cdot a$,
            $\forall \, a, b, c \in R$;
        \item Існує нейтральний елемент за множенням: $1 \in R$ такий, що $1 \cdot a = a \cdot 1 = a$, $\forall\, a \in R$.
    \end{enumerate}
    Якщо ще $a \cdot b = b \cdot a$, $\forall \, a, b \in R$, то таке кільце називається \textit{комутативним}.
\end{definition}

\begin{definition}[Кільце многочленів]
    \label{def:3-1-2}
    ~\par Нехай $R$ -- комутативне кільце з одиницею. Кільце многочленів $R[x]$ складається з усіх виразів виду
    \begin{equation*}
        f(x) = a_{n} x^{n} + a_{n-1} x^{n-1} + \ldots + a_{1} x + a_{0},
    \end{equation*}
    де $\forall \, i : a_{i} \in \mathbb{R}$, $a_{n} \neq 0$ та $n \in \mathbb{Z}$.

    Число $n$ називається \textit{степенем} многочлена $f(x)$, позначається $\deg(f)$.
\end{definition}

Операції додавання та множення многочленів наступним чином:
\begin{itemize}
    \item $(f + g)(x) = \sum\limits_{i=0}^{\max(\deg(f), \deg(g))} (a_i + b_i) x^i$, де $a_i, b_i$ -- коефіцієнти $f$ та $g$ відповідно;
    \item $(f \cdot g)(x) = \sum\limits_{k=0}^{\deg(f) + \deg(g)} c_k x^k$, де $c_k = \sum\limits_{i=0}^{k} a_i b_{k-i}$.
\end{itemize}

\subsection{Факторкільця многочленів}
\label{subsec:3-1-2}

\begin{definition}[Факторкільце]
    \label{def:3-1-3}
    ~\par Нехай $R$ -- кільце та $I$ -- його ідеал. Факторкільце $R/I$ складається з класів еквівалентності
    $a + I = \{a + r : r \in I\}$ для $a \in R$, з операціями:
    \begin{equation*}
        (a + I) + (b + I) = (a + b) + I, \quad (a + I) \cdot (b + I) = (a \cdot b) + I.
    \end{equation*}
\end{definition}

\noindent У Lattice-based cryptography найчастіше використовується факторкільце многочленів за ідеалом, що породжений
циклотомічним многочленом.

\begin{definition}[Циклотомічний многочлен]
    \label{def:3-1-4}
    ~\par $n$-ий циклотомічний многочлен (Cyclotomic polynomial) $\Phi_n(x)$ визначається як мінімальний многочлен над $\mathbb{Q}$, коренями
    якого є примітивні корені $n$-го степеня з одиниці:
    \begin{equation*}
        \Phi_n(x) = \prod_{\substack{1 \leq k \leq n \\ \gcd(k, n) = 1}} \left(x - e^{2\pi i k / n}\right).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{lemma:3-1-1}
    Для $n = 2^k$, де $k \in \mathbb{N}$, циклотомічний многочлен має вигляд:
    \begin{equation*}
        \Phi_n(x) = x^{n/2} + 1.
    \end{equation*}
\end{lemma}

\begin{proof}
    При $n = 2^k$ примітивними коренями $n$-го степеня з одиниці є $e^{2\pi i m / n}$ для непарних $m$. З
    $(x^{n/2} + 1) = (x^n - 1)/(x^{n/2} - 1)$ випливає твердження леми.
\end{proof}

\subsection{Кільце многочленів у TiGER}
\label{subsec:3-1-3}

В алгоритмі TiGER використовується кільце многочленів виду:
\begin{equation*}
    \label{eq:3-1-1}
    R_q = \frac{\mathbb{Z}_q[x]}{(x^n + 1)},
\end{equation*}
де $n$ -- степінь двійки (зазвичай $n = 512$ або $n = 1024$), а $q$ -- модуль, що також є степенем двійки
($q = 256$ у всіх варіаціях алгоритму TiGER).

Елементами $R_q$ є многочлени степеня не вище $n-1$ з коефіцієнтами з $\mathbb{Z}_q$:
\begin{equation*}
    f(x) = \sum\limits_{i=0}^{n-1} a_i x^i, \quad a_i \in \mathbb{Z}_q.
\end{equation*}

Вибір саме такого $n$ та многочлена $x^n + 1$ забезпечує:
\begin{itemize}
    \item Ефективність множення многочленів (без потреби в NTT);
    \item Редукцію за модулем $x^n + 1$, що спрощує обчислення;
    \item Зв'язок з циклотомічними многочленами та решітковими задачами.
\end{itemize}

\subsection{Операції в кільці \texorpdfstring{$R_q$}{ring Q}}
\label{subsec:3-1-4}

Для $f(x), g(x) \in R_q$ операції в кільці визначаються наступним чином:

\textbf{Додавання:} покоефіцієнтне за модулем $q$:
\begin{equation*}
    (f + g)(x) = \sum_{i=0}^{n-1} ((f_i + g_i) \bmod q) x^i.
\end{equation*}

\textbf{Множення:} спочатку виконується звичайне множення многочленів, потім взяття за модулем $(x^n + 1)$ та $q$.
Оскільки $x^n \equiv -1 \pmod{x^n + 1}$, то маємо:
\begin{equation*}
    \label{eq:3-1-2}
    h_i = \left(\sum_{j=0}^{i} f_j g_{i-j} - \sum_{j=i+1}^{n-1} f_j g_{n+i-j}\right) \bmod q,
\end{equation*}
де $h(x) = (f \cdot g)(x) = \sum_{i=0}^{n-1} h_i x^i$.

\section{Задачі на решітках}
\label{sec:3-2}

Безпека TiGER базується на обчислювальній складності певних задач на решітках. У цьому підпункті зазначимо основні
решіткові задачі, що лежать в основі постквантової криптографії.

\subsection{Решітки та базові задачі}
\label{subsec:3-2-1}

\begin{definition}[Решітка]
    \label{def:3-2-1}
    ~\par Нехай $\mathbf{b}_1, \mathbf{b}_2, \ldots, \mathbf{b}_m \in \mathbb{R}^n$ -- лінійно незалежні вектори.
    Решітка $\Lambda$, породжена цими векторами, визначається як:
    \begin{equation*}
        \Lambda = \Lambda(\mathbf{b}_1, \ldots, \mathbf{b}_m) = \left\{ \sum_{i=1}^{m} a_i \mathbf{b}_i : a_i \in \mathbb{Z} \right\}.
    \end{equation*}
    Вектори $\mathbf{b}_1, \ldots, \mathbf{b}_m$ називаються базисом решітки, а $m$ -- розмірністю решітки.
\end{definition}

\begin{definition}[Мінімальна відстань решітки(shortest vector)]
    \label{def:3-2-2}
    ~\par Мінімальна відстань решітки $\Lambda$ визначається як:
    \begin{equation*}
        \lambda_1(\Lambda) = \min_{\mathbf{v} \in \Lambda \setminus \{\mathbf{0}\}} \|\mathbf{v}\|,
    \end{equation*}
    де $\|\cdot\|$ -- евклідова норма.
\end{definition}

\begin{definition}[SVP]
    \label{def:3-2-3}
    ~\par \textit{Shortest Vector Problem (SVP):} Для заданого базису решітки $\Lambda$ знайти ненульовий вектор
    $\mathbf{v} \in \Lambda$ такий, що $\|\mathbf{v}\| = \lambda_1(\Lambda)$.
\end{definition}

\noindent SVP є NP-складною задачею~\cite{ajtai1998}. Для криптографічних цілей часто використовується наступна версія:

\begin{definition}[Апроксимаційна задача SVP]
    \label{def:3-2-4}
    ~\par \textit{$\gamma$-approximate SVP ($\gamma$-SVP):} Для заданого базису решітки $\Lambda$ та параметра
    наближення $\gamma \geq 1$, знайти ненульовий вектор $\mathbf{v} \in \Lambda$ такий, що
    $\|\mathbf{v}\| \leq \gamma \cdot \lambda_1(\Lambda)$.
\end{definition}

\subsection{Задача Learning With Errors (LWE)}
\label{subsec:3-2-2}

Задача Learning With Errors була введена Одедом Регєвим у 2005 році~\cite{regev2005} і стала основою для багатьох
постквантових криптосистем.

\begin{definition}[LWE задача (search version)]
    \label{def:3-2-5}
    ~\par Нехай $n, q \geq 1$ -- цілі числа, $\chi$ -- розподіл ймовірностей на $\mathbb{Z}_q$. Пошукова задача
    $\text{LWE}_{n,q,\chi}$ визначається наступним чином:

    Для невідомого секрету $\mathbf{s} \in \mathbb{Z}_q^n$ та заданої послідовності пар $(\mathbf{a}_i, b_i) \in \mathbb{Z}_q^n \times \mathbb{Z}_q$,
    де
    \begin{equation*}
        b_i = \langle \mathbf{a}_i, \mathbf{s} \rangle + e_i \pmod{q},
    \end{equation*}
    з випадково обраними $\mathbf{a}_i \in \mathbb{Z}_q^n$, $\langle \cdot, \cdot \rangle$ -- операція векторного
    добутку та $e_i \xleftarrow{p} \chi$, знайти секрет $\mathbf{s}$.
\end{definition}

\begin{definition}[LWE задача (detection version)]
    \label{def:3-2-6}
    ~\par Розпізнавальна задача $\text{Decision-LWE}_{n,q,\chi}$ полягає у розрізненні наступних двох розподілів:
    \begin{itemize}
        \item $(\mathbf{a}, \langle \mathbf{a}, \mathbf{s} \rangle + e \bmod q)$, де
            $\mathbf{a} \leftarrow \mathbb{Z}_q^n$, $\mathbf{s} \in \mathbb{Z}_q^n$ фіксоване,
            $e \xleftarrow{p} \chi$;
        \item $(\mathbf{a}, u)$, де $\mathbf{a}, u$ -- рівноймовірно розподілені на $\mathbb{Z}_q^n$ та $\mathbb{Z}_q$ відповідно.
    \end{itemize}
\end{definition}

\begin{theorem}[Регєва]
    \label{theorem:3-2-1}
    ~\par Для певних параметрів $n, q, \chi$, розв'язання задачі Decision-LWE за поліноміальний час у середньому
    випадку еквівалентно розв'язанню наближеної задачі $\gamma$-SVP за квантовий поліноміальний час у найгіршому
    випадку для деякого $\gamma = \tilde{O}(n/\sigma)$.
\end{theorem}

\subsection{Задача Ring Learning With Errors (RLWE)}
\label{subsec:3-2-3}

Ring-LWE є алгебраїчною версією LWE, що вже використовує кільця многочленів для більшої
ефективності~\cite{lyubashevsky2010}.

\begin{definition}[RLWE задача]
    \label{def:3-2-7}
    ~\par Нехай $R = \mathbb{Z}[x]/(x^n + 1)$, $R_q = \mathbb{Z}_q[x]/(x^n + 1)$, та $\chi$ -- розподіл ймовірностей
    на $R_q$. Розпізнавальна задача $\text{Decision-RLWE}_{n,q,\chi}$ полягає у розрізненні наступних розподілів:
    \begin{itemize}
        \item $(a, a \cdot s + e)$, де обрано $a \in R_q$ (рівномірний розподіл), $s \in R_q$ фіксоване, $e \xleftarrow{p} \chi$;
        \item $(a, u)$, де $a, u$ обрані рівномірно з $R_q$.
    \end{itemize}
\end{definition}

Важливим є те, що RLWE дозволяє представляти $n$ секретів (LWE-зразків) у вигляді одного многочлена в $R_q$, що
значно зменшує розмір ключів та шифротекстів. Для TiGER використовується $n \in \{512, 1024\}$ та $q = 256$.

\subsection{Задача Learning With Rounding (LWR)}
\label{subsec:3-2-4}

Learning With Rounding є детермінованим варіантом LWE, де замість додавання випадкової помилки використовується
округлення~\cite{banerjee2012}.

\begin{definition}[LWR задача]
    \label{def:3-2-8}
    ~\par Нехай $n, q, p$ -- цілі числа, $p < q$. Визначимо функцію округлення $\lfloor \cdot \rceil_p : \mathbb{Z}_q \to \mathbb{Z}_p$ як
    \begin{equation*}
        \lfloor x \rceil_p = \left\lfloor \frac{p}{q} \cdot x \right\rceil \bmod p,
    \end{equation*}
    де $\lfloor \cdot \rceil$ позначатиме округлення до найближчого цілого.

    Розпізнавальна задача $\text{Decision-LWR}_{n,q,p}$ полягає у розрізненні наступних розподілів:
    \begin{itemize}
        \item $(\mathbf{a}, \lfloor \langle \mathbf{a}, \mathbf{s} \rangle \rceil_p)$, де
            $\mathbf{a} \leftarrow \mathbb{Z}_q^n$, $\mathbf{s} \in \mathbb{Z}_q^n$ -- фіксоване;
        \item $(\mathbf{a}, u)$, де $\mathbf{a} \leftarrow \mathbb{Z}_q^n$, $u \leftarrow \mathbb{Z}_p$.
    \end{itemize}
\end{definition}

\begin{theorem}[Редукція (взяття за модулем) LWR до LWE~\cite{banerjee2012}]
    \label{theorem:3-2-2}
    Для відповідних параметрів $n, q, p$ та достатньо малого розподілу помилок $\chi$, задача Decision-LWR$_{n,q,p}$
    зводиться до задачі Decision-LWE$_{n,q,\chi}$.
\end{theorem}

\begin{remark}
    (Ідея теореми) При достатньо великому відношенні $q/p$, округлення $\lfloor \langle \mathbf{a}, \mathbf{s} \rangle \rceil_p$
    стає еквівалентно до додавання малої помилки округлення, яка розподілена майже рівномірно на інтервалі $(-q/(2p), q/(2p)]$.
\end{remark}

\subsection{Задача Ring Learning With Rounding (RLWR)}
\label{subsec:3-2-5}

RLWR поєднує переваги RLWE (компактність -- за рахунок алгебраїчної структури) та LWR (детермінованість,
та відсутність потреби у відборі помилок(sampling)).

\begin{definition}[RLWR задача]
    \label{def:3-2-9}
    ~\par Нехай $R_q = \mathbb{Z}_q[x]/(x^n + 1)$, $R_p = \mathbb{Z}_p[x]/(x^n + 1)$, де $p < q$. Функція округлення
    застосовуються для кожного коефіцієнта окремо:
    \begin{equation*}
        \lfloor f \rceil_p = \sum\limits_{i=0}^{n-1} \left\lfloor \frac{p}{q} \cdot f_i \right\rceil x^i \bmod p.
    \end{equation*}

    Розпізнавальна задача $\text{Decision-RLWR}_{n,q,p}$ полягає у розрізненні:
    \begin{itemize}
        \item $(a, \lfloor a \cdot s \rceil_p)$, де $a \in R_q$ обрано рівномірно, $s \in R_q$ фіксоване;
        \item $(a, u)$, де $a \in R_q$, $u \in R_p$ обрані рівномірно.
    \end{itemize}
\end{definition}

\begin{claim}
    \label{claim:3-2-1}
    ~\par При певних параметрах $n,q,p$, задача RLWR$_{n,q,p}$ є не легшою за задачу RLWE$_{n,q,\chi}$ з розподілом помилок
    $\chi$, що відповідає помилці округлення.
\end{claim}

У TiGER використовується комбінація: RLWR -- для генерації відкритого ключа (компактність) та RLWE -- для шифрування
(гнучкості у контролі помилок). Модулі обираються як степені двійки: $q = 256$, $p \in \{64, 128\}$, що дозволяє
реалізувати округлення через побітові зсуви. Про це поговоримо детальніше наступному,~\ref{chapter:4} розділі.

\section{"Сімейство"{} алгоритмів на базі RLWE/RLWR}
\label{sec:3-3}

TiGER належить до сімейства алгоритмів на решітках, які базуються на задачах RLWE та RLWR. Опишемо основні алгоритми
цього сімейства, які вплинули на дизайн TiGER (далі). Далі їх буде порівняно у розділі~\ref{chapter:6} та попередньо
у таблиці~\ref{table:3-3-1}.

\subsection{Lizard}
\label{subsec:3-3-1}

Lizard~\cite{lizard2018} був одним з перших алгоритмів, що комбінував у собі LWE та LWR для досягнення балансу між
безпекою та ефективністю.

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} LWE для генерації відкритого ключа, LWR для шифрування;
    \item \textbf{Простір:} Цілочисельні решітки над $\mathbb{Z}_q^n$ без використання кільцевої структури;
    \item \textbf{Модуль:} Малий модуль $q$ для покращення коректності;
    \item \textbf{Розміри:} Великі ключі (через відсутність алгебраїчної структури).
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Консервативна безпека (базується на стандартній LWE);
    \item Низька ймовірність помилки розшифрування.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Великі розміри ключів та шифротекстів;
    \item Повільніше множення векторів (порівняно з кільцевими варіантами).
\end{itemize}

\subsection{RLizard}
\label{subsec:3-3-2}

RLizard~\cite{rlizard2018} є кільцевою версією попереднього алгоритму, оптимізованою для IoT-пристроїв.

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} RLWE для генерації ключів, RLWR для шифрування;
    \item \textbf{Простір:} $R_q = \mathbb{Z}_q[x]/(x^n + 1)$, $n = 512$ або $n = 1024$;
    \item \textbf{Модуль:} Малий модуль $q$ (наприклад, $q = 1024$);
    \item \textbf{Помилки:} Дискретний гаусівський розподіл помилок з високою точністю (CDT-sampling).
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Компактні ключі та шифротексти завдяки кільцевій структурі;
    \item Швидке шифрування/розшифрування;
    \item Висока коректність;
    \item Підходить для пристроїв з обмеженим ресурсом.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Відносно велика пропускна здатність порівняно з найкомпактнішими схемами;
    \item Залежність від якісного(справді випадкового) семплювання гаусівських помилок.
\end{itemize}

\subsection{CRYSTALS-Kyber}
\label{subsec:3-3-3}

Kyber~\cite{kyber2018} є одним з фіналістів конкурсу NIST PQC і базується на Module-LWE (MLWE).

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} MLWE для обох операцій -- генерації ключів та шифрування повідомлення;
    \item \textbf{Простір:} Модульні решітки $R_q^k$, де $k \in \{2, 3, 4\}$ (залежно від рівня безпеки);
    \item \textbf{Модуль:} $q = 3329$ (просте число для ефективного NTT);
    \item \textbf{Оптимізація:} Number Theoretic Transform (NTT) для швидкого множення многочленів (хах, тут
        порівнюючи з чим саме і що вважати швидко);
    \item \textbf{Компресія:} Агресивне "стиснення"{} шифротексту.
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Стандартизовано під NIST (FIPS 203);
    \item Непоганий баланс між розмірами, швидкістю та безпекою;
    \item Ефективна реалізація з NTT.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Використання простого модуля ускладнює деякі оптимізації;
    \item Більший шифротекст порівняно з деякими MLWR-схемами.
\end{itemize}

\subsection{Saber}
\label{subsec:3-3-4}

Saber~\cite{saber2018} є Module-LWR схемою, фіналістом NIST PQC Round 3.

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} MLWR для обох операцій;
    \item \textbf{Простір:} Модульні решітки $R_q^k$, $k \in \{2, 3, 4\}$;
    \item \textbf{Модуль:} $q = 8192 = 2^{13}$;
    \item \textbf{Оптимізація:} Відсутність NTT (округлення завдяки побітовим операціям);
    \item \textbf{Помилки:} Детерміновані (через застосування округлення).
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Компактний шифротекст;
    \item Простота реалізації (без потреби в NTT чи гаусівському семплюванні);
    \item Ефективні побітові операції;
    \item Хороша стійкість до side-channel атак.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Більший(за розміром) відкритий ключ порівняно з Kyber;
\end{itemize}

\newpage %FORCED
\subsection{Порівняння алгоритмів, і що з них взяв TiGER}
\label{subsec:3-3-5}

\begin{table}[ht]
    \centering
    \begin{tblr}{
            colspec = {Q[l,m] Q[c,m] Q[c,m] Q[c,m] Q[c,m]},
            hlines, vlines,
            row{1} = {font=\bfseries}
        }
        Характеристика & Lizard  & RLizard   & Kyber             & Saber        \\
        Структура      & LWE/LWR & RLWE/RLWR & MLWE              & MLWR         \\
        Розмірність    & $n$     & $n$       & $n \times k$      & $n \times k$ \\
        Модуль $q$     & малий   & малий     & 3329              & 8192         \\
        NTT            & Ні      & Ні        & Так               & Ні           \\
        Семплювання    & Гаусс   & Гаусс/CDT & Centered binomial & Округлення   \\
        Компресія      & Помірна & Помірна   & Агресивна         & Помірна      \\
    \end{tblr}
    \caption{Порівняння підходів у сімействі RLWE/RLWR алгоритмів}
    \label{table:3-3-1}
\end{table}

\noindent TiGER об'єднує в собі найкращі ідеї з попередніх доробок:

\textbf{Позиція TiGER:}
\begin{itemize}
    \item Базується на \textbf{RLWE/RLWR} (як RLizard);
    \item Використовує \textbf{степені двійки} для $q, p$ (як Saber);
    \item \textbf{Розріджені секрети} для ефективності;
    \item \textbf{Корекція помилок} (XEf, D2) для мінімізації DFP/R;
    \item \textbf{Без NTT} для простоти;
    \item Фокусування на \textbf{мінімальному шифротексті} для легшого впровадження в існуючі протоколи.
\end{itemize}

\section{Криптографічні примітиви}
\label{sec:3-4}

У цій частині розділу розглянемо базові криптографічні примітиви, що використовуються для безпосередньо при побудові
TiGER: схеми шифрування з відкритим ключем (PKE) та механізми інкапсуляції ключа (KEM).

\subsection{Схема шифрування з відкритим ключем (PKE)}
\label{subsec:3-4-1}

\begin{definition}[PKE схема]
    \label{def:3-4-1}
    ~\par Схема шифрування з відкритим ключем (Public Key Encryption, PKE) складається з трьох алгоритмів:
    \begin{itemize}
        \item $\mathsf{KeyGen}(1^\lambda) \to (\mathsf{pk}, \mathsf{sk})$ --- ймовірнісний алгоритм генерації
            ключів, що на вході приймає параметр безпеки $\lambda$ і повертає пару: відкритий ключ $\mathsf{pk}$ та
            секретний ключ $\mathsf{sk}$;
        \item $\mathsf{Enc}(\mathsf{pk}, m; r) \to c$ --- ймовірнісний алгоритм шифрування, що приймає відкритий
            ключ $\mathsf{pk}$, повідомлення $m$ з простору повідомлень $\mathcal{M}$ та випадкове число $r$, і
            повертає шифротекст $c$;
        \item $\mathsf{Dec}(\mathsf{sk}, c) \to m'$ --- детермінований алгоритм розшифрування, що приймає
            секретний ключ $\mathsf{sk}$ і шифротекст $c$, та повертає повідомлення $m'$ або помилку -- $\bot$.
    \end{itemize}
\end{definition}

\begin{definition}[Коректність PKE]
    \label{def:3-4-2}
    ~\par PKE схема є $(1-\delta)$-коректною, якщо для будь-якої пари ключів
    $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ та будь-якого повідомлення $m \in \mathcal{M}$ виконується:
    \begin{equation*}
        \mathbb{P}[\mathsf{Dec}(\mathsf{sk}, \mathsf{Enc}(\mathsf{pk}, m)) \neq m] \leq \delta,
    \end{equation*}
    де ймовірність визначається через випадковість алгоритму $\mathsf{Enc}$. Параметр $\delta$ називається
    \textit{ймовірністю помилки розшифрування} (Decryption Failure Probability/Rate, DFP/R)
\end{definition}

У задачах на решітках, через наявність помилок у RLWE/RLWR, коректність не завжди є ідеальною. Тому для практичних
застосувань необхідно, щоб $\delta$ було незначним ($\delta \leq 2^{-128}$).

\subsection{Механізм інкапсуляції ключа (KEM)}
\label{subsec:3-4-2}

\begin{definition}[KEM схема]
    \label{def:3-4-3}
    ~\par Механізм інкапсуляції ключа (Key Encapsulation Mechanism, KEM) складається з трьох кроків:
    \begin{itemize}
        \item $\mathsf{KeyGen}(1^\lambda) \to (\mathsf{pk}, \mathsf{sk})$ --- алгоритм генерації ключів
            (аналогічно до PKE);
        \item $\mathsf{Encaps}(\mathsf{pk}) \to (c, K)$ --- ймовірнісний алгоритм інкапсуляції, що приймає
            відкритий ключ $\mathsf{pk}$ і повертає шифротекст $c$ та спільний секретний ключ $K \in \mathcal{K}$;
        \item $\mathsf{Decaps}(\mathsf{sk}, c) \to K'$ --- детермінований алгоритм декапсуляції, що приймає
            секретний ключ $\mathsf{sk}$ і шифротекст $c$, та повертає прихований секретний ключ $K'$ або символ
            помилки $\bot$.
    \end{itemize}
\end{definition}

\begin{definition}[Коректність KEM]
    \label{def:3-4-4}
    ~\par KEM схема є $(1-\delta)$-коректною, якщо для будь-якої пари ключів
    $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ справджується таке:
    \begin{equation*}
        \mathbb{P}[\mathsf{Decaps}(\mathsf{sk}, c) \neq K : (c, K) \gets \mathsf{Encaps}(\mathsf{pk})] \leq \delta.
    \end{equation*}
\end{definition}

\subsection{Побудова KEM з PKE}
\label{subsec:3-4-3}

Стандартний спосіб побудови KEM з PKE полягає у шифруванні випадкового повідомлення та використанні геш-функції
для отримання спільного ключа.

\begin{claim}[Нативна побудова KEM]
    \label{claim:3-4-1}
    ~\par Нехай $\mathsf{PKE} = (\mathsf{KeyGen}, \mathsf{Enc}, \mathsf{Dec})$ -- PKE це ось така трійка, що містить
    у собі простір повідомлень $\mathcal{M}$, та $H: \mathcal{M} \to \mathcal{K}$ -- деяка геш-функція. Тоді можна
    побудувати KEM
    таким способом:
    \begin{itemize}
        \item Спосіб генерації $\mathsf{KeyGen}$ такий же, як у PKE;
        \item $\mathsf{Encaps}(\mathsf{pk})$: обирають $m \in \mathcal{M}$, а далі обчислюють
            $c \gets \mathsf{Enc}(\mathsf{pk}, m)$ та $K \gets H(m)$. На виході отримано пару: $(c, K)$;
        \item $\mathsf{Decaps}(\mathsf{sk}, c)$: обчислюють $m' \gets \mathsf{Dec}(\mathsf{sk}, c)$ та на виході
            отримуємо $K' \gets H(m')$.
    \end{itemize}
\end{claim}

Така побудова не забезпечує IND-CCA безпеки навіть якщо базова PKE схема є IND-CPA безпечною, але для нас головне
щоб було зрозуміло як цей механізм працює). А для досягнення IND-CCA безпеки вже необхідно застосувати перетворення
Fujisaki-Okamoto (розглянемо його у секції~\ref{sec:3-6}).

\subsection{Криптографічні геш-функції}
\label{subsec:3-4-4}

\begin{definition}[Криптографічна геш-функція]
    \label{def:3-4-5}
    ~\par Функція $H: \{0,1\}^* \to \{0,1\}^n$ називається криптографічною геш-функцією, якщо вона задовольняє
    наступні умови:
    \begin{enumerate}
        \item \textbf{Стійкість до знаходження прообразу:} Для випадкового $y \in \{0,1\}^n$ обчислювально
            важко знайти $x$ такий, що $H(x) = y$;
        \item \textbf{Стійкість до знаходження другого прообразу:} Для заданого $x$ обчислювально важко знайти
            $x' \neq x$ такий, що $H(x') = H(x)$;
        \item \textbf{Стійкість до колізій:} Обчислювально важко знайти дві різні величини $x, x'$
            такі, що $H(x) = H(x')$.
    \end{enumerate}
\end{definition}

У TiGER використовуються геш-функції з сімейства SHA-3 -- SHAKE256 (або SHA3-256) для генерації випадковості, обчислення
спільних ключів та інших криптографічних операцій. SHAKE256 є функцією з розширеним виходом (XOF), що дозволяє
генерувати вихід довільної довжини.

\subsection{Зв'язок PKE та KEM у TiGER}
\label{subsec:3-4-5}

TiGER складається з двох рівнів:
\begin{enumerate}
    \item \textbf{TiGER.PKE} -- являє собою базову IND-CPA безпечну схему шифрування, що базується на RLWE(R);
    \item \textbf{TiGER.KEM} -- KEM, отриманий застосуванням перетворення Fujisaki-Okamoto (FO) до TiGER.PKE
        для досягнення IND-CCA безпеки.
\end{enumerate}
Це дозволяє:
\begin{itemize}
    \item Окремо аналізувати безпеку PKE (на базі RLWE/RLWR);
    \item Використовувати загальні результати про перетворення FO для доведення IND-CCA безпеки KEM;
\end{itemize}

\section{Основні поняття безпеки, що стосуються TiGER}
\label{sec:3-5}

\subsection{IND-CPA безпека}
\label{subsec:3-5-1}

\begin{definition}[IND-CPA (Indistinguishability under Chosen-Plaintext Attack) гра для PKE]
    \label{def:3-5-1}
    ~\par Розглянемо наступну "гру"{} між претендентом (challenger) $\mathcal{C}$ та супротивником (adversary) $\mathcal{A}$:
    \begin{enumerate}
        \item $\mathcal{C}$ генерує $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ і передає
            $\mathsf{pk}$ супротивнику $\mathcal{A}$;
        \item $\mathcal{A}$ обирає два повідомлення $m_0, m_1 \in \mathcal{M}$ однакової довжини і передає їх
            $\mathcal{C}$;
        \item $\mathcal{C}$ Випадковим чином обирає біт $b \xleftarrow{p} \{0,1\}$, обчислює
            $c \gets \mathsf{Enc}(\mathsf{pk}, m_b)$ і передає $c$ супротивнику $\mathcal{A}$;
        \item $\mathcal{A}$ виводить біт $b'$.
    \end{enumerate}
    Перевага супротивника визначається наступним чином:
    \begin{equation*}
        \mathsf{Adv}^{\text{IND-CPA}}_{\mathsf{PKE}}(\mathcal{A}) = \left| \mathbb{P}[b' = b] - \frac{1}{2} \right|
        + \varepsilon(\lambda).
    \end{equation*}

    PKE схема є IND-CPA безпечною, якщо для будь-якого ефективного (PPT) супротивника $\mathcal{A}$ перевага
    $\mathsf{Adv}^{\text{IND-CPA}}_{\mathsf{PKE}}(\mathcal{A})$ є незначною функцією від $\lambda$.
\end{definition}

IND-CPA безпечність означає нерозрізненість шифротекстів: супротивник маючи доступ до відкритого ключа (а отже,
має можливість шифрувати будь-які повідомлення), не може визначити, яке з двох повідомлень було зашифроване. Це
вимагає від шифрування, щоб воно було ймовірнісним.

\begin{definition}[IND-CPA (Indistinguishability under Chosen-Plaintext Attack) безпека для KEM]
    \label{def:3-5-2}
    ~\par Для KEM "гра"{} IND-CPA визначається аналогічно:
    \begin{enumerate}
        \item $\mathcal{C}$ генерує пару $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ і
            передає $\mathsf{pk}$ супротивнику $\mathcal{A}$;
        \item $\mathcal{C}$ обирає $b \xleftarrow{p} \{0,1\}$. Якщо обрано $b = 0$, то обчислює
            $(c, K_0) \gets \mathsf{Encaps}(\mathsf{pk})$; а якщо $b = 1$, обчислює
            $(c, K_0) \gets \mathsf{Encaps}(\mathsf{pk})$ та $K_1 \xleftarrow{p} \mathcal{K}$.
            Опісля передає пару $(c, K_b)$ супротивнику;
        \item $\mathcal{A}$ виводить біт $b'$.
    \end{enumerate}
    Перевага cупротивника $\mathsf{Adv}^{\text{IND-CPA}}_{\mathsf{KEM}}(\mathcal{A})$ визначається аналогічно як і в PKE.
\end{definition}

Безпека KEM тісно пов'язана з:
\begin{itemize}
    \item IND-CPA безпекою базової PKE схеми;
    \item Ймовірністю помилки розшифрування $\varepsilon$;
    \item Параметрами випадкових оракулів (про трохи далі).
\end{itemize}

Важливим є те, що навіть за наявності помилок розшифрування (що неминуче для схем на решітках), можна довести
IND-CCA безпеку за умови достатньо малого $\varepsilon(\lambda)$.

\subsection{IND-CCA безпека}
\label{subsec:3-5-2}

\begin{definition}[IND-CCA для PKE]
    \label{def:3-5-3}
    ~\par "Гра"{} IND-CCA відрізняється від IND-CPA тим, що противник $\mathcal{A}$ має додатково доступ до оракула
    дешифратора (decryption oracle) $\mathsf{Dec}(\mathsf{sk}, \cdot)$:
    \begin{enumerate}
        \item $\mathcal{C}$ генерує $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ і передає
            $\mathsf{pk}$ супротивнику $\mathcal{A}$;
        \item $\mathcal{A}$ робить запити до оракула дешифрування, подаючи на вхід довільні шифротексти $c_i$ і
            отримувати $m_i = \mathsf{Dec}(\mathsf{sk}, c_i)$;
        \item $\mathcal{A}$ обирає $m_0, m_1$ і отримує challenge шифротекст
            $c^{*} \gets \mathsf{Enc}(\mathsf{pk}, m_b)$ для випадкового $b$;
        \item $\mathcal{A}$ продовжує робити запити до оракула дешифрування, але не може запитувати $c^{*}$ -- випадок
            \textbf{IND-CCA2} (а якщо запити заборонені вже після отримання $c^{*}$ -- це \textbf{IND-CCA1});
        \item $\mathcal{A}$ виводить біт $b'$.
    \end{enumerate}
    Перевага $\mathsf{Adv}^{\text{IND-CCA}}_{\mathsf{PKE}}(\mathcal{A})$ визначається аналогічно.
\end{definition}

\begin{definition}[IND-CCA безпека для KEM]
    \label{def:3-5-4}
    ~\par Для KEM схеми противник має доступ до оракула декапсуляції $\mathsf{Decaps}(\mathsf{sk}, \cdot)$ і
    \textbf{не може} запитувати challenge шифротекст $c^*$ після його отримання.
\end{definition}

IND-CCA (Indistinguishability under Chosen Ciphertext Attack) безпека є значно сильнішою, ніж IND-CPA, оскільки
моделює активного противника, який може маніпулювати шифротекстами та спостерігати результати дешифрування. Для
практичних застосувань зазвичай потрібна IND-CCA2 безпека.

\subsection{Ймовірність помилки розшифрування (DFP/R)}
\label{subsec:3-5-3}

\begin{definition}[Decryption Failure Probability/Rate]
    \label{def:3-5-5}
    ~\par Для PKE схеми ймовірність помилки розшифрування (DFP/R) визначається як:
    \begin{equation*}
        \delta = \max_{m \in \mathcal{M}} \mathbb{P}_{(\mathsf{pk},\mathsf{sk}),r}
        [\mathsf{Dec}(\mathsf{sk}, \mathsf{Enc}(\mathsf{pk}, m; r)) \neq m],
    \end{equation*}
    де ймовірність береться за випадковістю генерації ключів та шифрування.

    Для KEM схеми:
    \begin{equation*}
        \delta = \mathbb{P}_{(\mathsf{pk},\mathsf{sk}),(c,K)}[\mathsf{Decaps}(\mathsf{sk}, c) \neq K].
    \end{equation*}
\end{definition}

У решіткових схемах помилки розшифрування виникають природнім шляхом (наявність шуму у RLWE/RLWR), тому параметри
схеми (розміри модулів, розподіл помилок, коефіцієнт стиснення) мають бути підібрані так, щоб забезпечити мале $\delta$.

\noindent (!) Висока ймовірність помилки розшифрування може призвести до наступних атак:
\begin{itemize}
    \item \textbf{Failure boosting attacks~\cite{dhooghe2018}:} Супротивник може ітеративно створювати шифротексти,
        що мають високу ймовірність помилки, щоб витягувати поступово інформацію про секретний ключ;
    \item \textbf{Multi-target attacks~\cite{danvers2022}:} При наяності багатьох публічних ключів або сесій,
        навіть відносно мала DFP/R може стати проблемою.
\end{itemize}

\noindent Для реалізацій TiGER цільова DFP/R становить:
\begin{itemize}
    \item TiGER128: $\delta \approx 2^{-120}$;
    \item TiGER192: $\delta \approx 2^{-136}$;
    \item TiGER256: $\delta \approx 2^{-167}$.
\end{itemize}
P.S. Ці значення вважаються достатньо малими для практичного застосування.

\subsection{Квантова безпека a.k.a. QROM}
\label{subsec:3-5-4}

\begin{definition}[Quantum Random Oracle Model]
    \label{def:3-5-6}
    ~\par Модель квантового випадкового оракула (скорочено QROM) -- це розширення класичної моделі випадкового
    оракула (ROM), де противник має квантовий доступ до геш-функцій, тобто може ще робити запити у суперпозиції.
\end{definition}

\noindent Для TiGER необхідно, щоб перетворення Fujisaki-Okamoto забезпечувало IND-CCA безпеку у QROM, це гарантуватиме
стійкість проти квантових атак.

\section{Перетворення Fujisaki-Okamoto}
\label{sec:3-6}

Перетворення Fujisaki-Okamoto (скорочено FO)~\cite{fo1999,fo2013} є загальним методом перетворення IND-CPA безпечної
PKE схеми у IND-CCA безпечну KEM схему. В цьому підпункті наведемо просте класичне FO перетворення та його модифікацію --
варіант з неявним відхиленням, що використовується в TiGER.

\subsection{Класичне перетворення FO}
\label{subsec:3-6-1}

\begin{theorem}[Fujisaki-Okamoto]
    \label{theorem:3-6-1}
    ~\par Нехай $\mathsf{PKE} = (\mathsf{KeyGen}, \mathsf{Enc}, \mathsf{Dec})$ -- IND-CPA безпечна PKE схема з
    однозначним детермінованим розшифруванням. Нехай $G: \mathcal{M} \to \mathcal{R} \times \mathcal{K}$ та
    $H: \mathcal{M} \times \mathcal{C} \to \mathcal{K}$ -- випадкові оракули. Тоді наступна конструкція є
    IND-CCA безпечною KEM у моделі випадкового оракула~\cite{fo1999}:
    \begin{algorithm}[H]
        \caption{KeyGen()}
        \begin{algorithmic}[1]
            \State Generate $(pk, sk) \gets $ PKE.KeyGen$(1^\lambda)$
            \State \Return $(pk, sk)$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Encaps$(pk)$}
        \begin{algorithmic}[1]
            \State Choose $m \xleftarrow{p} \mathcal{M}$
            \State Calculate $(r, K) \gets G(m)$
            \State Calculate $c \gets$ PKE.Enc$(pk, m; r)$
            \State \Return $(c, K)$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Decaps$(sk, c)$}
        \begin{algorithmic}[1]
            \State Calculate $m' \gets$ PKE.Dec$(sk, c)$
            \State Calculate $(r', K') \gets G(m')$
            \State Calculate $c' \gets$ PKE.Enc$(pk, m'; r')$
            \If{$c = c'$}
            \State \Return $K'$
            \Else
            \State \Return $\bot$
            \EndIf
        \end{algorithmic}
    \end{algorithm}
\end{theorem}

\noindent \textbf{Ключова ідея перетворення FO} полягає у \textbf{\textit{повторному шифруванні}} (re-encryption):
після розшифрування повідомлення $m'$ воно повторно шифрується з тією ж випадковістю, і результат порівнюється з
отриманим шифротекстом. Це дозволяє виявити модифікації шифротексту.

\subsection{Перетворення \texorpdfstring{$\mathsf{FO}^{\not\bot}_m$}{FO} з неявним відхиленням}
\label{subsec:3-6-2}

Для схем на решітках з ненульовою ймовірністю помилки розшифрування було розроблено модифікацію -- варіант FO з
\textit{неявним відхиленням} (implicit rejection)~\cite{hofheinz2017}.

\begin{definition}[Перетворення $\mathsf{FO}^{\not\bot}_m$]
    \label{def:3-6-1}
    ~\par Нехай $\mathsf{PKE}$ -- IND-CPA безпечна PKE схема. Конструкція $\mathsf{FO}^{\not\bot}_m$ відрізняється
    від класичного FO у додатковій декапсуляції:

    \begin{algorithm}[H]
        \caption{KeyGen()}
        \begin{algorithmic}[1]
            \State Generate $(pk, sk') \gets$ PKE.KeyGen$(1^\lambda)$
            \State Choose $z \xleftarrow{p} \mathcal{Z}$ \Comment{Додатковий випадковий ключ}
            \State \Return $(pk, sk = (sk', z))$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Encaps$(pk)$}
        \begin{algorithmic}[1]
            \State Choose $m \xleftarrow{p} \mathcal{M}$
            \State Calculate $r \gets G(m, pk)$
            \State Calculate $c \gets$ PKE.Enc$(pk, m; r)$
            \State Calculate $K \gets H(m, c)$
            \State \Return $(c, K)$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Decaps$(sk, c)$}
        \begin{algorithmic}[1]
            \State Split $sk = (sk', z)$
            \State Calculate $m' \gets$ PKE.Dec$(sk', c)$
            \State Calculate $r' \gets G(m', pk)$
            \State Calculate $c' \gets$ PKE.Enc$(pk, m'; r')$
            \If{$c = c'$}
            \State \Return $K' \gets H(m', c)$
            \Else
            \State \Return $\overline{K} \gets H(z, c)$ \Comment{Неявне відхилення}
            \EndIf
        \end{algorithmic}
    \end{algorithm}
\end{definition}

\noindent \textbf{Ключова відмінність:} замість повернення $\bot$ при невдалій перевірці, алгоритм повертає
псевдовипадковий ключ $\overline{K} = H(z, c)$, де $z$ -- секретний випадковий ключ. Це має дві переваги:
\begin{itemize}
    \item \textbf{Захист від side-channel атак:} Оскільки зовнішньому спостерігачу стає важче визначити, чи
        відбулася помилка при декапсуляції;
    \item \textbf{Постійний час виконання:} Обидва варіанти (успіх/невдача) тепер виконують однакові операції гешування.
\end{itemize}

\subsection{Застосування у алгоритмі TiGER}
\label{subsec:3-6-4}

TiGER.KEM побудовано із застосуванням варіанту перетворення $\mathsf{FO}^{\not\bot}_m$ до TiGER.PKE:

\begin{itemize}
    \item \textbf{TiGER.PKE:} Базується на RLWR (для відкритого ключа) та RLWE (для шифрування), забезпечує
        IND-CPA безпеку;
    \item \textbf{Геш-функції:} Використовуються $G = H = \mathsf{SHAKE256}$ (функція з розширеним виходом)
        для генерації випадковості та спільних ключів;
    \item \textbf{Додаткове гешування:} Відкритий ключ $\mathsf{pk}$ гешується разом з повідомленням:
        $r \gets G(m, H(\mathsf{pk}))$, що забезпечує захист від multi-target атак;
    \item \textbf{Неявне відхилення:} При невдалій декапсуляції повертається $\overline{K} = H(z, c)$, що захищає від
        витоку інформації про помилки та розкритті хоч і мізерної, та інформації, про ключ.
\end{itemize}

\chapter{\large{Повний опис алгоритму TiGER}}
\label{chapter:4}

\section{Загальна структура алгоритму}
\label{sec:4-1}

TiGER має модульну архітектуру, що складається з двох рівнів: базової схеми шифрування з відкритим ключем
(TiGER.PKE) та механізму інкапсуляції ключа (TiGER.KEM), отриманого застосуванням перетворення Fujisaki-Okamoto
до PKE схеми.

\subsection{Модульна побудова алгоритму}
\label{subsec:4-1-1}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[node distance=2cm, >=stealth, thick]
        % Nodes
        \node[draw, rectangle, minimum width=3cm, minimum height=1cm] (pke) {TiGER.PKE};
        \node[draw, rectangle, minimum width=3cm, minimum height=1cm, below=of pke] (fo) {Перетворення FO$^{\not\bot}_m$};
        \node[draw, rectangle, minimum width=3cm, minimum height=1cm, below=of fo] (kem) {TiGER.KEM};

        % Arrows
        \draw[->] (pke) -- (fo) node[midway, right] {IND-CPA};
        \draw[->] (fo) -- (kem) node[midway, right] {IND-CCA};

        % Side labels
        \node[left=2cm of pke] (rlwe) {RLWE/RLWR};
        \draw[->] (rlwe) -- (pke);

        \node[right=2cm of fo] (hash) {Hash функції};
        \draw[->] (hash) -- (fo);
    \end{tikzpicture}
    \caption{Модульна структура TiGER}
    \label{fig:4-1-1}
\end{figure}

Конструкція TiGER базується на трьох наступних принципах:

\begin{enumerate}
    \item \textbf{Перший крок -- TiGER.PKE:} Схема шифрування з відкритим ключем, що використовує комбінацію RLWR
        для генерації відкритого ключа та RLWE для шифрування повідомлень. На припущення складності RLWE та RLWR
        задач маємо IND-CPA безпеку.
    \item \textbf{Перетворення FO$^{\not\bot}_m$:} Варіант перетворення Fujisaki-Okamoto з неявним відхиленням, що
        перетворює IND-CPA безпечну PKE схему в IND-CCA безпечну KEM схему використовує геш-функції SHAKE256 та
        SHA3-256 як випадкові оракули $H: \mathcal{M} \times \mathcal{C} \to \mathcal{K}$.
    \item \textbf{Вихід -- TiGER.KEM:} Повний механізм інкапсуляції ключа з IND-CCA безпекою у моделі
        квантового випадкового оракула (QROM), придатний для практичного використання у постквантових протоколах.
\end{enumerate}

\subsection{Взаємодія між компонентами TiGER}
\label{subsec:4-1-2}

Взаємодія між компонентами відбувається наступним чином:

\textbf{Генерація ключів:}
\begin{itemize}
    \item TiGER.PKE генерує пару $(\mathsf{pk}, \mathsf{sk}')$ використовуючи RLWR;
    \item TiGER.KEM додає випадковий ключ $z$ до секретного ключа: $\mathsf{sk} = (\mathsf{sk}', z)$;
    \item Відкритий ключ $\mathsf{pk}$ гешується для захисту від multi-target атак.
\end{itemize}

\textbf{Інкапсуляція:}
\begin{itemize}
    \item Генерується випадкове повідомлення $m$;
    \item геш-функція $G$ обчислює детерміновану випадковість $r$ з $m$ та гешу $\mathsf{pk}$;
    \item TiGER.PKE шифрує $m$ з випадковістю $r$ і видає шифротекст $c$;
    \item Спільний ключ $K$ обчислюється як $H(m, c)$.
\end{itemize}

\textbf{Декапсуляція:}
\begin{itemize}
    \item TiGER.PKE розшифровує шифротекст $c$ та повертає повідомлення $m'$;
    \item Виконується повторне шифрування (re-encryption) $m'$ для перевірки цілісності;
    \item Якщо перевірка успішна, повертається $K' = H(m', c)$;
    \item Якщо перевірка невдала, повертається псевдовипадковий ключ $\overline{K} = H(z, c)$ (неявне відхилення).
\end{itemize}

\section{Публічні параметри}
\label{sec:4-2}

TiGER визначає три набори параметрів, що відповідають трьом рівням безпеки згідно з класифікацією NIST: 
TiGER128 (рівень 1), TiGER192 (рівень 3) та TiGER256 (рівень 5). Розглянемо детальніше значення кожного 
параметра та обґрунтування їх вибору.

\newpage % FORCED
\begin{table}[ht]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Параметр}                & \textbf{TiGER128} & \textbf{TiGER192} & \textbf{TiGER256} \\
        \hline
        \hline
        $n$                              & 512               & 1024              & 1024              \\
        \hline
        $q$                              & $2^{14}$          & $2^{15}$          & $2^{16}$          \\
        \hline
        $p$                              & $2^{10}$          & $2^{11}$          & $2^{11}$          \\
        \hline
        $k_1$ (бітів для $\mathbf{b}$)   & 10                & 11                & 11                \\
        \hline
        $k_2$ (бітів для $\mathbf{c}_1$) & 4                 & 4                 & 5                 \\
        \hline
        $h_s$                            & 274               & 284               & 274               \\
        \hline
        $h_r$                            & 274               & 284               & 274               \\
        \hline
        $h_e$                            & 274               & 284               & 274               \\
        \hline
        $d$ (для XEf)                    & 8                 & 8                 & 9                 \\
        \hline
        $f$ (для D2)                     & 2                 & 2                 & 2                 \\
        \hline
        \hline
        $|\mathsf{pk}|$ (кількість байт) & 804               & 1568              & 1568              \\
        \hline
        $|\mathsf{sk}|$ (кількість байт) & 1876              & 3680              & 3680              \\
        \hline
        $|\mathsf{ct}|$ (кількість байт) & 804               & 1408              & 1600              \\
        \hline
        Рівень безпеки NIST              & 1                 & 3                 & 5                 \\
        \hline
        Класична безпека (кількість біт) & 143               & 207               & 272               \\
        \hline
        Квантова безпека (кількість біт) & 128               & 192               & 256               \\
        \hline
        DFP                              & $2^{-120}$        & $2^{-136}$        & $2^{-167}$        \\
        \hline
    \end{tabular}
    \caption{Параметри TiGER для різних рівнів безпеки}
    \label{table:4-2-1}
\end{table}

\textbf{Структурні параметри:}
\begin{itemize}
    \item \textbf{$n$} --- степінь многочлена, що визначає розмірність поліноміального кільця $R = \mathbb{Z}[x]/(x^n + 1)$. 
        Більше $n$ забезпечує вищу безпеку, але і водночас збільшує обчислювальну складність та розміри ключів;
    \item \textbf{$q$} --- основний модуль, що визначає кільце $R_{q} = R/qR$. В даному алгоритмі обрано як степінь 
        двійки для оптимізації операцій модульної арифметики.
    \item \textbf{$p$} --- модуль для RLWR округлення при генерації відкритого ключа. Задовольняє $p < q$ та 
        також є степенем двійки. Відношення $q/p$ визначає рівень "шуму"{} від округлення.
\end{itemize}

\textbf{Параметри для стиснення:}
\begin{itemize}
    \item \textbf{$k_{1}$} --- кількість біт для представлення компонент вектора $\mathbf{b}$ у відкритому ключі. 
        Стиснення з $\log_{2} q$ до $k_{1}$ біт зменшує розмір відкритого ключа;
    \item \textbf{$k_{2}$} --- кількість біт для представлення першої частини шифротексту $\mathbf{c}_1$. 
        Агресивніша компресія зменшує розмір шифротексту, але збільшує ймовірність помилки розшифрування(!).
\end{itemize}

\textbf{Параметри розподілів помилок:}
\begin{itemize}
    \item \textbf{$h_s$} --- вага Геммінга (Hamming weight) секретного ключа $\mathbf{s}$. TiGER використовує 
        розріджені тернарні многочлени з коефіцієнтами $\{-1, 0, 1\}$, де рівно $h_s$ коефіцієнтів є ненульовими;
    \item \textbf{$h_r$} --- вага Геммінга помилки $\mathbf{r}$ при генерації відкритого ключа (RLWR);
    \item \textbf{$h_e$} --- вага Геммінга для помилок $\mathbf{e}_1, \mathbf{e}_2$ при шифруванні (RLWE).
\end{itemize}

\textbf{Параметри кодів корекції помилок:}
\begin{itemize}
    \item \textbf{$d$} --- параметр коду XEf (extended XOR-based error correction). Визначає кількість біт 
        повідомлення, які кодуються разом. Чим більше $d$, тим краща корекція помилок, але при цьому збільшуються 
        обчислення;
    \item \textbf{$f$} --- параметр коду D2 (duplication code). Визначає частоту дублювання бітів повідомлення для 
        додаткового захисту від помилок DFP/R.
\end{itemize}

\noindent Фактичні бітові розміри криптографічних об'єктів обчислюються наступним чином:

\textbf{Відкритий ключ} $\mathsf{pk} = (\rho, \mathbf{b})$:
\begin{equation*}
    |\mathsf{pk}| = 32 + n \cdot k_1 / 8 \text{ байт},
\end{equation*}
де 32 байти -- розмір seed $\rho$, який використовується для генерації випадкового многочлена 
$\mathbf{a} \in R_q$. Замість зберігання повного многочлена $\mathbf{a}$ (що займало б $n \log_2 q$ біт) пам'яті, 
зберігається лише seed, з якого $\mathbf{a}$ відновлюється за потреби. Компонента $\mathbf{b}$ -- це результат 
RLWR обчислення $\mathbf{b} = \lfloor \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \rfloor_p$, стиснута до $k_{1}$ 
біта на кожен коефіцієнт.

\textbf{Секретний ключ} $\mathsf{sk} = (\mathsf{sk}', z, h, \mathsf{pk})$:
\begin{equation*}
    |\mathsf{sk}| = |\mathsf{sk}'| + 32 + 32 + |\mathsf{pk}| \text{ байт},
\end{equation*}
де $\mathsf{sk}'$ -- зжате представлення розрідженого секретного ключа $\mathbf{s}$, $z$ та $h$ --- 32-байтові 
значення для FO перетворення.

\textbf{Шифротекст} $\mathsf{ct} = (\mathbf{c}_1, \mathbf{c}_2)$:
\begin{equation*}
    |\mathsf{ct}| = n \cdot k_2 / 8 + n / 8 \text{ байт}.
\end{equation*}

Параметри TiGER були підібрані розробниками з урахуванням наступних критеріїв:

\begin{enumerate}
    \item \textbf{Безпека:} Забезпечують стійкість до відомих атак на RLWE/RLWR, включаючи атаки з використанням 
        решіткових алгоритмів (BKZ, LatticeSieve) на класичних та квантових комп'ютерах. Запас безпеки становить 
        10-15 біт понад нормово;
    \item \textbf{Коректність:} Ймовірність помилки розшифрування (DFP/R) не перевищує $2^{-120}$ для всіх наборів 
        параметрів, що є достатнім для практичного використання;
    \item \textbf{Ефективність:} Вибір степенів двійки для модулів дозволяє використовувати швидкі побітові 
        операції, а розріджені секрети прискорюють множення многочленів;
    \item \textbf{Компактність:} Параметри компресії ($k_1, k_2$) обрані так, щоб мінімізувати розміри при 
        збереженні прийнятного рівня DFP/R. Коди корекції помилок дозволяють застосовувати агресивнішу компресію 
        без погіршення коректності.
\end{enumerate}

\section{Допоміжні алгоритми}
\label{sec:4-3}

TiGER використовує набір допоміжних алгоритмів для генерації випадкових величин, розширення seed-значень та 
корекції помилок.

\begin{enumerate}
    \item \textbf{Алгоритм $\mathsf{HWT}_h$} відповідає за генерацію розрідженого тернарного многочлена з 
        фіксованою вагою Геммінга.
        \begin{algorithm}[H]
            \caption{$\mathsf{HWT}_h$}
            \begin{algorithmic}[1]
                \State Input: Seed $\sigma \in \{0,1\}^{256}$, weight $h \leq n$.
                \State Output: Поліном $\mathbf{s} \in R$ з коефіцієнтами $\{-1, 0, 1\}$ та рівно $h$ ненульовими коефіцієнтами.
            \end{algorithmic}
        \end{algorithm}
        Алгоритм використовує SHAKE256 для генерації послідовності випадкових індексів та знаків. Спочатку обираються 
        $h$ різних позицій в діапазоні $[0, n-1]$, потім для кожної позиції генерується випадковий знак $\pm 1$. 
        Використовується метод rejection sampling для забезпечення рівномірного розподілу індексів. Виконується 
        за константний час (з точністю до rejection sampling).
    \item \textbf{Алгоритм $\mathsf{expandA}$} --- генерація псевдовипадкового многочлена $\mathbf{a}$ з seed.
        \begin{algorithm}[H]
            \caption{$\mathsf{HWT}_h$}
            \begin{algorithmic}[1]
                \State Input: Seed $\rho \in \{0,1\}^{256}$.
                \State Output: Многочлен $\mathbf{a} \in R_q$ з рівномірно розподіленими коефіцієнтами.
            \end{algorithmic}
        \end{algorithm}
        Тут також використовується SHAKE256 як додаткова псевдовипадковость (PRG). Seed $\rho$ розширюється до 
        послідовності байтів, які інтерпретуються як коефіцієнти многочлена в $\mathbb{Z}_q$. Застосовується 
        rejection sampling для забезпечення рівномірності: якщо згенероване значення $\geq q$, воно відкидається і 
        генерується нове. Многочлен $\mathbf{a}$ використовується у RLWR для обчислення відкритого ключа: 
        $\mathbf{b}$ та у RLWE при шифруванні.

        Цей підхід дозволяє зберігати у відкритому ключі лише 32 байти seed замість повного многочлена, що займав 
        би $n \log_2 q$ біт --- для TiGER256 це 1024 × 16 = 16384 біт = 2048 байт). 
        Обидві сторони (відправник і отримувач) можуть незалежно відновити $\mathbf{a}$ з $\rho$.
    \item \textbf{Алгоритми корекції помилок $\mathsf{eccENC}$ та $\mathsf{eccDEC}$} --- кодування та декодування 
        повідомлення для зниження DFP/R.
        \begin{itemize}
            \item Код XEf (XOR-based error correction with extension): Повідомлення розбивається на блоки по $d$ 
                біт. Для кожного блоку обчислюється біт парності як ксор (XOR) усіх біт блоку та додається до 
                закодованого повідомлення. Це дозволяє виявити та виправити одиночні помилки в кожному блоці. При 
                декодуванні для кожного блоку перевіряється цей біт парності. Якщо він не збігається, алгоритм 
                намагається виправити помилку перебором всіх $d$ позицій у блоці.
                \item Код D2 (Duplication code): Додатковий рівень захисту, що дублює кожен біт повідомлення $f$ 
                разів. При декодуванні використовується мажоритарне голосування (majority voting): якщо більшість 
                копій біта мають значення 1, результат буде 1, інакше -- 0.
        \end{itemize}
        TiGER застосовує спочатку код XEf, потім код D2, що дає двоетапну систему корекції помилок. Це дозволяє 
        використовувати агресивнішу компресію шифротексту при збереженні низької DFP/R.
    \item \textbf{Геш-функції} --- використовуються для генерації випадковостей та обчислення спільних ключів у перетворенні FO.
        \begin{itemize}
            \item \textit{SHAKE256:} Функція з розширеним виходом (XOF) зі стандарту SHA-3. Використовується першочергово 
                як генератор псевдовипадковості (PRG) у $\mathsf{expandA}$ та $\mathsf{HWT}_h$, функція $G$ у перетворенні 
                FO для отримання детермінованої випадковості з повідомлення та для генерації довгих послідовностей 
                псевдовипадкових байтів.
            \item \textit{SHA3-256:} Криптографічна геш-функція зі стандарту SHA-3. Використовується як функція 
                $H$ у перетворенні Fujisaki-Okamoto для обчислення спільного ключа $K = H(m, c)$, гешуванні відкритого 
                ключа для захисту від multi-target атак та для генерації фінального спільного ключа фіксованого 
                розміру (256 біт).
        \end{itemize}
        Обидві ці функції є частиною стандарту FIPS 202 (2015 р) та мають формальний аналіз безпеки. У моделі 
        квантового випадкового оракула (QROM) вони моделюються як ідеальні випадкові функції та доступними супротивнику.
\end{enumerate}

\section{TiGER.PKE}
\label{sec:4-4}

TiGER.PKE це базова схема шифрування з відкритим ключем, що забезпечує IND-CPA безпеку. Схема використовує 
комбінацію RLWR для генерації відкритого ключа та RLWE для шифрування повідомлень.

\subsection{KeyGen -- генерація ключів}
\label{subsec:4-4-1}

Алгоритм генерації ключів створює пару відкритий\&секретний ключ на основі RLWR.

\begin{algorithm}[H]
    \caption{TiGER.PKE.KeyGen()}
    \label{alg:4-4-1}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Параметри $(n, q, p, h_s, h_r, k_1)$
        \State \textbf{Output:} Відкритий ключ $pk$, секретний ключ $sk$
        \State
        \State Generate seed $\rho \xleftarrow{p} \{0,1\}^{256}$
        \State Generate seed $\sigma_s \xleftarrow{p} \{0,1\}^{256}$
        \State Generate seed $\sigma_r \xleftarrow{p} \{0,1\}^{256}$
        \State
        \State $\mathbf{a} \gets \mathsf{expandA}(\rho)$ \Comment{Expand seed в многочлен}
        \State $\mathbf{s} \gets \mathsf{HWT}_{h_s}(\sigma_s)$ \Comment{Sparse секретний ключ}
        \State $\mathbf{r} \gets \mathsf{HWT}_{h_r}(\sigma_r)$ \Comment{Sparse error}
        \State
        \State $\mathbf{b}' \gets \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \in R_q$ \Comment{RLWR обчислення}
        \State $\mathbf{b}' \gets \lfloor \mathbf{b}' \cdot (p/q) \rceil \in R_p$ \Comment{Округлення за$\mod p$}
        \State $\mathbf{b} \gets \mathsf{Compress}(\mathbf{b}', k_1)$ \Comment{Компресія до $k_1$ біт}
        \State
        \State $pk \gets (\rho, \mathbf{b})$
        \State $sk \gets \sigma_s$ \Comment{Save secret seed(!)}
        \State \Return $(pk, sk)$
    \end{algorithmic}
\end{algorithm}

Кроки алгоритму (якщо словами):

\begin{enumerate}
    \item \textbf{Генерація seeds:} Спершу створюються три незалежні 256-бітні seeds:
        \begin{itemize}
            \item $\rho$ --- для генерації публічного многочлена $\mathbf{a}$;
            \item $\sigma_s$ --- для генерації секретного ключа $\mathbf{s}$;
            \item $\sigma_r$ --- для генерації помилки $\mathbf{r}$.
        \end{itemize}
    \item \textbf{Expand $\mathbf{a}$:} Використовується алгоритм $\mathsf{expandA}$ для детермінованої генерації 
        рівномірно випадкового многочлена $\mathbf{a} \in R_q$ з seed $\rho$.
    \item \textbf{Генерація розріджених многочленів:}
        \begin{itemize}
            \item Секретний ключ $\mathbf{s}$ генерується як тернарний многочлен з вагою Геммінга $h_s$;
            \item Помилка $\mathbf{r}$ аналогічно генерується з вагою $h_r$.
        \end{itemize}
    \item \textbf{RLWR:} Обчислюється $\mathbf{b}' = \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \in R_q$, після чого 
        виконується округлення до найближчого цілого модуля $p$: $\lfloor \mathbf{b}' \cdot (p/q) \rceil$. Операція 
        округлення вводить детермінований "шум"{}, що замінює явну помилку в класичному RLWE.
    \item \textbf{Компресія:} Многочлен $\mathbf{b}'$ стискається з $\log_{2} p$ біт до $k_{1}$ біт на коефіцієнт 
        для зменшення розміру відкритого ключа.
    \item \textbf{Формування ключів:} Відкритий ключ містить seed $\rho$ та стиснений $\mathbf{b}'$, а секретний 
        ключ зберігається у вигляді seed $\sigma_s$, з якого можна відновити $\mathbf{s}$ за потреби.
\end{enumerate}

\subsection{Encryption -- шифрування}
\label{subsec:4-4-2}

Алгоритм шифрування перетворює повідомлення в шифротекст використовуючи RLWE.

\begin{algorithm}[H]
    \caption{TiGER.PKE.Enc$(pk, m; r)$}
    \label{alg:4-4-2}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Відкритий ключ $pk = (\rho, \mathbf{b})$, повідомлення $m \in \{0,1\}^{256}$, 
            випадковість $r$
        \State \textbf{Output:} Шифротекст $ct = (\mathbf{c}_1, \mathbf{c}_2)$
        \State
        \State Parse seeds from $r$: $(\sigma_{e_1}, \sigma_{e_2}) \gets r$
        \State
        \State $\mathbf{a} \gets \mathsf{expandA}(\rho)$ \Comment{Відновлення $\mathbf{a}$ з seed}
        \State $\mathbf{b}' \gets \mathsf{Decompress}(\mathbf{b}, k_1)$ \Comment{Декомпресія відкритого ключа}
        \State
        \State $\mathbf{e}_1 \gets \mathsf{HWT}_{h_e}(\sigma_{e_1})$ \Comment{Генерація "помилок"{}}
        \State $\mathbf{e}_2 \gets \mathsf{HWT}_{h_e}(\sigma_{e_2})$
        \State
        \State $m' \gets \mathsf{eccENC}(m)$ \Comment{Кодування з корекцією помилок}
        \State $\mathbf{m} \gets \mathsf{Encode}(m')$ \Comment{Перетворення біт в многочлен}
        \State
        \State $\mathbf{c}_1' \gets \mathbf{a} \cdot \mathbf{e}_1 + \mathbf{e}_2 \in R_q$ \Comment{RLWE компонента}
        \State $\mathbf{c}_1 \gets \mathsf{Compress}(\mathbf{c}_1', k_2)$ \Comment{Агресивна компресія}
        \State
        \State $\mathbf{c}_2' \gets \mathbf{b}' \cdot \mathbf{e}_1 + \mathbf{m} \cdot \lfloor q/2 \rfloor \in R_q$ \Comment{Повідомлення + шум}
        \State $\mathbf{c}_2 \gets \mathsf{Compress}(\mathbf{c}_2', 1)$ \Comment{Компресія до 1 біт}
        \State
        \State \Return $ct = (\mathbf{c}_1, \mathbf{c}_2)$
    \end{algorithmic}
\end{algorithm}

Кроки алгоритму:

\begin{enumerate}
    \item \textbf{Парсинг випадковості:} З детермінованої випадковості $r$ (згенерованої через геш-функцію $G$ 
        у FO) отримуємо seeds для генерації помилок $\mathbf{e}_1, \mathbf{e}_2$.
    \item \textbf{Відновлення відкритого ключа:}
        \begin{itemize}
            \item Многочлен $\mathbf{a}$ відновлюється з $\rho$ seed;
            \item Компресований $\mathbf{b}$ декомпресується до $\mathbf{b}' \in R_p$.
        \end{itemize}
    \item \textbf{Генерація "помилок"{}:} Створюються два розріджених тернарних многочлена $\mathbf{e}_1, \mathbf{e}_2$ 
        з вагою Геммінга $h_e$ кожен.
    \item \textbf{Підготовка повідомлення:}
    \begin{itemize}
        \item Повідомлення $m$ кодується через $\mathsf{eccENC}$ (коди XEf та D2) для захисту від помилок;
        \item Закодоване повідомлення перетворюється в многочлен $\mathbf{m} \in R$ з коефіцієнтами з $\{0,1\}$;
        \item Множиться на $\lfloor q/2 \rfloor$ для розміщення в "середині"{} модуля $q$.
    \end{itemize}
    \item \textbf{RLWE шифрування:}
    \begin{itemize}
        \item $\mathbf{c}_1' = \mathbf{a} \cdot \mathbf{e}_1 + \mathbf{e}_2$ --- "маскування"{} помилки $\mathbf{e}_1$;
        \item $\mathbf{c}_2' = \mathbf{b}' \cdot \mathbf{e}_1 + \mathbf{m} \cdot \lfloor q/2 \rfloor$ --- зашифроване повідомлення.
    \end{itemize}
    \item \textbf{Компресія шифротексту:}
    \begin{itemize}
        \item $\mathbf{c}_1$ стискається до $k_2$ біт на коефіцієнт (агресивна компресія);
        \item $\mathbf{c}_2$ стискається до 1 біт на коефіцієнт (зберігається лише знак).
    \end{itemize}
\end{enumerate}

\subsection{Decryption -- розшифрування}
\label{subsec:4-4-3}

Алгоритм розшифрування відновлює повідомлення з шифротексту використовуючи секретний ключ.

\begin{algorithm}[H]
    \caption{TiGER.PKE.Dec$(sk, ct)$}
    \label{alg:4-4-3}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Секретний ключ $sk = \sigma_s$, шифротекст $ct = (\mathbf{c}_1, \mathbf{c}_2)$
        \State \textbf{Output:} Повідомлення $m \in \{0,1\}^{256}$ або $\bot$
        \State
        \State $\mathbf{s} \gets \mathsf{HWT}_{h_s}(\sigma_s)$ \Comment{Відновлення sk з seed}
        \State
        \State $\mathbf{c}_1' \gets \mathsf{Decompress}(\mathbf{c}_1, k_2)$ \Comment{Декомпресія шифротексту}
        \State $\mathbf{c}_2' \gets \mathsf{Decompress}(\mathbf{c}_2, 1)$
        \State
        \State $\mathbf{v} \gets \mathbf{c}_2' - \mathbf{c}_1' \cdot \mathbf{s} \in R_q$ \Comment{Видалення маски}
        \State
        \State $\mathbf{m}' \gets \mathsf{Round}(\mathbf{v})$ \Comment{Округлення до \{0,1\}}
        \State $m' \gets \mathsf{Decode}(\mathbf{m}')$ \Comment{Розбиття многочлена на біти}
        \State
        \State $m \gets \mathsf{eccDEC}(m')$ \Comment{Декодування з корекцією помилок}
        \State
        \If{$m = \bot$}
            \State \Return $\bot$ \Comment{Помилка розшифрування}
        \Else
            \State \Return $m$
        \EndIf
    \end{algorithmic}
\end{algorithm}

Покроково маємо:

\begin{enumerate}
    \item \textbf{Відновлення секретного ключа:} З seed $\sigma_s$ відновлюється розріджений многочлен $\mathbf{s}$.
    \item \textbf{Декомпресія шифротексту:} Обидві компоненти $\mathbf{c}_1, \mathbf{c}_2$ декомпресуються до повного 
        розміру в $R_q$.
    \item \textbf{Видалення маски:} Обчислюється $\mathbf{v} = \mathbf{c}_2' - \mathbf{c}_1' \cdot \mathbf{s}$, 
        що має бути близьким до $\mathbf{m} \cdot \lfloor q/2 \rfloor$ (за наявності малої помилки).
    \item \textbf{Округлення:} Функція $\mathsf{Round}$ округлює кожен коефіцієнт $\mathbf{v}$ до найближчого з чисел: 
        $0$ або $\lfloor q/2 \rfloor$, потім нормалізує до $\{0,1\}$:
    \begin{equation*}
        \mathsf{Round}(v_i) = 
        \begin{cases}
            0, & \text{якщо } |v_i| < q/4 \\
            1, & \text{якщо } |v_i - \lfloor q/2 \rfloor| < q/4 \\
            \text{error}, & \text{інакше}
        \end{cases}
    \end{equation*}
    \item \textbf{Декодування:} Многочлен $\mathbf{m}'$ перетворюється в послідовність біт $m'$, після чого 
        застосовується $\mathsf{eccDEC}$ для виправлення помилок та отримання повідомлення $m$. 
    \item \textbf{Перевірка коректності:} Якщо $\mathsf{eccDEC}$ виявляє unexpect error, повертається $\bot$.
\end{enumerate}

Джерела помилок розшифрування можуть виникнути завдяки:
\begin{itemize}
    \item Помилка $\mathbf{r}$ від RLWR при генерації $\mathbf{b}$;
    \item Помилки $\mathbf{e}_1, \mathbf{e}_2$ від RLWE при шифруванні;
    \item Помилки від компресії/декомпресії $\mathbf{b}, \mathbf{c}_1, \mathbf{c}_2$ відповідно;
\end{itemize}

Параметри TiGER підібрані так, щоб сумарна помилка залишалась в межах $\pm q/4$ з високою ймовірністю, забезпечуючи 
коректне розшифрування. Коди корекції помилок XEf та D2 додатково підвищують надійність.

\section{TiGER.KEM}
\label{sec:4-5}

TiGER.KEM -- механізм інкапсуляції ключа, отриманий застосуванням перетворення Fujisaki-Okamoto з неявним відхиленням 
до TiGER.PKE. Забезпечує IND-CCA безпеку у моделі квантового випадкового оракула.

\subsection{KeyGen -- генерація ключів}
\label{subsec:4-5-1}

Алгоритм генерації ключів розширює TiGER.PKE.KeyGen додатковою компонентою -- FO перетворенням.

\begin{algorithm}[H]
    \caption{TiGER.KEM.KeyGen()}
    \label{alg:4-5-1}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Параметри $(n, q, p, h_s, h_r, k_1)$
        \State \textbf{Output:} Відкритий ключ $pk$, секретний ключ $sk$
        \State
        \State $(pk', sk') \gets$ TiGER.PKE.KeyGen() \Comment{Базова генерація ключів}
        \State
        \State $z \xleftarrow{p} \{0,1\}^{256}$ \Comment{Випадковий ключ для implicit rejection}
        \State $h \gets \text{SHA3-256}(pk')$ \Comment{Геш відкритого ключа}
        \State
        \State $pk \gets pk'$
        \State $sk \gets (sk', z, h, pk')$ \Comment{Розширений секретний ключ}
        \State
        \State \Return $(pk, sk)$
    \end{algorithmic}
\end{algorithm}

\textbf{Компоненти секретного ключа:}

\begin{itemize}
    \item $sk'$ --- секретний ключ TiGER.PKE (правду кажучи це seed $\sigma_s$);
    \item $z$ --- випадковий 256-бітний ключ для обчислення псевдовипадкового спільного ключа при невдалій 
        декапсуляції (неявне відхилення);
    \item $h$ --- геш відкритого ключа, використовується геш-функцією $G$ для генерації випадковості шифрування;
    \item $pk'$ --- копія відкритого ключа (для можливості повторного шифрування при декапсуляції).
\end{itemize}

\subsection{Encapsulation -- інкапсуляція}
\label{subsec:4-5-2}

Алгоритм інкапсуляції генерує спільний ключ та його зашифровану форму.

\begin{algorithm}[H]
    \caption{TiGER.KEM.Encaps$(pk)$}
    \label{alg:4-5-2}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Відкритий ключ $pk$
        \State \textbf{Output:} Шифротекст $ct$ та спільний ключ $K \in \{0,1\}^{256}$
        \State
        \State $m \xleftarrow{p} \{0,1\}^{256}$ \Comment{Вибираємо випадкове повідомлення}
        \State
        \State $h \gets \text{SHA3-256}(pk)$ \Comment{Гешування відкритого ключа}
        \State $r \gets \text{SHAKE256}(m \| h)$ \Comment{Детермінована випадковість}
        \State
        \State $ct \gets$ TiGER.PKE.Enc$(pk, m; r)$ \Comment{Шифрування повідомлення}
        \State
        \State $K \gets \text{SHA3-256}(m \| ct)$ \Comment{Спільний ключ обчислюється через геш}
        \State
        \State \Return $(ct, K)$
    \end{algorithmic}
\end{algorithm}

\textbf{Ключові аспекти:}

\begin{enumerate}
    \item \textbf{Випадкове повідомлення:} Генерується рівномірно (розподілене) випадкове $m \in \{0,1\}^{256}$, яке 
        буде зашифроване.
    \item \textbf{Детермінована випадковість:} Замість використання нової випадковості для шифрування, $r$ обчислюється 
        детермінована як $r = \text{SHAKE256}(m \| h)$. Це критично для можливості повторного шифрування при декапсуляції.
    \item \textbf{Гешування відкритого ключа:} Включення $h = \text{SHA3-256}(pk)$ в обчислення $r$ забезпечує взаємозв'язок 
        шифротексту до конкретного відкритого ключа, що захищає від multi-target атак.
    \item \textbf{Спільний ключ:} Обчислюється як $K = \text{SHA3-256}(m \| ct)$, як можна бачити є залежність як від 
        повідомлення так і від шифротексту. Це є важливим для безпеки алгоритму загалом: противник не може обчислити 
        $K$ без знання $m$, навіть якщо перехопив шифротекст $ct$.
\end{enumerate}

\subsection{Decapsulation -- декапсуляція}
\label{subsec:4-5-3}

Декапсуляція застосовується для відновлення спільного ключ з шифротексту, виконуючи перевірку цілісності через 
повторне шифрування.

\begin{algorithm}[H]
    \caption{TiGER.KEM.Decaps$(sk, ct)$}
    \label{alg:4-5-3}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Секретний ключ $sk = (sk', z, h, pk)$, шифротекст $ct$
        \State \textbf{Output:} Спільний ключ $K \in \{0,1\}^{256}$
        \State
        \State $m' \gets$ TiGER.PKE.Dec$(sk', ct)$ \Comment{Розшифрування}
        \State
        \If{$m' = \bot$}
            \State \Return $\overline{K} \gets \text{SHA3-256}(z \| ct)$ \Comment{Implicit rejection}
        \EndIf
        \State
        \State $r' \gets \text{SHAKE256}(m' \| h)$ \Comment{Створення "випадковості"{}}
        \State $ct' \gets$ TiGER.PKE.Enc$(pk, m'; r')$ \Comment{Повторне шифрування}
        \State
        \If{$ct' = ct$}
            \State \Return $K \gets \text{SHA3-256}(m' \| ct)$ \Comment{Успішна декапсуляція}
        \Else
            \State \Return $\overline{K} \gets \text{SHA3-256}(z \| ct)$ \Comment{Implicit rejection}
        \EndIf
    \end{algorithmic}
\end{algorithm}

\begin{enumerate}
    \item \textbf{Розшифрування:} Спершу -- звичайне розшифрування через TiGER.PKE.Dec. Якщо розшифрування 
        видало помилку ($m' = \bot$), одразу повертається псевдовипадковий ключ.
    \item \textbf{Re-encryption:} Розшифроване повідомлення $m'$ повторно шифрується з тією ж визначеною випадковістю 
        $r' = \text{SHAKE256}(m' \| h)$ (є критичном кроком для забезпечення IND-CCA безпеки).
    \item \textbf{Перевірка цілісності:} Отриманий $ct'$ порівнюється з оригінальним $ct$:
        \begin{itemize}
            \item Якщо $ct' = ct$, це означає, що шифротекст не був модифікований противником, і тоді повертається 
                справжній спільний ключ $K = \text{SHA3-256}(m' \| ct)$;
            \item Якщо $ct' \neq ct$, це сигналізує про атаку або помилку, і повертається псевдовипадковий ключ, щоб 
                заплутати зловмисника.
        \end{itemize}
    \item \textbf{Неявне відхилення (implicit rejection):} Замість явного повернення помилки $\bot$, алгоритм повертає 
        псевдовипадковий ключ $\overline{K} = \text{SHA3-256}(z \| ct)$. Це має дві такі переваги:
        \begin{itemize}
            \item \textbf{Захист від side-channel атак:} Зовнішньому спостерігачу важко визначити, чи відбулась успішна 
                декапсуляція чи ні, оскільки в обох випадках повертається деякий 256-бітний ключ;
            \item \textbf{Константний час:} Що при успішному output, що пои failed виконується однакова кількість 
                геш-операцій.
        \end{itemize}
    \item \textbf{Роль секретного ключа $z$:} Випадковий ключ $z$ є унікальним для кожної пари ключів та невідомим 
        противнику. Це гарантує, що $\overline{K}$ буде непередбачуваним для противника навіть за наявності багатьох 
        невдалих декапсуляцій.
\end{enumerate}

\noindent \textbf{Ключові моменти безпеки або ж чому це безпечно}

Перетворення FO$^{\not\bot}_m$ з повторним шифруванням перетворює будь-яку IND-CPA безпечну PKE схему в IND-CCA 
безпечну KEM.

\begin{itemize}
    \item \textbf{Детермінована випадковість:} Використання $r = \text{SHAKE256}(m \| h)$ замість нової випадковості 
        робить шифрування детермінованим для даного $m$ та $pk$, що дозволяє виконати перевірку через повторне шифрування;
    \item \textbf{Гешування спільного ключа:} $K = \text{SHA3-256}(m \| ct)$ робить спільний ключ непередбачуваним 
        без знання $m$, навіть якщо $ct$ скомпроментовано супротивником;
    \item \textbf{Захист від атак вибраного шифротексту:} Противник може подавати довільні модифіковані шифротексти 
        $ct^*$ до оракула декапсуляції, але:
        \begin{itemize}
            \item Якщо $ct^*$ не є валідним шифруванням деякого $m^*$, перевірка умови $ct' \neq ct^*$ виявить це;
            \item Противник отримає лише $\overline{K} = \text{SHA3-256}(z \| ct^*)$, що не надає жодної інформації про 
                справжній спільний ключ через випадковість $z$ та властивості геш-функції.
        \end{itemize}
\end{itemize}

\section{Аналіз коректності}
\label{sec:4-6}

Коректність вимагає від TiGER, того щоб розшифрування майже завжди повертало правильне повідомлення. У цій секції 
проаналізуємо джерела помилок та обчислимо ймовірність помилки розшифрування.

\subsection*{Математичний аналіз помилок}

При розшифруванні повідомлення обчислюється величина:
\begin{equation*}
    \mathbf{v} = \mathbf{c}_2' - \mathbf{c}_1' \cdot \mathbf{s} = \mathbf{m} \cdot \lfloor q/2 \rfloor + \mathbf{err},
\end{equation*}
де $\mathbf{err}$ -- сумарна помилка з декількох джерел.

\noindent \textbf{Джерела помилок є наступними:}

\begin{enumerate}
    \item \textbf{Помилка від RLWR:} При генерації відкритого ключа:
        \begin{equation*}
            \mathbf{b} = \lfloor (\mathbf{a} \cdot \mathbf{s} + \mathbf{r}) \cdot (p/q) \rceil,
        \end{equation*}
        що вносить помилку округлення $\mathbf{err}_{\text{RLWR}}$, де $\mathbf{err}_{\text{RLWR}} \approx \mathbf{r} \cdot (p/q)$.
    \item \textbf{Помилка від RLWE:} При шифруванні:
        \begin{equation*}
            \mathbf{c}_1' = \mathbf{a} \cdot \mathbf{e}_1 + \mathbf{e}_2, \quad \mathbf{c}_2' = \mathbf{b}' \cdot \mathbf{e}_1 + \mathbf{m} \cdot \lfloor q/2 \rfloor,
        \end{equation*}
        що вносить помилку $\mathbf{err}_{\text{RLWE}} = -\mathbf{e}_2 \cdot \mathbf{s} + \mathbf{err}_{\text{RLWR}} \cdot \mathbf{e}_1$.
    \item \textbf{Помилка від компресії відкритого ключа:} Компресія $\mathbf{b}$ ($\log_2 p$ \to $k_1$) біт 
        вносить наступну помилку округлення:
        \begin{equation*}
            \mathbf{err}_{\text{comp},\mathbf{b}} \approx \mathbf{U}([-p/2^{k_1+1}, p/2^{k_1+1}]).
        \end{equation*}
    \item \textbf{Помилка від компресії шифротексту:} Компресія $\mathbf{c}_1$ до $k_2$ біт та $\mathbf{c}_2$ до 1 біт:
        \begin{equation*}
            \mathbf{err}_{\text{comp},\mathbf{c}_1} \approx \mathbf{U}([-q/2^{k_2+1}, q/2^{k_2+1}]), \quad 
            \mathbf{err}_{\text{comp},\mathbf{c}_2} \approx \mathbf{U}([-q/4, q/4]).
        \end{equation*}
\end{enumerate}

\noindent \textbf{Сумарна помилка складатиме:} помилку в кожному коефіцієнті многочлена $\mathbf{v}$:
\begin{equation*}
    \begin{aligned}
    \mathbf{err} &= \mathbf{err}_{\text{comp},\mathbf{c}_2} + \mathbf{err}_{\text{comp},\mathbf{c}_1} \cdot \mathbf{s} \\
    &\quad + (\mathbf{err}_{\text{comp},\mathbf{b}} \cdot \mathbf{e}_1 - \mathbf{e}_2 \cdot \mathbf{s} + \mathbf{r} \cdot \mathbf{e}_1 \cdot (p/q)).
    \end{aligned}
\end{equation*}

\noindent Помилка розшифрування виникає, коли $|\mathbf{err}_i| \geq q/4$ для якогось коефіцієнта $i$, і це призводить до 
неправильного округлення.

\subsection*{Оцінка ймовірності помилки}

Для оцінки DFP/R необхідно обчислити ймовірність того, що хоча б один коефіцієнт має помилку $\geq q/4$.

\textbf{Статистичний аналіз:}

\begin{enumerate}
    \item \textbf{Розподіл помилок:} Кожна компонента помилки має рівномірний розподіл в заданих межах.
    \item \textbf{Дисперсія:} Для розрідженого тернарного многочлена $\mathbf{s}$ з вагою $h_s$:
        \begin{equation*}
            \text{Var}(\mathbf{s}) \approx h_s, \quad \text{Var}(\mathbf{s} \cdot \mathbf{e}) \approx h_s \cdot h_e / 3,
        \end{equation*}
        де ділення враховує коефіцієнти $\{-1, 0, 1\}$.
    \item \textbf{Максимальна помилка складає:}
        \begin{equation*}
            \sigma^2_{\text{err}} \approx h_s \cdot h_e / 3 + h_r \cdot h_e \cdot (p/q)^2 + (q/2^{k_2+1})^2 + (q/2)^2 + \ldots
        \end{equation*}
    \item \textbf{DFP/R для одного коефіцієнта:} Ймовірність помилки в одному з коефіцієнтів:
        \begin{equation*}
            P(\text{помилка в } i\text{-му коефіцієнті}) \approx 2 \cdot Q(q/4 / \sigma_{\text{err}}),
        \end{equation*}
        де $Q(x) = \frac{1}{\sqrt{2\pi}} \int_x^\infty e^{-t^2/2} dt$ -- функція розподілу помилок для нормального розподілу.
    \item \textbf{Тоді DFP/R для всього повідомлення:}
        \begin{equation*}
            \text{DFP/R} \leq n \cdot P(\text{помилка в одному коефіцієнті}) = n \cdot 2 \cdot Q(q/4 / \sigma_{\text{err}}).
        \end{equation*}
\end{enumerate}

\noindent \textbf{Різні параметри мають різний вплив на DFP/R:}

\begin{enumerate}
    \item \textbf{Модулі $q$ та $p$:}
        \begin{itemize}
            \item Більше $q$ збільшує інтервал ($q/4$ стає більшим), зменшуючи DFP/R;
            \item Менше відношення $q/p$ зменшує помилку від RLWR, але при цьому збільшує розмір відкритого ключа.
        \end{itemize}
    \item \textbf{Ваги Геммінга $h_s, h_r, h_e$:}
        \begin{itemize}
            \item Більші ваги збільшують дисперсію помилки, підвищуючи DFP/R;
            \item Менші ваги зменшують безпеку (легше атакувати розріджені ключі);
        \end{itemize}
    \item \textbf{Параметри компресії $k_1, k_2$:}
        \begin{itemize}
            \item Менші $k_1, k_2$ краще зменшують розміри ключів/шифротексту, збільшуючи помилку компресії;
        \end{itemize}
    \item \textbf{Коди корекції помилок (XEf, D2):}
        \begin{itemize}
            \item Коди XEf можуть виправити одиночні помилки в блоках по $d$ біт, знижуючи доволі DFP/R доволі 
                добре (у $d$ разів) для таких помилок;
            \item Код D2 з $f = 2$ дублює кожен біт, дозволяючи виправляти помилки через мажоритарне голосування.
        \end{itemize}
\end{enumerate}

\subsection*{Експериментальні результати}

Автори TiGER провели обчислювальні експерименти для верифікації теоретичних оцінок DFP/R і отримали:

\begin{itemize}
    \item \textbf{TiGER128:} DFP/R $\approx 2^{-120}$ (теоретична), $< 2^{-128}$ (експериментальна після $2^{40}$ тестів);
    \item \textbf{TiGER192:} DFP/R $\approx 2^{-136}$ (теоретична), не виявлено помилок після $2^{45}$ тестів;
    \item \textbf{TiGER256:} DFP/R $\approx 2^{-167}$ (теоретична), не виявлено помилок після $2^{48}$ тестів.
\end{itemize}

Експерименти підтверджують, що практична DFP/R не перевищує теоретичних оцінок і є достатньо малою для будь-яких 
реалістичних сценаріїв використання.

\section{Особливості реалізації}
\label{sec:4-7}

TiGER розроблявся з ухилом на ефективність та безпеку.

Конструкція TiGER має наступні риси, що забезпечують компактність, ефективність та безпеку реалізації. 

\textbf{Компактність} досягається через використання RLWR та агресивної компресії, що дозволяє отримати малі 
розміри відкритого ключа та шифротексту порівняно з аналогами. Наприклад, TiGER128 має відкритий ключ розміром 
лише 804 байти та шифротекст 804 байти, що менше ніж у Kyber512 (800 + 768 байт) та Saber (672 + 736 байт). 
Економія місця особливо важлива для протоколів з обмеженою пропускною здатністю, таких як TLS, де кожен байт має 
значення. Також зберігання seed замість повних многочленів (як у $\mathbf{a}$) економить до 2 КБ для TiGER256.

\textbf{Висока обчислювальна ефективність} забезпечується через використання модулів які є степенями двійки ($q = 2^k$), 
що дозволяє виконувати операції модульної арифметики через прості побітові зсуви:
\begin{itemize}
    \item Округлення $\lfloor x \cdot (p/q) \rceil$ виконується як побітовий зсув вправо: оскільки $q = 2^{14}$ та 
        $p = 2^{10}$ для TiGER128, ділення на $q/p = 2^4$ еквівалентне зсуву на 4 біти;
    \item  Операції за $\bmod q$ виконуються через побітовий AND з числом $q - 1$. Це значно швидше ніж модульні 
        операції, що використовуються в деяких інших схемах. 
    \item Розріджені секрети ($h_s \ll n$) прискорюють множення многочленів: замість $O(n^2)$ операцій для множення, 
        потрібно лише $O(h_s \cdot n)$ операцій, що дає прискорення приблизно в $n/h_s \approx 2$ рази.
\end{itemize}

\textbf{Простота в реалізації} є важливою перевагою TiGER. Відмова від використання Number Theoretic Transform (NTT) 
спрощує імплементацію, оскільки NTT вимагає специфічних модулів виду $q = 1 \bmod 2n$ та bit-reversal permutation
(якийсь жах, я таки не вдуплив що це). TiGER використовує множення многочленів, яке, хоч і має вищу асимптотичну 
складність $O(n^2)$ порівняно з $O(n \log n)$ для NTT, але є простішим для людського сприйняття та реалізації. Для 
розріджених многочленів складність знижується до $O(h \cdot n)$, що робить це множення конкурентоспроможним.
При реалізації важливо уникати умовних переходів та операцій індексації масивів, які залежать від секретних значень, 
оскільки це може призвести до витоку інформації через timing або cache атаки.

\textbf{Захист від атак} забезпечується кількома механізмами:
\begin{itemize}
    \item Неявне відхилення (implicit rejection) у TiGER.KEM захищає від витоку інформації через помилки розшифрування. 
        Це протидіє failure boosting attacks, де противник ітеративним підходом підбирає шифротексти з високою ймовірністю 
        помилки для витягування інформації про секретний ключ. (адаптивна атака на основі вибраного шифротекста)
    \item Гешування відкритого ключа ($r = G(m, H(pk))$) забезпечує стійкість до multi-target атак, прив'язуючи кожен 
        шифротекст до конкретного відкритого ключа.
    \item Детермінована випадковість шифрування через $G$ дозволяє виконати перевірку цілісності через повторне шифрування, 
        що є основою IND-CCA безпеки.
\end{itemize} 

\textbf{Коди корекції помилок} є ключовою інновацією вTiGER. Застосування кодів XEf та D2 значно знижує ймовірність 
помилки розшифрування без збільшення розміру шифротексту. Код XEf може виправити одиночні помилки в блоках по $d$ 
біт та відповідно підвищує стійкість у стільки ж разів. Без кодів корекції довелося або використовувати менш 
агресивне стиснення (більший шифротекст), або змиритися з вищим DFP/R, що неприйнятно для практичних застосувань.

\textbf{Константний час виконання} є критичним для захисту від атак через побічні канали (side-channel attacks). 
Генерація розріджених многочленів через $\mathsf{HWT}_h$ використовує rejection sampling, при цьому загальна 
кількість ітерацій обмежена та не залежить від секретних даних. Операції з многочленами виконуються за фіксований 
час незалежно від значень коефіцієнтів. Плюс неявне відхилення гарантує, що (не)успішна декапсуляція виконуються 
з використанням однакової кількості геш-операцій.

\textbf{Практичні переваги} Модульна структура (PKE + FO) дозволяє окремо тестувати та оптимізувати різні компоненти. 
Відсутність складних математичних операцій (як pairing у криптографії на еліптичних кривих) робить TiGER перспективним 
для впровадження на пристроях з обмеженим ресурсом (embedded systems, IoT).

У таблиці~\ref{table:4-7-1} підсумуємо ключові технічні рішення TiGER та їх вплив на характеристики алгоритму.

\begin{longtblr}[
    caption = {Порівняльна таблиця покращень TiGER},
    label = {table:4-7-1},
]{
    colspec = {| X[1,l] | X[1.2,l] | X[1.2,l] |},
    rowhead = 1,
    hlines,
    row{1} = {c}, % Заголовки таблиці по центру
}
    % Заголовок
    \textbf{Технічне рішення} & \textbf{Переваги} & \textbf{Компроміси} \\
    \hline

    % Вміст
    \textbf{RLWR замість RLWE} (відкритий ключ) &
    \textit{+} Менший розмір $pk$ через детерміноване округлення &
    \textit{-} Необхідність балансування $q/p$ \\

    \textbf{Модулі -- степені двійки} ($q = 2^k$, $p = 2^k$) &
    \textit{+} Швидкі побітові операції \newline
    \textit{+} Простота в реалізації \newline
    \textit{+} Const час виконання &
    \textit{-} Трохи менша безпека на біт порівняно з простим $q$ \\

    \textbf{Розріджені секрети} ($h_s, h_r, h_e \ll n$) &
    \textit{+} Швидке множення: $O(h \cdot n)$ замість $O(n^2)$ \newline
    \textit{+} Менша дисперсія помилок &
    \textit{-} Потенційна вразливість до комбінованих атак \newline
    \textit{-} Невипадковий вибір $h$ для збереження safety balance \\

    \textbf{Відсутність NTT} &
    \textit{+} Свобода у виборі модулів $p$, $q$ \newline
    \textit{+} Менше ризиків для side-channel attacks &
    \textit{-} Повільніше множення: $O(n^2)$ vs $O(n \log n)$ \newline
    \textit{-} Компенсується розрідженістю \\

    \textbf{Агресивна компресія} ($k_1 = 10$-$11$, $k_2 = 4$-$5$) &
    \textit{+} Компактні розміри $pk$ і $ct$ \newline
    \textit{+} Ефективність у протоколах з обмеженою пропускною здатністю &
    \textit{-} Збільшення помилок компресії \newline
    \textit{-} Вища DFP без корекції помилок \\

    \textbf{Коди корекції помилок} (XEf + D2) &
    \textit{+} Дуже низька DFP ($\leq 2^{-120}$) \newline
    \textit{+} Дозволяє агресивнішу компресію \newline
    \textit{+} Надійність decryption &
    \textit{-} Невелике збільшення обчислень \newline
    \textit{-} Складніша логіка реалізації коду \\

    \textbf{Неявне відхилення} (implicit rejection) &
    \textit{+} Захист від failure boosting атак \newline
    \textit{+} Константний час (успіх = невдача) &
    \textit{-} Складніша декапсуляція \\

    \textbf{Seed-based генерація} ($\rho$ для $\mathbf{a}$, $\sigma$ для $\mathbf{s}$) &
    \textit{+} Малі розміри ключів (256 біт seed замість $n \log q$ біт) \newline
    \textit{+} Детермінованість і повторюваність &
    \textit{-} Потреба регенерувати многочлени при використанні \newline
    \textit{-} Вимоги до якісного PRNG \\

    \textbf{FO$^{\not\bot}_m$ перетворення} &
    \textit{+} IND-CCA безпека з IND-CPA PKE \newline
    \textit{+} Стандартизований підхід \newline
    \textit{+} Забезпечення безпеки в QROM &
    \textit{-} Потреба повторного шифрування \newline
    \textit{-} Додаткові геш-обчислення \\

    \textbf{Детермінована випадковість} ($r = G(m, h)$) &
    \textit{+} Можливість перевірки через re-encryption \newline
    \textit{+} Відсутність потреби у новій випадковості при Enc &
    \textit{-} Критична залежність від стійкості самих геш-функцій \newline
    \textit{-} І вразливість при компрометації $G$ \\
\end{longtblr}

Як видно з таблиці, більшість технічних рішень TiGER представляють собою компроміси між різними характеристиками. 
Ключовою перевагою є досягнення балансу між безпекою, ефективністю та компактністю при збереженні практичності 
реалізації. Особливо цінною є комбінація агресивної компресії з кодами корекції помилок -- це унікальність TiGER 
порівняно з багатьма конкурентами.

\chapter{\large{Аналіз безпеки}}
\label{chapter:5}

\section{Теоретичні основи безпеки}
\label{sec:5-1}

TiGER.PKE та TiGER.KEM забезпечують різні рівні криптографічної безпеки завдяки застосуванню добре вивчених 
криптографічних перетворень.

\subsection{IND-CPA безпека TiGER.PKE}
\label{subsec:5-1-1}

Базова схема TiGER.PKE забезпечує безпеку проти атаки з використанням відкритого тексту -- IND-CPA (Indistinguishability 
under Chosen Plaintext Attack). Формально, це означає, що противник, може обирати повідомлення та отримувати їх шифрування, 
але при цьому не може відрізнити шифротексти двох обраних ним повідомлень з ймовірністю суттєво більшою за $1/2$.

\begin{claim}[про IND-CPA безпеку]
    \label{claim:5-1-1}
    ~\par У припущенні складності RLWE та RLWR проблем, TiGER.PKE є IND-CPA безпечною схемою шифрування з відкритим ключем 
    у моделі випадкового оракула.
\end{claim}

\noindent \textit{Ідея доведення:} Безпека TiGER.PKE зводиться до складності двох задач: RLWR (для відкритого ключа) 
та RLWE (для шифротексту). Відкритий ключ $\mathbf{b} = \lfloor (\mathbf{a} \cdot \mathbf{s} + \mathbf{r}) \cdot (p/q) \rceil$ 
є RLWR зразком, який не розкриває інформацію про $\mathbf{s}$ за припущення складності RLWR. А шифротекст 
$(\mathbf{c}_1, \mathbf{c}_2)$ складається з RLWE зразків: $\mathbf{c}_1' = \mathbf{a} \cdot \mathbf{e}_1 + \mathbf{e}_2$ 
є RLWE зразком відносно $\mathbf{e}_1$, а $\mathbf{c}_2' = \mathbf{b}' \cdot \mathbf{e}_1 + \mathbf{m} \cdot \lfloor q/2 \rfloor$ 
маскує повідомлення $\mathbf{m}$ через RLWE. Зловмисник, який здатний розрізняти шифротексти, міг би вирішити 
RLWE/RLWR задачі, а це суперечить припущенню їх складності.

\subsection{IND-CCA безпека TiGER.KEM}
\label{subsec:5-1-2}

TiGER.KEM досягає значно кращої безпеки. Він має стійкість до атак з виборним шифротекстом -- IND-CCA 
(Indistinguishability under Chosen Ciphertext Attack). У цій моделі противник має доступ до оракула декапсуляції 
і може подавати довільні шифротексти для розшифрування (за винятком цільового шифротексту).

\begin{claim}[про IND-CCA безпеку]
    \label{claim:5-1-2}
    ~\par За припущенням IND-CPA безпеки TiGER.PKE та моделювання геш-функцій $G$, $H$, як квантових випадкових оракулів, 
    TiGER.KEM є IND-CCA безпечною в моделі квантового випадкового оракула (QROM).
\end{claim}

\noindent \textit{Ідея доведення:} Безпека досягається через перетворення Fujisaki-Okamoto з неявним відхиленням 
(FO$^{\not\bot}_m$). Доведення використовує послідовність game-hopping (гібридних експериментів), де в кожному 
наступному експерименті протокол модифікується незначним чином, і в результаті зловмисник не може відрізнити 
сусідні експерименти. Заключний експеримент відповідає ситуації, де спільний ключ є повністю випадковим і незалежним 
від шифротексту.

\subsection{Важливість моделі QROM}
\label{subsec:5-1-3}

Класичні доведення безпеки FO перетворення використовують модель випадкового оракула (ROM), де геш-функції моделюються 
як справжні випадкові функції, доступні лише через класичні запити(??). Однак зловмисник з квантовим комп'ютером може 
виконувати \textit{квантові запити} до оракулів, що являють собою суперпозиції багатьох входів одночасно, що потенційно 
дає переваги в атаках.

Модель квантового випадкового оракула (QROM) враховує цю загрозу, моделюючи геш-функції як квантові оракули, доступні 
для квантових запитів. TiGER.KEM має формальне доведення безпеки в QROM, що підтверджує його стійкість навіть проти 
зловмисників з доступом до квантових обчислень геш-функцій.

\section{Квантова стійкість}
\label{sec:5-2}

Основна мотивація постквантової криптографії -- захист від появи квантових комп'ю\-терів, які становлять екзистенційну 
і доволі реальну загрозу для сучасних криптосистем на основі розв'язання задач факторизації та дискретного логарифму.

\subsection*{Квантові загрози класичній криптографії}

Квантові алгоритми: Шора (1994) та Гровера (1996) радикально змінили ландшафт криптографічної безпеки:

\textbf{Алгоритм Шора} вирішує задачі факторизації цілих чисел та дискретного логарифму за поліноміальний час на 
квантовому комп'ютері. Для числа $N$ складність факторизації становить $\exp(O((\log N)^{1/3}))$ (субекспоненційна), 
тоді як квантовий алгоритм Шора досягає $O((\log N)^3)$ (поліноміальна). Це означає повну компрометацію таких 
алгоритмів як:
\begin{itemize}
    \item \textbf{RSA:} Квантовий комп'ютер з $\sim$2000 логічних кубітів може факторизувати 2048-бітне число за 
        лічені години (трохи перебільшую, але все ж);
    \item \textbf{ECDSA/ECDH:} Дискретний логарифм на еліптичних кривих вирішується аналогічно ефективно;
    \item \textbf{Diffie-Hellman:} Класичний варіант DH також стає вразливим через полегшення обрахування дискретного 
        логарифму у скінченних полях.
\end{itemize}

\textbf{Алгоритм Гровера} забезпечує квадратичне(!) прискорення задачі пошуку в несортованих базах даних. Для 
звичаного пошуку розміру $N$, класична складність становила б $O(N)$, тоді як квантовий алгоритм досягає 
$O(\sqrt{N})$. Це має свій вплив на симетричну криптографію:
\begin{itemize}
    \item \textbf{AES-128:} Ефективна безпека знижується до $2^{64}$ операцій, що вже недостатньо;
    \item \textbf{SHA-256:} Collision resistance (стійкість до колізій) зменшується з $2^{128}$ до $2^{85}$, а 
        preimage resistance (стійкість до знаходження прообразу) -- з $2^{256}$ до $2^{128}$;
\end{itemize}
Як наслідок - треба подвоювати розмірів ключів (AES-256, SHA-512) для збереження еквівалентного рівня безпеки.

В той же час решіткові задачі є стійкими до квантових атак. На відміну від факторизації та дискретного логарифму, 
задачі на решітках (включно з RLWE та RLWR) не мають відомих ефективних квантових алгоритмів.

\noindent Ключові причини цього:
\begin{enumerate}
    \item \textbf{Відсутність прихованої підгрупової структури:} Алгоритм Шора використовує квантове перетворення 
        Фур'є (QFT) для виявлення періодичності в підгрупах кільця $\mathbb{Z}_N^*$ або серед точок еліптичної кривої. 
        Решіткові задачі не мають такої регулярної алгебраїчної структури, яка б дозволяла QFT виявляти корисну інформацію.
    \item \textbf{Геометрична проблема:} Задачі на решітках є геометричними проблемами -- пошук найближчого вектора решітки 
        або найкоротшого ненульового вектора. Ці задачі залишаються складними навіть для квантових алгоритмів, 
        оскільки не існує приведення до задач з експоненційною кількістю періодичних розв'язків.
    \item \textbf{Відомі квантові атаки неефективні:} Найкращі з відомих квантових алгоритми для решіткових задач 
        це квантові версії класичних BKZ (Block Korkine-Zolotarev) та sieving алгоритмів. Вони надають лише 
        \textit{поліномільно-логарифмічне} прискорення (наприклад, з $2^{0.292\beta}$ до $2^{0.265\beta}$ для просіювання, 
        де $\beta$ -- block dimension), що далеко від експоненційного прискорення алгоритму Шора.
\end{enumerate}

\subsection*{Оцінка квантової складності атак на TiGER}

Для оцінки безпеки TiGER проти квантових атак використовується модель Core-SVP (Short Vector Problem), що 
вимірює складність вирішення SVP на решітці розмірності $\beta$ (block dimension):

\noindent В класичній моделі обчислень найкращими класичними алгоритми (BKZ + sieving) досягається:
\begin{equation*}
    T_{\text{classical}} \approx 2^{0.292\beta + o(\beta)}
\end{equation*}

\noindent В квантовому всесвіті, при застосуванні квантових версії sieving алгоритмів (див. Laarhoven et al., 2015), 
складність досягає:
\begin{equation*}
    T_{\text{quantum}} \approx 2^{0.265\beta + o(\beta)}
\end{equation*}

\noindent Для TiGER параметри обиралися так, щоб при достатньо великому $\beta$ забезпечувався бажаний рівень безпеки:

\begin{itemize}
    \item \textbf{TiGER128:} $\beta_{\text{quantum}} \approx 483$, це дає $2^{128}$ квантових операцій для атаки;
    \item \textbf{TiGER192:} $\beta_{\text{quantum}} \approx 724$, що дає $2^{192}$ квантових операцій;
    \item \textbf{TiGER256:} $\beta_{\text{quantum}} \approx 966$, що дає $2^{256}$ квантових операцій.
\end{itemize}

\noindent Ці оцінки консервативні і враховують можливі майбутні покращення квантових алгоритмів. Навіть за наявності 
велитенського квантового комп'ютера/ів з мільйонами логічних кубітів, злам того ж TiGER128 вимагав би $2^{128}$ 
квантових операцій, що наразі є практично нереалістичним.

\subsection*{Стійкість головного у TiGER -- геш-функції}

TiGER використовує геш-функції SHA3-256 та SHAKE256, які також мають бути квантово стійкими:

\begin{itemize}
    \item \textbf{SHA3 (Keccak):} Базується на губчастій конструкції (sponge construction), яка не має відомих 
        квантових атак, ефективніших за атаку із застосуванням алгоритму Гровера. Для SHA3-256 квантова 
        collision resistance становить порядку $\approx 2^{85}$ операцій, а preimage resistance -- $2^{128}$ операцій. 
        Це є терпимим для використання у TiGER.KEM.
    \item \textbf{SHAKE256:} Як XOF (extendable-output function) з змінною довжиною виходу, SHAKE256 має аналогічну 
        як і SHA3. Використання $G$ для генерації детермінованої випадковості не створює додаткових квантових 
        вразливостей.
\end{itemize}

\section{Рівні безпеки NIST}
\label{sec:5-3}

NIST (National Institute of Standards and Technology) визначив п'ять рівнів безпеки для стандартизації 
постквантових алгоритмів. Ці рівні дозволяють порівнювати стійкість різних алгоритмів з існуючими класичними 
еталонними схемами.

\subsection{Категорії безпеки згідно NIST}
\label{subsec:5-3-1}
Рівні безпеки NIST визначаються через мінімальну обчислювальну складність зламу, еквівалентну пошуку ключа в 
симетричних криптосистемах або зламу класичних асиметричних схем:

\begin{table}[H]
    \begin{tblr}{
            colspec = {| X[1,c] | X[3,l] | X[4,l] |},
            vlines,
            hlines,
            row{1} = {c},
        }
        \textbf{Рівень} & \textbf{Класичний еквівалент} & \textbf{Квантовий еквівалент}                                     \\
        \hline
        \textbf{1}      & Пошук ключа AES-128           & $2^{128}$ класичних або $2^{64}$ квантових операцій               \\
        \hline
        \textbf{2}      & Collision пошук в SHA-256     & $2^{128}$ класичних або $2^{64}$ квантових операцій (для колізій) \\
        \hline
        \textbf{3}      & Пошук ключа AES-192           & $2^{192}$ класичних або $2^{96}$ квантових операцій               \\
        \hline
        \textbf{4}      & Collision пошук в SHA-384     & $2^{192}$ класичних або $2^{96}$ квантових операцій (для колізій) \\
        \hline
        \textbf{5}      & Пошук ключа AES-256           & $2^{256}$ класичних або $2^{128}$ квантових операцій              \\
    \end{tblr}
    \caption{Рівні безпеки NIST}
    \label{table:5-3-1}
\end{table}

\noindent Насправді є 3 NIST anchor layers (1, 3, 5), а інші два -- містять проміжні значення.

\begin{enumerate}
    \item \textbf{TiGER128 (Рівень 1):} Призначений для загального використання, де потрібен баланс між безпекою та 
        ефективністю. Перший рівень достатній для захисту більшості даних на найближчі 10-15 років, враховуючи 
        поточний стан квантових технологій.
    \item \textbf{TiGER192 (Рівень 3):} Підвищена безпека для конфіденційних даних, що вимагають довгострокового 
        захисту (20-30 років). Квантова безпека $2^{192}$ операцій робить атаку практично неможливою навіть за 
        наявності значних прогресів у квантових обчисленнях.
    \item \textbf{TiGER256 (Рівень 5):} Максимальна безпека для критично важливих застосувань (державні секрети, 
        військові документи, фінансові інфраструктури і т.п.). Квантова безпека в $2^{256}$ операцій гарантує 
        захист навіть від гіпотетичних квантових комп'ютерів майбутнього з безпрецедентною обчислювальною потужністю, 
        але ми ще подивимося:).
\end{enumerate}

\noindent \textbf{Ключові принципи NIST:}
\begin{enumerate}
    \item Рівні безпеки NIST визначаються за складністю атаки квантовим комп'ютером. Наприклад, рівень 1 вимагає, 
        щоб квантова атака на алгоритм вимагала не менше ресурсів, ніж квантовий пошук ключа AES-128 
        (що становить $2^{64}$ квантових операцій через алгоритм Гровера s еквівалентно $2^{128}$ класичним).
    \item NIST вимагає консервативних оцінок безпеки, що враховують можливі майбутні покращення алгоритмів для атак. 
        Алгоритм вважається відповідним рівню безпеки, якщо найкраща відома атака (з урахуванням можливих покращень) 
        вимагатиме не менше ресурсів, ніж еталонна задача.
    \item Рівні NIST фокусуються також на практичній складності атак, враховуючи не лише теоретичну складність 
        алгоритмів, але й реальні обчислювальні обмеження.
\end{enumerate}

\subsection{Відповідність TiGER стандартам NIST}
\label{subsec:5-3-2}

TiGER має три набори (див. табл~\ref{table:4-2-1}) параметрів, що відповідають відповідно трьом рівням безпеки NIST:

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Характеристика}      & \textbf{TiGER128} & \textbf{TiGER192} & \textbf{TiGER256} \\
        \hline
        \hline
        Рівень NIST                  & \textbf{1}        & \textbf{3}        & \textbf{5}        \\
        \hline
        Класична безпека (біт)       & 143               & 207               & 272               \\
        \hline
        Квантова безпека (біт)       & 128               & 192               & 256               \\
        \hline
        Core-SVP $\beta$ (квантовий) & 483               & 724               & 966               \\
        \hline
        Складність атаки (кв. опер.) & $2^{128}$         & $2^{192}$         & $2^{256}$         \\
        \hline
        Еквівалент NIST              & AES-128           & AES-192           & AES-256           \\
        \hline
    \end{tabular}
    \caption{Відповідність параметрів TiGER рівням NIST}
    \label{table:5-3-2}
\end{table}

Важливою характеристикою також є \textit{запас безпеки} -- різниця між заявленим рівнем безпеки та фактичною складністю 
найкращої відомої атаки. TiGER має значний запас безпеки:

\begin{itemize}
    \item \textbf{TiGER128:} Класична безпека $\approx 143$ біт при заявлених 128 біт (запас $+15$ біт);
    \item \textbf{TiGER192:} Класична безпека $\approx 207$ біт при заявлених 192 біт (запас $+15$ біт);
    \item \textbf{TiGER256:} Класична безпека $\approx 272$ біт при заявлених 256 біт (запас $+16$ біт).
\end{itemize}

Цей запас забезпечує захист від можливих майбутніх покращень алгоритмів атак та надає впевненість у довгостроковій 
безпеці TiGER. Навіть якщо з'являться нові методи атак, що знижують складність на порядка $\sim 2^{10}$ операцій, 
TiGER лишатиметься безпечним на заявлених рівнях.

\chapter{\large{Порівняння з іншими алгоритмами}}
\label{chapter:6}

\section{TiGER vs RLizard}
\label{sec:6-1}

RLizard є безпосереднім попередником алгоритму TiGER, розробленим тією ж командою в 2018 році. TiGER успадковує 
багато ідей від RLizard і вносить значні покращення, що роблять його більш компактним та ефективним.

\subsection*{Спільні риси}

TiGER та RLizard мають багато спільного:

\begin{enumerate}
    \item \textbf{Поєднання RLWE/RLWR:} Обидва алгоритми використовують RLWR для генерації відкритого 
        ключа та RLWE для шифрування. Це дозволяє зменшити розмір відкритого ключа через округлення.
    \item \textbf{Модулі у вигляді степенів двійки:} Використання модуля виду $q = 2^k$ для оптимізації 
        модульних операцій через побітові операції зсуву та bitwise AND.
    \item \textbf{Відсутність NTT:} Обидва алгоритми не використовують Number Theoretic Trans\-form, що спрощує 
        програмну реалізацію, і при цьому ж зменшує ризики side-channel атак.
    \item \textbf{Розріджені секрети:} Секретні ключі та помилки є тернарними многочленами з малою вагою 
        Геммінга ($h \ll n$). Це прискорює прискорює множення многочленів.
    \item \textbf{FO перетворення:} Обидві схеми використовують перетворення Fujisaki-Okamoto для досягнення 
        IND-CCA безпеки KEM з IND-CPA безпечної PKE.
\end{enumerate}

\subsection*{Ключові відмінності}

TiGER вносить кілька суттєвих покращень порівняно з RLizard:

\begin{enumerate}
    \item \textbf{Зменшення степені многочлена ($n = 1024 \to 512$):}
    \begin{itemize}
        \item TiGER використовує половинний $n$ для рівня 1, що зменшує складність множення многочленів з 
            $O(1024^2) \approx 10^6$ до $O(512^2) \approx 2.6 \times 10^5$ операцій (прискорення у $\sim$4x);
        \item Зменшення $n$ також зменшує розміри всіх інших многочленів у $2$ рази;
        \item Безпека не на гіршому рівні за рахунок компенсації -- використання кодів корекції помилок.
    \end{itemize}
    \item \textbf{Зменшення модуля ($q = 2^{20} \to 2^{14}$):}
    \begin{itemize}
        \item Менший $q$ означає менше біт на кожен коефіцієнт многочлена: з 20 до 14 біт;
        \item Як наслідок -- зменшення розмірів всіх компонентів многочленів з $R_q$;
        \item Менший $q$ також прискорює операції модульної арифметики (менші числа).
    \end{itemize}
    \item \textbf{Агресивніша компресія:}
    \begin{itemize}
        \item TiGER застосовує агресивну компресію $k_2 = 4$ біт для $\mathbf{c}_1$ та 1 біт для $\mathbf{c}_2$;
        \item Агресивна компресія збільшує помилки, але TiGER компенсує це знову ж таки через коди корекції 
            помилок.
    \end{itemize}
    \item \textbf{Застосування кодів корекції помилок (XEf + D2):}
    \begin{itemize}
        \item \textit{Ключова інновація TiGER} --- використання двох методів для корекції помилок;
        \item Код XEf виправляє одиночні помилки в блоках по $d = 8$ біт, збільшуючи надійність приблизно в $d$ разів;
        \item Код D2 дублює кожен біт ($f = 2$), дозволяючи додатково виправляти помилки через мажоритарне голосування;
        \item Комбінація дозволяє TiGER використовувати агресивнішу компресію при збереженні дуже низької DFP/R ($2^{-120}$);
        \item В RLizard що того, що того немає.
    \end{itemize}
    \item \textbf{Неявне відхилення (implicit rejection):}
    \begin{itemize}
        \item TiGER використовує FO$^{\not\bot}_m$ варіант з неявним відхиленням: замість повернення $\bot$ при невдалій 
            декапсуляції, повертається псевдовипадковий ключ $\overline{K} = H(z, ct)$ -- захист від failure boosting атак
        \item RLizard використовує стандартний FO варіант з явним відхиленням, що є вразливішим до таких атак.
    \end{itemize}
    \item \textbf{Підвищення безпеки при менших параметрах:}
    \begin{itemize}
        \item Незважаючи на менший $n$ та $q$, TiGER128 має \textit{вищий} Core-SVP $\beta = 483$ порівняно з 
            RLizard $\beta = 450$ -- забезпечення кращої безпеки при значно менших розмірах;
        \item Це досягається через оптимізацію розподілу помилок, вибір ваг Геммінга, та консервативніші оцінки 
            безпеки;
    \end{itemize}
\end{enumerate}

\noindent Це можна підсумувати таблицею:

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Характеристика} & \textbf{RLizard} & \textbf{TiGER128} \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Параметри}}                       \\
        \hline
        Степінь многочлена $n$  & 1024             & 512               \\
        \hline
        Основний модуль $q$     & $2^{20}$         & $2^{14}$          \\
        \hline
        Модуль округлення $p$   & $2^{10}$         & $2^{10}$          \\
        \hline
        Вага секрету $h_s$      & 256              & 274               \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Розміри (байт)}}                  \\
        \hline
        Відкритий ключ $|pk|$   & 1472             & 804               \\
        \hline
        Шифротекст $|ct|$       & 1312             & 804               \\
        \hline
        Секретний ключ $|sk|$   & 1536             & 1876              \\
        \hline
        Загалом                 & 4320             & 3484              \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Безпека та надійність}}           \\
        \hline
        Core-SVP $\beta$        & 450              & 483               \\
        \hline
        DFP/R                   & $2^{-128}$       & $2^{-120}$        \\
        \hline
        Коди корекції помилок   & Немає            & XEf + D2          \\
        \hline
        Implicit rejection      & Відсутнє         & Є                 \\
        \hline
    \end{tabular}
    \caption{Порівняння RLizard та TiGER}
    \label{table:6-1-1}
\end{table}

\subsection*{Практичні наслідки}

Покращення TiGER мають значний практичний сенс:

\begin{itemize}
    \item \textbf{Компактність:} Зменшення $|pk| + |ct|$ на $\sim$35\% робить TiGER ефективнішим для протоколів 
        з обмеженою пропускною здатністю таких як TLS чи IoT;
    \item \textbf{Продуктивність:} Менший $n$ та $q$ прискорюють усі операції: генерацію ключів, шифрування, 
        дешифрування.
    \item \textbf{Надійність:} Коди корекції помилок роблять TiGER більш надійним у реальних умовах, де можливі 
        апаратні помилки;
    \item \textbf{Безпечність:} Implicit rejection та вищий Core-SVP $\beta$ роблять TiGER стійкішим до сучасних 
        атак.
\end{itemize}

\section{TiGER vs Kyber}
\label{sec:6-2}

Kyber (нині стандартизований ML-KEM) є переможцем конкурсу NIST з постквантової криптографії та де-факто слугує 
стандартом для KEM на основі решіток. Порівняння TiGER з Kyber дає розуміння переваг та компромісів обох підходів.

\subsection*{Архітектурні відмінності}

Kyber та TiGER базуються на різних варіантах решіткових задач та мають різне математичне підгрунтя:
\begin{enumerate}
    \item \textbf{MLWE vs RLWE:}
    \begin{itemize}
        \item \textit{Kyber} використовує Module-LWE --- узагальнення алгоритму LWE на вектори многочленів. Це компромісний 
            варіант між стандартним LWE та RLWE;
        \item \textit{TiGER} використовує чистий RLWE/RLWR на одному многочлені з кільцевої структури. Ця структура 
            дозволяє зменшити розміри, але потенційно зменшує запас безпеки;
    \end{itemize}
    \item \textbf{Модуль просте число vs степінь двійки:}
    \begin{itemize}
        \item \textit{Kyber} використовує $q = 3329$ --- спеціально обране просте число виду $q = 1 \bmod 2n$, що 
            дозволяє використовувати NTT;
        \item \textit{TiGER} використовує $q = 2^{14}$, що дозволяє швидкі побітові операції, але унеможливлює NTT 
            (оскільки $2^{14}$ не має примітивних коренів степеня $2n$);
    \end{itemize}
    \item \textbf{RLWR vs RLWE для відкритого ключа:}
    \begin{itemize}
        \item \textit{Kyber} генерує $\mathbf{pk} = \mathbf{A} \cdot \mathbf{s} + \mathbf{e}$ з явною помилкою 
            $\mathbf{e}$;
        \item \textit{TiGER} використовує RLWR: $\mathbf{pk} = \lfloor \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \rceil_{p/q}$ 
            з округленням, що вводить неявну помилку та економить місце (але це усього порядка декількох кілобайт);
    \end{itemize}
    \item \textbf{Секретні ключі:}
    \begin{itemize}
        \item \textit{Kyber} використовує Centered Binomial Distribution (CBD) з параметром $\eta = 3$. Коефіцієнти 
            многочленів беруться з множини $\{-3, -2, -1, 0, 1, 2, 3\}$. Це дає "природний"{} розподіл помилок;
        \item \textit{TiGER} використовує розріджені тернарні многочлени: коефіцієнти з $\{-1, 0, 1\}$, де рівно 
            $h_s = 274$ ненульових коефіцієнтів. Це прискорює множення, але розріджені секрети потенційно більш 
            вразливіші до комбінаторних атак. Необхідний консервативний вибір $h_s$.
    \end{itemize}
\end{enumerate}

Зведемо до таблиці:
\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Характеристика} & \textbf{Kyber512}                                & \textbf{TiGER128}                                                     \\
        \hline
        \hline
        \textbf{Базова проблема}& MLWE (Module-LWE)                                & RLWE + RLWR                                                           \\
                                & Вектори многочленів                              & Один многочлен                                                        \\
        \hline
        \textbf{Розмірність}    & $k = 2$ модулі                                   & $k = 1$ (тільки кільце)                                               \\
                                & $n = 256$ на модуль                              & $n = 512$                                                             \\
        \hline
        \textbf{Модуль $q$}     & 3329 (просте число)                              & $2^{14} = 16384$ (степінь 2)                                          \\
        \hline
        \textbf{Множення}       & NTT (FFT в $\mathbb{Z}_q$)                       & Пряме множення                                                        \\
                                & $O(kn \log n)$                                   & $O(hn)$ (розріджене)                                                  \\
        \hline
        \textbf{Відкритий ключ} & MLWE: $\mathbf{A} \cdot \mathbf{s} + \mathbf{e}$ & RLWR: $\lfloor \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \rceil_{p/q}$ \\
                                & Явна помилка $\mathbf{e}$                        & Округлення замість помилки                                            \\
        \hline
        \textbf{Шифрування}     & MLWE на векторах                                 & RLWE на многочленах                                                   \\
        \hline
        \textbf{Секрети}        & CBD розподіл ($\eta = 3$)                        & Розріджені тернарні                                                   \\
                                & Щільні (всі коеф. $\neq 0$)                      & Вага Геммінга $h_s = 274$                                             \\
        \hline
        \textbf{Коди корекції}  & Немає                                            & XEf + D2                                                              \\
        \hline
        \textbf{FO варіант}     & Стандартний                                      & Implicit rejection                                                    \\
        \hline
    \end{tabular}
    \caption{Архітектурні відмінності Kyber та TiGER}
    \label{table:6-2-1}
\end{table}

\noindent Також порівняємо їхні характеристик згідно (NIST рівень 1)

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Метрика}       & \textbf{Kyber512} & \textbf{TiGER128} \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Безпека}}                         \\
        \hline
        Квантова безпека (біт) & 128               & 128               \\
        \hline
        Core-SVP $\beta$       & 512               & 483               \\
        \hline
        Класична безпека (біт) & 143               & 143               \\
        \hline
        DFP/R                  & $2^{-139}$        & $2^{-120}$        \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Розміри в байтах}}                 \\
        \hline
        Відкритий ключ $|pk|$  & 800               & 804               \\
        \hline
        Шифротекст $|ct|$      & 768               & 804               \\
        \hline
        Секретний ключ $|sk|$  & 1632              & 1876              \\
        \hline
        $|pk| + |ct|$          & 1568              & 1608              \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Продуктивність на x86}}           \\
        \hline
        KeyGen                 & 55K               & 40K               \\
        \hline
        Encaps                 & 75K               & 65K               \\
        \hline
        Decaps                 & 80K               & 70K               \\
        \hline
    \end{tabular}
    \caption{Порівняння Kyber512 та TiGER128 згідно NIST 1}
    \label{table:6-2-2}
\end{table}

\noindent Ми бачимо, що:

\begin{enumerate}
    \item \textbf{По безпеці:}
    \begin{itemize}
        \item Kyber512 має трохи вищий Core-SVP $\beta = 512$ порівняно з TiGER128 ($\beta = 483$). Це дає 
            невеликий запас безпеки $(\sim6\%)$;
        \item Kyber має значно нижчу DFP/R ($2^{-139}$ vs $2^{-120}$), що робить його надійнішим.
    \end{itemize}
    \item \textbf{По пам'яті:}
    \begin{itemize}
        \item TiGER128 має майже однакові розміри з Kyber512: $|pk| + |ct| = 1608$ vs 1568 байт;
        \item Kyber трохи компактніший завдяки використанню модульної структурі MLWE та оптимізованій компресії;
        \item Секретний ключ TiGER більший (+15\%), що є компромісом за зберігання додаткових seed для відновлення 
            секретного ключа та ключа $z$ для implicit rejection;
    \end{itemize}
    \item \textbf{По швидкодії:}
    \begin{itemize}
        \item TiGER показує кращу продуктивність ($\sim$10-27\% швидше), особливо на генерації ключів. Це 
            завдячуючи використанню побітових операцій за модулем $2^{14}$;
        \item Kyber з NTT асимптотично швидший для доволі великих $n$, але для $n = 256$ (Kyber) vs $n = 512$ (TiGER) 
            різниця є невеликою;
    \end{itemize}
\end{enumerate}

\subsection*{Переваги та недоліки}

\textbf{Переваги Kyber:}
\begin{itemize}
    \item \textbf{Стандартизація:} Затверджений NIST як ML-KEM;
    \item \textbf{Консервативність:} MLWE менш структурований за RLWE, вищий Core-SVP $\beta$, нижча DFP/R;
    \item \textbf{Досвід:} Багато оптимізаційних реалізацій (більше років "на сцені"{} алгоритмів);
    \item \textbf{NTT:} Асимптотично швидше множення для великих розмірностей (чесно, ну така собі перевага).
\end{itemize}

\textbf{Переваги TiGER:}
\begin{itemize}
    \item \textbf{Простота:} Відсутність NTT спрощує реалізацію;
    \item \textbf{Ефективність:} Швидші побітові операції з модулем призводять до кращих показників на практиці 
        для малих $n$;
    \item \textbf{Застосування кодів коректування:} Інтеграція XEf + D2 дозволяє агресивніше стискання та 
        підвищує надійність;
    \item \textbf{Implicit rejection:} Додатковий захист від failure boosting атак;
\end{itemize}

\textbf{Недоліки TiGER:}
\begin{itemize}
    \item \textbf{Відсутність стандартизації:} Поки що затверджений NIST;
    \item \textbf{Нижчий $\beta$:} Трохи менший запас безпеки порівняно з Kyber;
    \item \textbf{Вища DFP/R:} $2^{-120}$ vs $2^{-139}$ (по факту змагання "хто ближче до нуля"{}, бо і так це майже нуль);
    \item \textbf{Менш досліджений:} Менше публічних аудитів та оптимізованих реалізацій (дуже молодий алгоритм).
\end{itemize}

Kyber та TiGER представляють різну, так би мовити, філософію реалізації у постквантових KEM. Kyber обирає консервативний 
підхід (MLWE, вищий $\beta$), а TiGER фокусується на практичній ефективності (степені двійки, коди корекції).

\section{TiGER vs Saber}
\label{sec:6-3}

Saber є фіналістом конкурсу NIST, що базується на Module-LWR (Learning With Rounding) -- детермінованому варіанті 
MLWE. Порівняння TiGER з Saber є важливим, оскільки обидва алгоритми використовують округлення (rounding) замість 
використання методу явних помилок.


За концепцією TiGER та Saber є доволі схожими:

\begin{enumerate}
    \item \textbf{LWR підхід:} Обидва використовують округлення для введення т.з. "шуму"{}:
        \begin{itemize}
            \item \textit{Saber:} MLWR на векторах многочленів;
            \item \textit{TiGER:} RLWR на одному многочлені (для відкритого ключа).
        \end{itemize}
    \item \textbf{Модулі степенів двійки:} Обидва використовують $q = 2^k$, що дозволяє ефективні побітові 
        операції для округлення та модульної арифметики.
    \item \textbf{Відсутність NTT:} Жоден з алгоритмів не використовує NTT. Це спрощує реалізацію та знижує 
        складність коду.
    \item \textbf{Компактність:} Обидва досягають малих розмірів ключів порівняно з алгоритмами на основі LWE.
\end{enumerate}

\subsection*{Ключові відмінності}

Незважаючи на схожість у використанні LWR, TiGER та Saber мають і певні архітектурні відмінності:

\begin{enumerate}
    \item \textbf{MLWR vs RLWR:}
    \begin{itemize}
        \item \textit{Saber} використовує чистий MLWR для всього: шифрування і відкритий ключ генерується через MLWR 
            на векторах ($k = 2$ для LightSaber), щось середнє між LWE та RLWE;
        \item \textit{TiGER} комбінує RLWR (для відкритого ключа) та RLWE (для шифрування). Такий гібридний підхід 
            TiGER може бути складним з точки зору аналізу безпеки, але дає більше можливостей для оптимізації 
            окремих параметрів.
    \end{itemize}
    \item \textbf{Модулі та точність округлень:}
    \begin{itemize}
        \item Saber використовує більше біт для кодування повідомлення ($T = 2^4$), що дає більший "запас"{} помилки, 
            але збільшує розмір шифротексту;
        \item TiGER компенсує меншу точність ($T = 2$) використанням кодів корекції помилок.
    \end{itemize}
    \item \textbf{Агресивність компресії:}
    \begin{itemize}
        \item \textit{Saber} використовує помірну компресію з параметрами $\varepsilon_p$ та $\varepsilon_T$. 
            Це дає достатньо бітів про запас для надійного дешифрування;
        \item \textit{TiGER} застосовує дуже агресивну компресію: $k_2 = 4$ біт для $\mathbf{c}_1$ (з оригінальних 
            14 біт) та 1 біт для $\mathbf{c}_2$ (зберігає лише знак). Така агресивна компресія TiGER можлива завдяки 
            використанню корекції помилок XEf + D2.
    \end{itemize}
\end{enumerate}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Характеристика} & \textbf{LightSaber}                                      & \textbf{TiGER128}                                                     \\
        \hline
        \hline
        \textbf{Базова проблема}& MLWR (Module-LWR)                                        & RLWR + RLWE (гібрид)                                                  \\
        \hline
        \textbf{Структура}      & Вектори многочленів                                      & Один многочлен                                                        \\
                                & $k = 2$ модулі, $n = 256$                                & $k = 1$, $n = 512$                                                    \\
        \hline
        \textbf{Модулі}         & $q = 2^{13}$, $p = 2^{10}$                               & $q = 2^{14}$, $p = 2^{10}$                                            \\
                                & $T = 2^4$ (повідомлення)                                 & $T = 2^1$ (повідомлення)                                              \\
        \hline
        \textbf{Відкритий ключ} & MLWR: $\lfloor \mathbf{A} \cdot \mathbf{s} \rceil_{p/q}$ & RLWR: $\lfloor \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \rceil_{p/q}$ \\
                                & Чисте округлення                                         & Округлення + мала помилка                                             \\
        \hline
        \textbf{Шифрування}     & MLWR: $\lfloor \mathbf{A}^T \cdot \mathbf{s}' \rceil$    & RLWE: $\mathbf{a} \cdot \mathbf{e}_1 + \mathbf{e}_2$                  \\
                                & Округлення                                               & Явні помилки                                                          \\
        \hline
        \textbf{Секрети}        & Біноміальний розподіл $\mu = 10$                         & Розріджені тернарні $h_s = 274$                                                                                                    \\
        \hline
        \textbf{Коди корекції}  & Немає                                                    & XEf + D2                                                              \\
        \hline
        \textbf{Компресія}      & Помірна ($\varepsilon_p, \varepsilon_T$)                 & Агресивна ($k_2 = 4$, 1 біт)                                          \\
        \hline
    \end{tabular}
    \caption{Порівняння Saber та TiGER}
    \label{table:6-3-1}
\end{table}

\noindent Порівняємо їхні характеристики згідно першого рівня NIST:

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Метрика}       & \textbf{LightSaber} & \textbf{TiGER128} \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Безпека}}                           \\
        \hline
        Квантова безпека (біт) & 128                 & 128               \\
        \hline
        Core-SVP $\beta$       & 511                 & 483               \\
        \hline
        DFP/R                  & $2^{-136}$          & $2^{-120}$        \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Розміри (байт)}}                    \\
        \hline
        Відкритий ключ $|pk|$  & 672                 & 804               \\
        \hline
        Шифротекст $|ct|$      & 736                 & 804               \\
        \hline
        Секретний ключ $|sk|$  & 1568                & 1876              \\
        \hline
        $|pk| + |ct|$          & 1408                & 1608              \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Особливості}}                       \\
        \hline
        Коди корекції          & Немає               & XEf + D2          \\
        \hline
        Implicit rejection     & Немає               & Є                 \\
        \hline
        Симетричність розмірів & Ні (672/736)        & Так (804/804)     \\
        \hline
    \end{tabular}
    \caption{NIST 1 порівняння LightSaber та TiGER128}
    \label{table:6-3-2}
\end{table}

\noindent Можна спостерігати, що:

\begin{enumerate}[label=\arabic*)]
    \item LightSaber є \textit{найкомпактнішим} серед провідних кандидатів NIST першого рівня. А TiGER на 14\% 
        більший за загальними розмірами $|pk| + |ct|$ (1608 vs 1408 байт).
    \item Обидва мають схожі параметри безпеки, але LightSaber має трохи вищий Core-SVP $\beta$ (+5.5\%) та 
        значно нижчий DFP/R ($2^{-136}$ vs $2^{-120}$). Saber виграє в консервативності параметрів.
    \item Але TiGER має унікальні переваги, такі як:
    \begin{itemize}
        \item \textbf{Коди корекції помилок} роблять TiGER стійкішим до апаратних помилок та fault injection атак;
        \item \textbf{Implicit rejection} забезпечує додатковий захист від failure boosting атак;
        \item \textbf{Симетричність розмірів ключів} ($|pk| = |ct|$) спрощує управління пам'яттю (при реалізації).
    \end{itemize}
    \item А "під капотом"{} обох алгоритмів маємо наступне:
    \begin{itemize}
        \item \textit{Saber} компактність і простота реалізації через застосування чистого MLWR підходу;
        \item \textit{TiGER} жертвує компактністю заради додаткових функцій безпеки та надійності.
    \end{itemize}
\end{enumerate}

Saber та TiGER можна назвати "родичами"{} сім'ї LWR алгоритмів, які мають з різні пріоритети. Для застосувань, де 
критична мінімізація розмірів, Saber має перевагу. Для сценаріїв з високими вимогами до відмовостійкості та захисту 
від fault injection вже TiGER має певні переваги.


\section{TiGER vs SMAUG}
\label{sec:6-4}

SMAUG (Speedy Module-lAttice-based mUltimedia Ghost) є найближчим "родичем"{} для TiGER, оскільки обидва алгоритми 
мають спільну історію розробки та в результаті були об'єднані в єдину специфікацію для участі у фінальному раунді 
конкурсу KpqC. Порівняння TiGER з SMAUG дає глибше розуміння вигоди об'єднання двох підходів.

\subsection*{Історія об'єднання}

TiGER та SMAUG розроблялися незалежно, але з однією ціллю -- створити ефективний KEM на основі RLWE/RLWR з малими 
розмірами (але підвищеною безпекою) та високою продуктивністю:

\begin{itemize}
    \item \textbf{TiGER} (2020): Розроблений як еволюція RLizard, фокус на кодах виправлення помилок та гібридному 
        (RLWE/RLWR) підході;
    \item \textbf{SMAUG} (2021): Розроблений фокусуючись на модульній структурі та оптимізації для мультимедійних 
        застосувань;
    \item \textbf{Об'єднання} (2022): Задля перемоги у конкурсі проєкти об'єдналися, створивши єдину специфікацію 
        "TiGER/SMAUG" та названою SMAUG-T з параметрами обох алгоритмів.
\end{itemize}

\subsection*{Архітектурні схожості та відмінності}

\noindent Ключові спостереження, які можна помітити:

\begin{enumerate}
    \item \textbf{Module vs Ring:}
    \begin{itemize}
        \item \textit{SMAUG} використовує модульну структуру ($k = 2$) аналогічно до Kyber/Saber, що дає 
            консервативніший підхід до безпеки. Цей модульний підхід дозволяє гнучкіще масштабувати безпеку 
            через зміну $k$.
        \item \textit{TiGER} використовує чисту кільцеву структуру ($k = 1$), максимізуючи ефективність та 
            компактність;
    \end{itemize}
    \item \textbf{Коди корекції помилок:}
    \begin{itemize}
        \item \textit{SMAUG} використовує тільки XEf код для корекції одиночних помилок;
        \item \textit{TiGER} додає другий рівень корекції (D2), що дублює біти для додаткової надійності;
        \item Подвійна корекція помилок в TiGER дозволяє використовувати агресивнішу компресію при збереженні 
            низького рівня DFP/R.
    \end{itemize}
    \item \textbf{Розміри модулів:}
    \begin{itemize}
        \item \textit{SMAUG} використовує менші модулі: $q = 2^{11}$, $p = 2^8$ -- вимагають більшої 
            обережності з відслідковуванням "помилок";
        \item В той час як \textit{TiGER} використовує більші модулі: $q = 2^{14}$, $p = 2^{10}$, але компенсує 
            їх через використання чистої кільцевої структури та кодів корекції.
    \end{itemize}
    \item \textbf{Цільове застосування:}
    \begin{itemize}
        \item \textit{SMAUG} оптимізований для мультимедійних застосувань та streaming, де важлива низька латентність;
        \item \textit{TiGER} призначений для широкого використання, де цінується баланс між безпекою, розмірами та 
            швидкодією.
    \end{itemize}
\end{enumerate}

Згребемо це все до компактного табличного вигляду:

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Характеристика}     & \textbf{SMAUG128}          & \textbf{TiGER128}               \\
        \hline
        \hline
        \textbf{Базові алгоритми}   & MLWE + MLWR                & RLWE + RLWR                     \\
                                    & (гібрид на векторах)       & (гібрид на кільці)              \\
        \hline
        \textbf{Структура}          & Module: $k = 2$, $n = 256$ & Ring: $k = 1$, $n = 512$        \\
        \hline
        \textbf{Модулі}             & $q = 2^{11}$, $p = 2^8$    & $q = 2^{14}$, $p = 2^{10}$      \\
        \hline
        \textbf{Секрети}            & Біноміальний розподіл      & Розріджені тернарні             \\
                                    & $\eta = 2$                 & $h_s = 274$                     \\
        \hline
        \textbf{Коди корекції}      & XEf                        & XEf + D2                        \\
        \hline
        \textbf{Компресія}          & Помірна                    & Агресивна                       \\
        \hline
        \textbf{Implicit rejection} & Є                          & Є                               \\
        \hline
        \textbf{Target usage}       & Мультимедіа, streaming     & Загальне застосування(KEM, PKE) \\
        \hline
    \end{tabular}
    \caption{Порівняння SMAUG та TiGER}
    \label{table:6-4-1}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Метрика}       & \textbf{SMAUG128} & \textbf{TiGER128} \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Безпека}}                         \\
        \hline
        Квантова безпека (біт) & 128               & 128               \\
        \hline
        Core-SVP $\beta$       & 492               & 483               \\
        \hline
        DFP/R (орієнтовна)     & $2^{-130}$        & $2^{-120}$        \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\textit{Розміри (байт)}}                  \\
        \hline
        Відкритий ключ $|pk|$  & 672               & 804               \\
        \hline
        Шифротекст $|ct|$      & 800               & 804               \\
        \hline
        $|pk| + |ct|$          & 1472              & 1608              \\
        \hline
    \end{tabular}
    \caption{Числові характеристики SMAUG128 та TiGER128}
    \label{table:6-4-2}
\end{table}

Що можна сказати виходячи з цих цифр? Обидва алгоритми мають дуже близькі параметри безпеки (Core-SVP $\beta$ відрізняється 
лише на 2\%). SMAUG має трохи нижчу DFP/R завдяки консервативнішим параметрам. SMAUG є більш компактним приблизно 
на $\sim$9\%. Це досягається через використання менших модулів та оптимізовану компресію. Також TiGER має перевагу 
через подвійну систему корекції помилок (XEf \& D2), що робить його стійкішим до різних атак та апаратних помилок.

\subsection*{Стратегія об'єднання}

Об'єднана специфікація TiGER/SMAUG (SMAUG-T) включає в себе:

\begin{itemize}
    \item \textbf{Єдина кодова база:} Спільна реалізація базових операцій (множення многочленів, гешування), а 
        також застосування Implicit rejection для обох варіантів, уніфікованих геш-функцій (SHA3-256, SHAKE256) 
        та спільна структура FO перетворення.
    \item \textbf{Акцентування на параметрах та напрямку викорисатання:} Користувач може обирати між TiGER (з акцентом 
        на надійність) або SMAUG (акцент на компактність) залежно від сфери застосування, оскільки TiGER: Ring-based 
        з подвійною корекцією -- для загального використання, в той час як SMAUG: Module-based з одинарною корекцією 
        помилок -- для мультимедіа.
\end{itemize}

\noindent \textbf{Переваги від цього об'єднання} такі:

\begin{enumerate}
    \item В першу чергу це гнучкість. Користувачі можуть обирати оптимальний варіант (зміна параметрів) для 
        конкретного цілього застосування;
    \item Друга перевага -- це "cпільний аудит"{} -- тобто безпека обох алгоритмів аналізується заразом, що 
        підвищує довіру до нього;
    \item По третє -- економія часу розробки, бо спільна кодова база зменшує дублювання зусиль;
    \item І наостанок -- конкурентноспроможність. Об'єднана заявка сильніша через різноманітність у підходах.
\end{enumerate}

Як підсумок вищенаведеного, SMAUG та TiGER є комплементарними підходами в рамках родини RLWE/RLWR алгоритмів. 
Об'єднання двох алгоритмів створює гнучку екосистему, що покриває широкий спектр вимог постквантової криптографії.

\section{Порівняння усіх перелічених алгоритмів}
\label{sec:6-5}

Тут вже зведемо результати і зробимо комплексне порівняння TiGER з провідними постквантовими KEM алгоритмами за 
ключовими характеристиками: безпека, розміри, продуктивність та особливості реалізації, ну загалом як і робили 
до того.

\subsection*{Порівняння безпеки та розмірів:}

Всі дані взято для рівня безпеки NIST 1 (128 біт квантової безпеки).

\begin{enumerate}
    \item Усі алгоритми забезпечують 128-бітну квантову безпеку (рівень NIST 1), але з різними значеннями Core-SVP 
        $\beta$ (block size):
        \begin{itemize}
            \item \textit{Kyber512} та \textit{LightSaber} мають $\beta \approx 510$. Це дає невеликий запас 
                порівняно з пороговим $\beta = 512$ для 128-бітної безпеки;
            \item \textit{TiGER128} має $\beta = 483$, що є нижчим за еталонне значення, але це компенсується 
                більш консервативними оцінками та використанням D2, XEf і implicit rejection.
        \end{itemize}
    \item TiGER128 має конкурентні розміри у порівнянні з іншими та володіє унікальною властивістю -- однакові 
        розміри $|pk|$ та $|ct|$ (обидва 804 байт):
        \begin{itemize}
            \item Відкритий ключ (804 байт) близький до Kyber512 (800 байт) і трохи більший за LightSaber (672 байт);
            \item Шифротекст (804 байт) трохи більший за Kyber512 (768 байт) та LightSaber (736 байт);
        \end{itemize}
\end{enumerate}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|c|c|}
        \hline
        \textbf{Алгоритм}     & \textbf{Core-SVP $\beta$} & \textbf{$|pk|$ (байт)} & \textbf{$|ct|$ (байт)} \\
        \hline
        \hline
        \textbf{Kyber512}     & 512                       & 800                    & 768                    \\
        \hline
        \textbf{LightSaber}   & 511                       & 672                    & 736                    \\
        \hline
        \textbf{TiGER128}     & 483                       & 804                    & 804                    \\
        \hline
    \end{tabular}
    \caption{Порівняння постквантових KEM (рівень NIST 1)}
    \label{table:6-5-1}
\end{table}

Для вищих рівнів безпеки (NIST 3 та NIST 5) TiGER також демонструє конкурентно спроможні характеристики:

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Рівень} & \textbf{Алгоритм} & \textbf{$|pk| + |ct|$ (байт)} & \textbf{Відносна компактність} \\
        \hline
        \hline
        \multirow{3}{*}{\textbf{NIST 1}}
                        & Kyber512          & 1568                          & baseline(certificated)         \\
                        & LightSaber        & 1408                          & \textit{-10\%}                 \\
                        & TiGER128          & 1608                          & \textit{+2.5\%}                \\
        \hline
        \multirow{3}{*}{\textbf{NIST 3}}
                        & Kyber768          & 2400                          & baseline(certificated)         \\
                        & Saber             & 2304                          & \textit{-4\%}                  \\
                        & TiGER192          & 2976                          & \textit{+24\%}                 \\
        \hline
        \multirow{3}{*}{\textbf{NIST 5}}
                        & Kyber1024         & 3168                          & baseline(certificated)         \\
                        & FireSaber         & 3040                          & \textit{-4\%}                  \\
                        & TiGER256          & 3168                          & same                           \\
        \hline
    \end{tabular}
    \caption{Порівняння розмірів для різних рівнів NIST}
    \label{table:6-5-2}
\end{table}

\noindent Можна бачити що: TiGER128 та TiGER256 мають конкурентні розміри порівняно з Kyber та Saber. TiGER192 має 
помітно більші розміри (+24\% порівняно з Kyber768). Це компроміс з вищою надійністю дешифрування (визначається 
по показнику DFP/R);

\subsection*{Узагальнююче порівняння характеристик}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|c|c|}
        \hline
        \textbf{Характеристика} & \textbf{Kyber512} & \textbf{LightSaber} & \textbf{TiGER128} & \textbf{RLizard} \\
        \hline
        \hline
        \multicolumn{5}{|c|}{\textit{Параметри безпеки}}                                                         \\
        \hline
        Core-SVP $\beta$        & 512               & 511                 & 483               & 450              \\
        \hline
        DFP/R                   & $2^{-139}$        & $2^{-136}$          & $2^{-120}$        & $2^{-128}$       \\
        \hline
        \hline
        \multicolumn{5}{|c|}{\textit{Розміри (байт)}}                                                            \\
        \hline
        $|pk|$                  & 800               & 672                 & 804               & 1472             \\
        \hline
        $|ct|$                  & 768               & 736                 & 804               & 1312             \\
        \hline
        $|sk|$                  & 1632              & 1568                & 1876              & 1536             \\
        \hline
        $\Sigma$                & 3200              & 2976                & 3484              & 4320             \\
        \hline
        \hline
        \multicolumn{5}{|c|}{\textit{Особливості}}                                                               \\
        \hline
        Базова проблема         & MLWE              & MLWR                & RLWE+RLWR         & RLWE+RLWR        \\
        \hline
        NTT                     & Так               & Ні                  & Ні                & Ні               \\
        \hline
        Error correction codes  & Ні                & Ні                  & XEf+D2            & Ні               \\
        \hline
        Модулі                  & Простий           & $2^k$               & $2^k$             & $2^k$            \\
        \hline
        Статус                  & Standard NIST     & Фіналіст            & Кандидат          & Попередник       \\
        \hline
    \end{tabular}
    \caption{Комплексне порівняння постквантових KEM (NIST 1)}
    \label{table:6-5-3}
\end{table}

\noindent З таблиці можна бачити, що Kyber є затвердженим NIST як ML-KEM стандарт, що робить його пріоритетним вибором для 
більшості застосувань. А TiGER є єдиним алгоритмом з інтегрованими кодами корекції помилок (XEf+D2), він також 
демонструє конкурентні розміри, близькі до Kyber та Saber, і значно кращі за RLizard та залишається поки лиш цікавою 
альтернативою з унікальними характеристиками у задачах, де наведені його параметри становитимуть вагоме критичне 
значення.

\chapter{\large{Аналіз атак на TiGER}}
\label{chapter:7}

\section{Аналіз слабких місць алгоритму}
\label{sec:7-1}

У цьому розділі ми висвітлимо потенційно слабкі місця алгоритму TiGER та оцінимо їх вплив на експлуатацію загалом.
Хоч TiGER базується на добре вивчених задачах RLWE/RLWR, його окремі реалізації мають свої певні особливості.

\subsection*{1. Атаки на базову задачу RLWE/RLWR}

Решіткові атаки a.k.a. Lattice reduction attack є основним класом атак на RLWE/RLWR, що використовують алгоритми 
BKZ (Block Korkine-Zolotarev) для пошуку shortest вектору у решітці (SVP) та вектору решітки, найближчого до заданої 
точки (CVP).

\noindent \textbf{Побудова решітки:}

Маючи $m$ зразків (пар) RLWE $(\mathbf{a}_i, \, \mathbf{b}_i = \mathbf{a}_i \cdot \mathbf{s} + \mathbf{e}_i)$, 
будуємо решітку розмірності:
\begin{equation*}
    d = n(m + 1) = 512 \cdot 2 = 1024 \quad \MakeWaveComment{для TiGER128 $m = 1$}
\end{equation*}

\noindent \textbf{Цільовий вектор:}

Для розріджених тернарних секретів з вагою Геммінга $h_s = 274$, норма складає:
\begin{equation*}
    \|\mathbf{s}\| = \sqrt{h_s} = \sqrt{274} \approx 16.55
\end{equation*}

Комбінований вектор помилок і секрету:
\begin{equation*}
    \|\mathbf{v}\| = \sqrt{h_e + h_s} = \sqrt{274 + 274} = \sqrt{548} \approx 23.41
\end{equation*}

\noindent \textbf{Необхідний розмір блоку BKZ:}

BKZ (Block Korkine-Zolotarev)~\cite{schnorr1994} є алгоритмом редукції для базису решітки, який послідовно покращує 
базис, роблячи вектори коротшими. Параметр $\beta$ (розмір блоку) визначає якість редукції: більший $\beta$ знаходить 
коротші вектори, але зі значно більшою обчислювальною складністю.

Згідно до Core-SVP, $\beta = 483$ є порогом необхідним для здійснення успішної атаки на TiGER128~\cite{matzov2022}.

\noindent \textbf{Складність:}

Складність BKZ оцінюється за формулами~\cite{albrecht2015}:
\begin{align*}
    \text{Класична:} & \quad 2^{0.292\beta + 16.4} = 2^{0.292 \cdot 483 + 16.4} \approx 2^{157} \text{ операцій} \\
    \text{Квантова:} & \quad 2^{0.265\beta + 16.4} = 2^{0.265 \cdot 483 + 16.4} \approx 2^{144} \text{ операцій}
\end{align*}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Параметр}         & \textbf{Значення}          \\
        \hline
        Розмірність решітки $d$   & 1024                       \\
        Core-SVP $\beta$          & 483                        \\
        Класична складність       & $\approx 2^{157}$ операцій \\
        Квантова складність       & $\approx 2^{144}$ операцій \\
        Класична безпека          & $\approx 143$ біт          \\
        Квантова безпека (NIST 1) & $128$ біт                  \\
        \hline
    \end{tabular}
    \caption{Складність решіткової атаки на TiGER128}
    \label{table:7-1-1}
\end{table}

Як можна бачити, решіткові атаки на RLWE/RLWR, яка лежить в основі TiGER, є практично нездійсненними.

\subsection*{2. Комбінаторні атаки на розріджені секрети}

TiGER використовує розріджені тернарні секрети ($h_s = 274$ ненульових коефіцієнтів з загальної кількості $n = 512$). 
Це потенційно зменшує ентропію порівняно зі щільними секретами (такі, які використовуються в Kyber512).

\noindent \textbf{Простір ключів $\mathcal{S}$:}

Кількість можливих секретних ключів обчислюється як:
\begin{equation*}
    |\mathcal{S}| = \binom{n}{h_s} \cdot 2^{h_s}
\end{equation*}

де $C_{h_s}^{n}$ -- комбінація (вибірка позицій ненульових коефіцієнтів), а $2^{h_s}$ -- вибір знаку ($\pm 1$).

Для нашого TiGER128 маємо:
\begin{equation*}
    |\mathcal{S}| = \binom{512}{274} \cdot 2^{274}
\end{equation*}

Використавши апроксимацію Стірлінга для $n!$ маємо:
\begin{equation*}
    \binom{n}{k} \approx \frac{2^{nH(k/n)}}{\sqrt{2\pi k(1-k/n)}}
\end{equation*}

де $H(p) = -p\log_{2} p - (1-p)\log_{2}(1-p)$ -- бінарна ентропія (binary entropy function).

Ймовірність дорівнює: $p = h_{s}/n = 274/512 \approx 0.535$, тоді
\begin{equation*}
    H(0.535) = -0.535 \log_2(0.535) - 0.465 \log_2(0.465) \approx 0.999
\end{equation*}

Логарифімічна оцінка довжини ключа складає:
\begin{equation*}
    \log_2 |\mathcal{S}| \approx 512 \cdot 0.999 + 274 = 511.5 + 274 = 785.5 \text{ біт}
\end{equation*}

Якщо здійснювати атаку перебором (brutforce), навіть з застосуванням квантового прискоренням Гровера отримуємо:
\begin{equation*}
    \text{Complexity}_{\text{Grover}} = 2^{785.5/2} = 2^{392.75} \gg 2^{128}
\end{equation*}

Як підсумок, простір ключів є достатньо великим, щоб бути стійким до атак перебором.

\subsection*{3. Атаки через помилки округлення (RLWR specific)}

RLWR вводить детерміновану помилку з використанням округлення (див. розділ~\ref{subsec:3-2-5}):
\begin{equation*}
    \mathbf{e}_{\text{rounding}} = \mathbf{a} \cdot \mathbf{s} - \lfloor \mathbf{a} \cdot \mathbf{s} \rceil_{p/q} \cdot \frac{q}{p}
\end{equation*}

Кожен коефіцієнт $\mathbf{e} \in [-\frac{q}{2p}, \frac{q}{2p}]$. Для TiGER:
\begin{equation*}
    \|\mathbf{e}_{\text{rounding}}\|_{\infty} \leq \frac{2^{14}}{2 \cdot 2^{10}} = 8
\end{equation*}

Риторичне питання: Чи може детермінованість може давати додаткову інформацію зловмиснику? Округлення є відомою 
для всіх функцією від секретного $\mathbf{s}$ та публічного $\mathbf{a}$. Проте, без знання $\mathbf{s}$, розподіл 
помилки залишається рівномірним і не дає практичної переваги атакуючому. Редукції з RLWR до RLWE~\cite{bogdanov2016} 
показують, що RLWR не слабший за RLWE при правильному виборі параметрів (див. твердження~\ref{claim:3-2-1}). Отже, 
використання такого округлення не створює практичної вразливості.

\subsection*{4. Атаки на кільцеву структуру алгоритму}

Кільце $R = \mathbb{Z}[x]/(x^{512} + 1)$ має спеціальну структуру. Чи можна її якось експлуатувати, щоб здійснити 
атаку? 

Існують так звані "підкільцеві атаки" (Subfield lattice attacks). Ці атаки працюють, коли кільце має нетривіальні підкільця, що дозволяє редукувати (зменшувати) розмірність решітки. 
Для циклотомічного кільця $\mathbb{Z}[x]/(\Phi_m(x))$, проблеми виникають у тому випадку, якщо $m$ має багато дільників. 
Для TiGER, $m = 2 \cdot 512 = 1024 = 2^{10}$. Хоча $m$ має велику кількість дільників, проте для степенів двійки 
відомі підкільцеві атаки~\cite{cramducas2016} потребують \textit{експоненційної кількості} зразків або 
\textit{мають не кращу складність} за звичайні решіткові атаки при $n \geq 512$. Тобто використання кільцевої 
структури не дає практичної переваги для атаки на TiGER.

\subsection*{5. Side-channel вразливості}

Є три підвиди атак на бічні канали:

\noindent \textbf{Timing атаки:}

\begin{itemize}
    \item \textbf{Помножень на розріджені многочлени:} Множення на многочлен $\mathbf{s}$ займає час $O(h_s \cdot n)$, 
        який може варіюватися, як наслідок -- потенційний витік часу виконання.

        \textit{Захист:} є дуже банальним -- константний час реалізації через використання ключів однакової довжини 
        або dummy операцій (??).
    \item \textbf{Rejection sampling:} Генерація секретів з точною вагою $h_s$ через rejection може привести до витоку 
        інформації про кількість ітерацій.

        \textit{Захист:} Використання seed expansion з постійною кількістю спроб, незалежно від успіху. (отут прикола 
        я не поняв)
\end{itemize}

\noindent \textbf{Power analysis атаки:}

Споживання енергії під час множення многочленів може корелюватися з секретними даними.

Як захист застосовується маскування (masking) першого та другого порядку -- тобто проведення розділення секретних 
даних на випадкові частки.

\noindent \textbf{Fault injection атаки:}

Індукування помилок під час дешифрування може викрити інформацію про секретний ключ через failure boosting.

Використання implicit rejection у TiGER (FO$^{\not\bot}_m$) слугує захистом, оскільки при помилці декапсуляції 
повертається псевдовипадковий ключ замість $\bot$, що унеможливлює відрізнення успішної декапсуляції від невдалої.

Висновок: Side-channel атаки є реальною загрозою, але TiGER має вбудований захисний механізм implicit rejection, 
а також константна реалізація та маскування є необхідним для забезпечення повного захисту.

\subsection*{Підсумкова таблиця по слабких місцях TiGER}

\begin{table}[H]
    \label{table:7-1-2}
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Тип атаки} & \textbf{Складність} & \textbf{Рівень загрози}      & \textbf{Захист}           \\
        \hline
        \hline
        BKZ                & $2^{144}$ (квант.)  & \textcolor{Green4}{Безпечно}  & Достатнє значення $\beta$ \\
        \hline
        Brutforce          & $2^{393}$ (Grover)  & \textcolor{Green4}{Безпечно}  & Large key space           \\
        \hline
        RLWR specific      & ?                   & \textcolor{Green4}{Безпечно}  & Редукція до RLWE          \\
        \hline
        Subfield           & $\geq 2^{144}$      & \textcolor{Green4}{Безпечно}  & $m$ має мало дільників    \\
        \hline
        Timing             & Варіюється          & \textcolor{orange}{Помірний} & Const-time implementation \\
        \hline
        Power analysis     & Варіюється          & \textcolor{orange}{Помірний} & Mask using                \\
        \hline
        Fault injection    & Варіюється          & \textcolor{Green4}{Безпечно}  & Implicit rejection        \\
        \hline
    \end{tabular}
    \centering
    \caption{Слабкі місця TiGER}
\end{table}

\textbf{Загальний висновок:} Як бачимо, TiGER не має критичних математичних вразливостей. Основні його ризики пов'язані 
з side-channel атаками, які потребують обережної реалізації. Його "Cryptographic Core Architecture"{} є стійкою до всіх 
відомих теоретичних атак при заданих оптимальних параметрах.

\section{Можливі вразливості через DFP/R}
\label{sec:7-2}

Decapsulation Failure Probability (DFP) та Decryption Failure Rate (DFR) є критичними параметрами для KEM (Key 
Encapsulation Mechanism) на основі решіток. Навіть дуже мала ймовірність помилки дешифрування може бути використана 
зловмисником для витягування інформації про секретний ключ. Проаналізуємо вразливості через DFP/R та існуючі 
механізми захисту в TiGER.

DFP -- це ймовірність того, що правильно сформований шифротекст декапсулюється некоректно, тобто:
\begin{equation*}
    \text{DFP} = \Pr[\text{Decaps}(sk, \text{Encaps}(pk)) \neq K]
\end{equation*}

\noindent Ця помилка виникає, коли сума помилок від шифрування та компресії перевищує границю, яку зазчивай 
виправляє код корекції. Низька ймовірність DFP є критичною, оскільки дуже мала DFP (від $2^{-30}$ до $2^{-100}$) 
може бути експлуатована зловмисником при \textit{failure boosting} атаці для витягування секретного ключа.

\subsection*{Джерела помилок у TiGER та оцінка DFP для TiGER128}

У алгоритмі TiGER помилки накопичуються з кількох джерел:

\begin{enumerate}
    \item \textbf{Помилки при шифруванні.} В процесі шифрування генеруються навмисні помилки $\mathbf{e}_1, \mathbf{e}_2, \mathbf{e}_3$:
        \begin{equation*}
            \mathbf{c}_1 = \mathbf{a} \cdot \mathbf{e}_1 + \mathbf{e}_2, \quad \mathbf{c}_2 = \mathbf{b} \cdot \mathbf{e}_1 
            + \mathbf{e}_3 + \mathbf{Encode}(\mu)
        \end{equation*}
        Кожна помилка має свою вагу Геммінга $h_e$. Для TiGER128 вони всі однакові: $h_{e_1} = h_{e_2} = h_{e_3} = 274$.
    \item \textbf{Помилки округлення відкритого ключа.} Нагадаємо, що публічний ключ має вигляд:
        \begin{equation*}
                \mathbf{b} = \lfloor \mathbf{a} \cdot \mathbf{s} + \mathbf{r} \rceil_{p/q}
        \end{equation*}
        Округлення вносить неявну помилку:
        \begin{equation*}
                \mathbf{e}_{\text{round}} = (\mathbf{a} \cdot \mathbf{s} + \mathbf{r}) - \mathbf{b} \cdot \frac{q}{p}
        \end{equation*}
        Для TiGER128: $\|\mathbf{e}_{\text{round}}\|_{\infty} \leq \frac{q}{2p} = 8$.
    \item \textbf{Помилки компресії}:
        Шифротекст зазнає стиснення з 14 біт до $k_2 = 4$ біт для $\mathbf{c}_1$ та до $k_3 = 1$ біт (лишається 
        лише знак) для $\mathbf{c}_2$:
        \begin{equation*}
            \mathbf{e}_{\text{comp},1} = \mathbf{c}_1 - \text{Decompress}(\text{Compress}(\mathbf{c}_1, k_2), k_2)
        \end{equation*}
        TiGER використосує рівномірну компресію (uniform compression), розділяючи на рівні інтервали. Довжина 
        кожного інтервалу $q/2^{k}$.Тому помилка компресії має таке верхнє обмеження:
        \begin{equation*}
            \|\mathbf{e}_{\text{comp}}\|_{\infty} \leq \frac{q}{2^{k+1}}
        \end{equation*}
        Чисельні значення є наступними:
        \begin{align*}
            \|\mathbf{e}_{\text{comp},1}\|_{\infty} & \leq \frac{2^{14}}{2^{4+1}} = \frac{16384}{32} = 512 \\
            \|\mathbf{e}_{\text{comp},2}\|_{\infty} & \leq \frac{2^{14}}{2^{1+1}} = \frac{16384}{4} = 4096
        \end{align*}
        \item \textbf{Сумарна помилка при дешифруванні:}
            При дешифруванні обчислюється вектор $\mathbf{v}$:
            \begin{equation*}
                \mathbf{v} = \mathbf{c}_2 - \mathbf{c}_1 \cdot \mathbf{s}
            \end{equation*}
            Сумарна помилка при дешифруванні складатиме:
            \begin{equation*}
                \mathbf{e}_{\text{total}} = \mathbf{r} \cdot \mathbf{e}_1 + \mathbf{e}_{\text{round}} \cdot \mathbf{e}_1 - 
                \mathbf{e}_2 \cdot \mathbf{s} + \mathbf{e}_3 + \mathbf{e}_{\text{comp},1} + \mathbf{e}_{\text{comp},2}
            \end{equation*}
\end{enumerate}

\noindent Кожен член суми $\mathbf{e}_{\text{total}}$ має свій розподіл. Найбільший внесок має $\mathbf{e}_{\text{comp},2}$. 
В TiGER використовуються коди корекції помилок (XEf + D2), які можуть виправити обмежену кількість помилок. Нехай 
цей поріг виправлення складає $\tau$ помилкових біт на один блок.

Припустимо, що після застосування кодів корекції, DFP на один біт (ймовірність помилки для одного біта) дорівнює 
$p_{\text{bit}}$. Для повідомлення довжиною в 256 біт це становитиме:
\begin{equation*}
    \text{DFP} \approx 1 - (1 - p_{\text{bit}})^{256} \approx 256 \cdot p_{\text{bit}} \quad (\text{якщо } p_{\text{bit}} \ll 1)
\end{equation*}

\noindent З специфікації TiGER (заявлена DFP): $\text{DFP}_{\text{TiGER128}} = 2^{-120}$. Це означає буде 1 
failure на $2^{120}$ спроб декапсуляції.

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Алгоритм}   & \textbf{DFP} \\
        \hline
        Kyber512           & $2^{-139}$   \\
        Saber (LightSaber) & $2^{-136}$   \\
        TiGER128           & $2^{-120}$   \\
        SMAUG128           & $2^{-130}$   \\
        \hline
    \end{tabular}
    \caption{Порівняння DFP різних постквантових KEM \\ для рівня NIST 1}
    \label{table:7-2-1}
\end{table}

\noindent TiGER має трохи вищу DFP порівняно з Kyber/Saber, але все ще достатньо низьку для практичного використання.

\subsection*{Failure boosting attack}

Загальна концепція класичного варіанту атаки полягає в тому, що атакуючий може ітеративно створювати спеціально 
підібрані шифротексти з підвищеною ймовірністю failure (замість $2^{-120}$, досягає $2^{-10}$ або більше) та 
спостерігає за відповіддю алгоритму, чи відбудеться помилка. За достатньої кількості спостережень можна витягнути 
інформацію про секретний ключ~\cite{danvers2019failure}, а з використанням статистичних методів реконструювати і 
коефіцієнти секретного ключа. 

Для здобуття (extraction) одного біту інформації про секретний ключ $\mathbf{s}$ потрібно $\approx 1/\text{DFP}_{\text{boosted}}$ 
запитів. Якщо атакуючий може досягти $\text{DFP}_{\text{boosted}} = 2^{-10}$, то для витягування 256 бітного ключа 
необхідно здійснити:
\begin{equation*}
    \text{Queries} \approx 256 \cdot 2^{10} = 2^{18} \approx 262,000 \quad \text{запитів.}
\end{equation*}

Тобто маємо практично здійснену атаку!
Якщо використовується стандартний FO з explicit rejection (див. алгоритм~\ref{subsec:3-6-1}), то 
зловмисник в результаті бачить $\bot$, він знає, що відбулася помилка декапсуляції.

Який захист від цього має TiGER? Він використовує варіант Fujisaki-Okamoto з \textit{implicit rejection} 
(див. алгоритм~\ref{subsec:3-6-2}). Ефект від implicit rejection є наступним:

\begin{itemize}
    \item Атакуючий завжди отримує деякий ключ $K$ ($\overline{K}$ або $K'$), незалежно від того, була помилка 
        чи ні. $K'$ (при успіху) та $\bar{K}$ (при помилці) -- обидва виглядають випадковими;
    \item Атакуючий не може відрізнити успішну декапсуляцію від невдалої без знання секретного $z$ і failure boosting 
        атака стає неможливою, оскільки немає спостережувального сигналу про failure.
\end{itemize}

Implicit rejection забезпечує IND-CCA безпеку навіть за наявності ненульової DFP. Навіть якщо декапсуляція іноді 
помиляється, атакуючий не може це відстежити та використати проти системи. Показник DFP для TiGER складає $2^{-120}$, 
і є достатньо низьким для практичного використання. Але критично важливим є те, що TiGER використовує \textit{implicit rejection}, 
що робить failure boosting атаки практично неможливими. За умови коректної константної реалізації ці вразливості 
через DFP у алгоритмі TiGER можуть бути належним чином мітиговані.

\section{Meet-LWE атака}
\label{sec:7-3}

Meet-in-the-Middle (MitM) атаки є потужним криптоаналітичним інструментом та "грозою"{} для багатьох криптопримітивів. 
У цій секції детально проаналізуємо цю атаку та її застосовність до TiGER.

\subsection*{Концепція Meet-in-the-Middle}

Почнемо одразу з класичного прикладу застосування -- атака на подвійне шифрування.

Нехай $E_k(m)$ -- шифрування повідомлення $m$ ключем $k$. Подвійне шифрування: $c = E_{k_2}(E_{k_1}(m))$. Наївна 
атака (перебір) складатиме $2^{2n}$ операцій для ключів довжини $n$ біт кожен, в той час як MitM атака:

\begin{algorithm}[H]
    \caption{Meet-in-the-Middle атака на подвійне шифрування}
    \begin{algorithmic}[1]
        \State \textbf{Input:} Відоме $(m, c)$, де $c = E_{k_2}(E_{k_1}(m))$
        \State \textbf{Output:} Ключі $(k_1, k_2)$
        \State
        \State \textbf{// Фаза 1: Forward (побудова таблиці)}
        \State Ініціалізувати геш-таблицю $T$
        \For{$k_1 = 0$ \textbf{to} $2^n - 1$}
        \State $v \gets E_{k_1}(m)$
        \State $T[v] \gets k_1$ \Comment{Зберігаємо пару (значення, ключ)}
        \EndFor
        \State
        \State \textbf{// Фаза 2: Backward (пошук колізії)}
        \For{$k_2 = 0$ \textbf{to} $2^n - 1$}
        \State $v \gets D_{k_2}(c)$
        \If{$v \in T$} \Comment{Перевірка наявності в таблиці}
        \State $k_1 \gets T[v]$
        \If{$E_{k_2}(E_{k_1}(m)) = c$} \Comment{Верифікація}
        \State \Return $(k_1, k_2)$
        \EndIf
        \EndIf
        \EndFor
        \State \Return Failure
    \end{algorithmic}
\end{algorithm}

\noindent По складності маємо оцінку: $2^n$ час + $2^n$ пам'ять замість $2^{2n}$ лише часу(!).

\subsection*{Meet-LWE атака: основна ідея}

Alexander May розробив спеціалізований варіант MitM для задачі LWE, відомий як Meet-LWE атака~\cite{may2021}.

\noindent Для задачі LWE маємо:
\begin{equation*}
    \mathbf{b} = \mathbf{A} \cdot \mathbf{s} + \mathbf{e} \pmod{q}
\end{equation*}

\noindent де $\mathbf{s} \in \mathbb{Z}_q^n$ -- секрет, $\mathbf{e}$ -- помилка. Секрет, в свою чергу, розділений 
на дві частини:
\begin{equation*}
    \mathbf{s} = (\mathbf{s}_1, \mathbf{s}_2) \quad \text{де } \, \mathbf{s}_1 \in \mathbb{Z}_q^{n_1}, 
    \mathbf{s}_2 \in \mathbb{Z}_q^{n_2}, \quad n_1 + n_2 = n
\end{equation*}

\noindent \textbf{Складність атаки на TiGER128:}

Для розріджених секретів TiGER з $h_s = 274$, оптимізована версія Meet-LWE має складність:
\begin{align*}
    & \text{Complexity}_{\text{classical}} \approx 2^{0.8 \cdot 274} \approx 2^{219} \\
    & \text{Complexity}_{\text{quantum}} \approx 2^{109.5}
\end{align*}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Тип атаки} & \textbf{Класична} & \textbf{Квантова} \\
        \hline
        Brutforce          & $2^{785}$         & $2^{392}$         \\
        BKZ                & $2^{157}$         & $2^{144}$         \\
        Meet-LWE (оптим.)  & $2^{219}$         & $2^{109.5}$       \\
        \hline
        Цільовий рівень    & $2^{143}$         & $2^{128}$         \\
        \hline
    \end{tabular}
    \caption{Порівняння складності атак на TiGER128}
    \label{table:7-3-1}
\end{table}

\noindent Як бачимо, Meet-LWE має квантову складність $2^{109.5}$, що є нижчою цільового рівня, але з урахуванням 
практичних обмежень на ресурси загроза є обмеженою. TiGER192/256 мають складність $> 2^{190}$ (тут все добре).

\section{CCA атаки на PKE}
\label{sec:7-4}

Атаки з вибраним шифротекстом a.k.a. CCA (Chosen Ciphertext Attack) є одними з найнебезпечніших атак на криптосистеми. 
В 2023 році von Berg та його колеги опублікували роботу, що аналізує CCA атаку на PKE схеми на основі решіток, включаючи 
варіанти наближені до TiGER. Розглянемо нижче ці атаки і як від них захиститися.

\subsection*{CCA безпека}

Завдання атакуючого -- відрізнити шифротекст реального повідомлення від шифротексту випадкового повідомлення. 
Сама атака на основі вибраного шифротексту відбувається за рахунок того, що зловмисник має доступ до:
\begin{enumerate}
    \item \textbf{Оракула шифрування:} -- може отримувати шифротексти довільних повідомлень;
    \item \textbf{Оракула дешифрування:} -- може дешифровувати довільні шифротексти (крім цільового).
\end{enumerate}

\noindent Існують три рівні безпеки (залежно від наявних засобів у зловмисника):
\begin{itemize}
    \item \textbf{IND-CPA} (Indistinguishability under Chosen Plaintext Attack): Атакуючий має доступ лише до 
        оракула шифрування;
    \item \textbf{IND-CCA1} (Non-adaptive CCA): Має обмежений доступ до оракула дешифрування (зазвичай \textit{до} 
        отримання цільового шифротексту);
    \item \textbf{IND-CCA2} (Adaptive CCA): Має необмежений доступ до оракула дешифрування, але не може з його 
        допомогою дешифровувати сам цільовий ШТ.
\end{itemize}

Ця безпека є дуже важливою, бо у таких протоколах як TLS або SSH атакуючий часто може "підсунути"{} серверу модифіковані 
певним чином шифротексти та спостерігати за його реакцією (executing time, error messages). Це дає можливість CCA атак.

\subsection*{Базова PKE схема TiGER та її CPA безпека}

TiGER.PKE (базова схема без FO) була розглянута у розділі~\ref{sec:4-4}. Також навели твердження~\ref{claim:5-1-1}, 
яке стосується оцінки безпеки.

\noindent Класична CCA атака (атака через модифікацію шифротексту) на стандартний PKE виглядає так:

Нехай атакуючий має цільовий шифротекст $(ct_1, ct_2)$ для повідомлення $\mu$ та хоче дізнатися власне $\mu$, маючи 
доступ до оракула дешифрування.

\begin{enumerate}
    \item \textbf{Крок 1:} Створює модифікований шифротекст:
        \begin{equation*}
            ct'_2 = ct_2 + \Delta,
        \end{equation*}
    де $\Delta$ -- невелике відхилення.
    \item \textbf{Крок 2:} Подає $(ct_1, ct'_2)$ до оракула дешифрування і отримує $\mu'$.
    \item \textbf{Крок 3:} Маючи $\mu'$ та знаючи $\Delta$, можна витягнути інформацію про $\mu$ або навіть про 
        секретний ключ $\mathbf{s}$.
\end{enumerate}

\noindent \textbf{Приклад конкретної атаки (bit-flipping attack):}

Якщо $\Delta$ обрано так, що вона впливає лише на один біт декодованого повідомлення, то зловмисник може біт-за-бітом 
витягувати $\mu$:
\begin{equation*}
    \mu'_i = \mu_i \oplus f (\Delta_i, \mathbf{s}), \quad \text{де } f \text{ -- деяка функція.}
\end{equation*}

\noindent Спостерігаючи за зміною $\mu'_i$ для різних $\Delta_i$, можна реконструювати всі біти оригінального 
повідомлення $\mu$.

\subsection*{Атака von Berg на PKE з частковим декодуванням}

У роботі Каспер фон Берга~\cite{vonberg2023} запропоновано більш витончену атаку, що експлоатує \textit{проміжний стан} 
під час дешифрування.

\noindent Сценарій атаки полягає в наступному:

Припустимо, що атакуючий може спостерігати не лише фінальне декодоване повідомлення $\mu'$ (після кодів корекції), 
але й \textit{проміжний результат} $\mathbf{v}_{\text{raw}}$ \textit{до} застосування кодів корекції помилок:
\begin{equation*}
    \mathbf{v}_{\text{raw}} = \mathbf{c}_2 - \mathbf{c}_1 \cdot \mathbf{s}
\end{equation*}

\noindent Саме значення $\mathbf{v}_{\text{raw}}$ містить закодоване оригінальне повідомлення $\mu$ і плюс всі накопичені 
помилки (від RLWE, RLWR та компресії), тобто є лінійною комбінацією коефіцієнтів секретного ключа $\mathbf{s}$.

\noindent \textbf{Ідея атаки:}

\begin{enumerate}
    \item Зловмисник створює шифротекст $(ct_1, ct_2)$ зі спеціально підібраними параметрами 
        ($\mathbf{e}_1, \mathbf{e}_2, \mathbf{e}_3$);
    \item Спостерігає $\mathbf{v}_{\text{raw}}$ через power analysis (різновидність side-channel атаки);
    \item Збираючи багато таких спостережень з різними $ct_1$, будує систему лінійних рівнянь:
        \begin{equation*}
            \mathbf{V} = \mathbf{C}_1 \cdot \mathbf{s} + \mathbf{E},
        \end{equation*}
        де $\mathbf{V}$ -- вектор спостережених $\mathbf{v}_{\text{raw}}$, $\mathbf{E}$ -- вектор помилок;
    \item Розв'язує систему з урахуванням шуму для знаходження $\mathbf{s}$ (використовуючи LWE-solving methods).
\end{enumerate}

\noindent \textbf{Складність атаки:}

За оцінками авторів, для витягування повного $\mathbf{s}$ потрібно:
\begin{equation*}
    \text{Queries} \approx O(n \cdot \log q) \approx 512 \cdot 14 = 7168
\end{equation*}
запитів до оракула "часткового дешифрування"{} (IND-CCA1).

Ця атака потребує доступу до $\mathbf{v}_{\text{raw}}$ і \textit{до} кодів корекції. У реалізації TiGER 
дешифрування повертає лише фінальне $\mu$ після всіх перетворень (проміжні значення не витікають назовні), навіть 
і якщо є side-channel attacks (timing, power), витягнути саме $\mathbf{v}_{\text{raw}}$ дуже складно.

\subsection*{Захист через Fujisaki-Okamoto перетворення}

TiGER використовує \textit{не базову PKE}, а KEM з перетворенням Fujisaki-Okamoto (FO), яке перетворює IND-CPA 
безпечну PKE в IND-CCA2 безпечний KEM (див. розділ ~\ref{subsec:3-6-4}). Це перетворення захищає від CCA атак, бо:
\begin{enumerate}
    \item \textbf{Re-encryption check:} Дешифроване $\mu'$ використовується для повторного шифрування. Якщо 
        результат не збігається з $ct$, значить $ct$ був модифікований атакуючим;
    \item \textbf{Детермінованість:} Шифрування використовує $H'(\mu)$ як seed для помилок, тому одне $\mu$ 
        завжди видає той самий $ct$ (для даного $pk$). Ключ $K = H(\mu)$ повністю визначається повідомленням, 
        тому модифікація $ct$ дає інший $\mu'$ та, відповідно, інший $K'$, що виглядає як випадкове значення 
        для атакуючого.
    \item \textbf{Implicit rejection:} Навіть якщо перевірка провалилася, атакуючий не дізнається про це, оскільки 
        отримує псевдовипадковий $\bar{K}$;
\end{enumerate}

\noindent Існує доведення~\cite{hofheinz2017}, що FO$^{\not\bot}_m$ перетворення забезпечує IND-CCA2 безпеку за умов:
\begin{itemize}
    \item Базова PKE є IND-CPA безпечною;
    \item Геш-функції $H, H'$ моделюються як випадкові оракули (ROM);
    \item DFP/R схеми є достатньо малим значенням.
\end{itemize}
Для TiGER всі ці умови виконуються і TiGER KEM з FO$^{\not\bot}_m$ перетворенням є IND-CCA2 безпечним за умови 
коректної його реалізації. Атаки von Berg на базову PKE не застосовні до повної схеми KEM. Основні ризики 
пов'язані з side-channel атаками, які потребують обережної імплементації з константним часом та маскуванням.
Незважаючи на застосування модифікованого FO перетворення, деякі практичні атаки все ще можливі:

\newpage % FORCED
\begin{table}[H]
    \centering
    \begin{tblr}{
            colspec = {| Q[l, m] | X[l, m] | X[l, m] |},
            vlines,
            row{1} = {c},
        }
        \hline
        \textbf{Вектор атаки}          & \textbf{Підґрунтя атаки}                 & \textbf{Захист у TiGER}                                     \\
        \hline
        Модифікація $ct$               & Відсутність перевірки цілісності         & Re-encryption check                                         \\
        \hline
        Failure boosting               & Помилки декапсуляції                     & Implicit rejection                                          \\
        \hline
        Timing side-channel            & Різний час обробки для різних $ct$       & Const-time реалізація                                       \\
        \hline
        Fault injection                & Індукування помилок під час дешифрування & Використання кодів корекції, FO$^{\not\bot}_m$ перетворення \\
        \hline
        Leak $\mathbf{v}_{\text{raw}}$ & Power/EM side-channel                    & Masking                                                     \\
        \hline
    \end{tblr}
    \caption{CCA вектори атак на TiGER KEM}
    \label{table:7-4-1}
\end{table}

Як бачимо по таблиці, алгоритм математично доволі добре захищений від атак, інше -- залежить від програмної реалізації.

\chapter{\large{Практичне застосування та висновки}}
\label{chapter:8}

8.1 Можливі сценарії використання TiGER (TLS, VPN, messaging) \\
8.2 Підсумки дослідження \\
8.3 Перспективи розвитку постквантової криптографії \\

% TODO: Заповнити розділ

\chapter{\large{Результати власної реалізації}}
\label{chapter:9}

% TODO: Заповнити розділ
