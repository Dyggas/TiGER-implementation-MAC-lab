\chapter{\large{Вступне слово}}
\label{chapter:1}

\textbf{Мета роботи} (власне, для чого ми тут зібралися):

Дослідити особливостей реалізації сучасних алгебраїчних криптосистем на прикладі учасників першого раунду
національного конкурсу з постквантової криптографії в Кореї (KpqC).

\noindent \textbf{Наші задачі на комп'ютерний практикум та порядок їх виконання:}
\begin{enumerate}[label=\arabic*)]
    \item Роздітися на бригади. Визначили хто за що відповідатиме. Богдан -- займається реалізацією алгоритму TiGER,
          Олексій -- теоретичною частиною і звітом загалом.
    \item Провести теоретичне дослідження теми, надавши вичерпний та повний опис теоретичної сторони алгоритму з усіма
          деталями та відомими результатами досліджень; провести аналіз вже існуючих атак на алгоритм TiGER, а також
          загалом можливих атак; виконати порівняльний аналіз нашого алгоритму зi схожими та дослідити можливість
          перенесення та застосування відомих атак на нього.
    \item Реалізувати алгоритм програмно та всі(нє, ну ми постараємося) можливі варіанти цього алгоритму;
    \item Перевірити коректність -- підтвердити правильність реалізації за допомогою тестів, використавши тестові
          дані з офіційної реалізації;
    \item Зробити аналіз продуктивності алгоритму та, знову ж таки, провести порівняння та аналіз швидкодії за різних
          умов, дослідити вплив модифікацій окремих його складових частин на ефективність.
\end{enumerate}

\chapter{\large{Загальне теоретичне дослідження}}
\label{chapter:2}
\section{Постквантова криптографія}
\label{sec:2-1}

Сучасна криптографія з відкритим ключем, зокрема RSA та криптографія на еліптичних кривих -- Elliptic Curve
Cryptography (ECC), базується на обчислювальній складності задач факторизації великих чисел та дискретного логарифмування.
Однак у 1994 році Пітер Шор~\cite{shor1994} продемонстрував квантові алгоритми, здатні розв'язувати ці задачі за
поліноміальний час на достатньо потужному квантовому комп'ютері. Це створює критичну загрозу для існуючої криптографічної
інфраструктури.

Постквантова криптографія (Post-Quantum Cryptography, PQC) -- це галузь криптографії, що розробляє алгоритми, стійкі
як до класичних, так і до квантових атак. Серед основних напрямків PQC виділяють криптографію на решітках, криптографію
на кодах виправлення помилок, багатовимірну поліноміальну(квадратичну) криптографію та криптографію на основі
геш-функцій~\cite{WikiPQC}.

\section{Передумови створення TiGER}
\label{sec:2-2}

Механізм інкапсуляції ключа (Key Encapsulation Mechanism, KEM) є одним з найважливіших криптографічних примітивів для
захищеного обміну ключами. У контексті заміни класичних протоколів, таких як Diffie-Hellman (DH) або Elliptic Curve
Diffie-Hellman ECDH, постквантові KEM повинні забезпечувати не лише високий рівень безпеки, але й бути ефективними за
розміром даних та залишатися обчислювано складними для зламу зловмисником.

Криптографія на решітках, зокрема алгоритми на основі задач Learning With Errors (LWE)~\cite{regev2005} та Ring Learning
With Errors (RLWE)~\cite{lyubashevsky2010}, продемонструвала перспективність у створенні ефективних постквантових
схем. Розвиток цього напрямку призвів до появи сімейства алгоритмів, що використовують детермінований варіант --
Learning With Rounding (LWR)~\cite{banerjee2012}, який замінює випадкову помилку округленням, що покращує як
продуктивність, так і довжину шифротексту.

Серед попередніх розробок слід відзначити алгоритми Lizard~\cite{lizard2018} та RLizard~\cite{rlizard2018}, які
комбінували RLWE для генерації ключів з RLWR для шифрування, досягаючи балансу між безпекою та ефективністю. Однак
ці схеми мали певні обмеження щодо розміру відкритого ключа та шифротексту, що ускладнювало їх інтеграцію в існуючі протоколи.

TiGER (Tiny bandwidth key encapsulation mechanism for easy miGration based on RLWE(R))~\cite{tiger2022} був розроблений
командою дослідників з метою створення компактного та ефективного KEM, придатного для легкої інтеграції в існуючі системи
безпеки. Основні задачі, які ставили перед собою науковці це:

\begin{itemize}
    \item \textbf{Мінімізація розміру шифротексту та відкритого ключа}
    \item \textbf{Висока обчислювальна ефективність} --- використання в якості модуля число, яке є степенем двійки ($q = 2^{k}$)
          (для оптимізації операцій округлення через побітові зсуви);
    \item \textbf{Відмова від NTT} --- алгоритм не використовує Number Theoretic Transform, що спрощує реалізацію;
    \item \textbf{Використання розріджених секретів (з малою вагою Гемінга)} --- зменшення розміру секретного ключа та прискорення
          множення многочленів;
    \item \textbf{Корекція помилок} --- застосування кодів XEf та D2 для зниження ймовірності помилки дешифрування.
\end{itemize}

Конструкція TiGER базується на комбінації RLWR для генерації відкритого ключа та RLWE для шифрування, з подальшим застосуванням перетворення Fujisaki-Okamoto~\cite{fo1999, fo2013} для досягнення IND-CCA безпеки.

\section{Участь у KpqC та злиття з SMAUG}
\label{sec:2-3}

У 2022 році Національна служба розвідки Республіки Корея ініціювала Korean Post-Quantum Cryptography Competition
скорочено -- KpqC~\cite{kpqc2023}. Це національний конкурс для стандартизації постквантових криптографічних алгоритмів.

Обраний нами для аналізу алгоритм TiGER був поданий на перший раунд конкурсу KpqC у категорії механізмів інкапсуляції
ключа (KEM) і був одним з чотирьох алгоритмів, які пройшли до другого раунду.

\subsection{Злиття TiGER та SMAUG}
Команди TiGER та SMAUG об'єдналися для створення спільного алгоритму SMAUG-T~\cite{smaugt2024}. Метою злиття було
поєднання переваг обох підходів:

\begin{itemize}
    \item Від \textbf{TiGER}: Компактність шифротексту, використання RLWE/RLWR на кільцевому рівні, корекція помилок
          через D2 кодування (для параметра TiMER);
    \item Від \textbf{SMAUG}: Модульна структура (MLWE/MLWR), розріджені секрети через використання гаусівського
          шуму, покращена безпека за рахунок збільшення розмірності.
\end{itemize}

Результатом злиття став алгоритм SMAUG-T версії 3.0 (лютий 2024), який включає в себе:
\begin{itemize}
    \item Три основні набори параметрів: \textbf{SMAUG-T128}, \textbf{SMAUG-T192}, \textbf{SMAUG-T256}
          (відповідають рівням безпеки NIST 1, 3, 5);
    \item Додатковий набір параметрів \textbf{TiMER} (Tiny SMAUG using Error Reconciliation) -- оптимізований для
          IoT(Internet of Thing)-пристроїв з мінімальним шифротекстом завдяки використанню D2 кодування з TiGER.
\end{itemize}

\subsection{Результати KpqC 2023}

У січні 2025 року було оголошено фінальні результаті конкурсу KpqC. Переможцями стали:
\begin{itemize}
    \item У категорії KEM: \textbf{SMAUG-T} та \textbf{NTRU+};
    \item У категорії цифрового підпису: \textbf{HAETAE} (до речі, також від команди SMAUG).
\end{itemize}

Таким чином, ідеї та технології TiGER увійшли до складу національного стандарту постквантової криптографії Кореї
через алгоритм SMAUG-T.

\chapter{\large{Теоретична база алгоритму TiGER}}
\label{chapter:3}

\section{Алгебраїчні структури}
\label{sec:3-1}
Критографія на решітках (Lattice-based cryptography) використовує алгебраїчні структури для забезпечення ефективності
обчислень та компактності представлення даних. У цьому розділі я розпишу основні алгебраїчні об'єкти, що застосовуються
в алгоритмі TiGER.

\subsection{Кільця та многочлени}
\label{subsec:3-1-1}

\begin{definition}[Кільце]
    \label{def:3-1-1}
    ~\par Кільце $(R, +, \cdot)$ -- це множина з двома операціями: додавання $(+)$ та множення $(\cdot)$, що задовольняє
    наступні властивості:
    \begin{enumerate}
        \item $(R, +)$ є абелевою групою за додаванням. Нейтральний елемент $0$;
        \item Множення є асоціативним: $(a \cdot b) \cdot c = a \cdot (b \cdot c)$, $\forall \, a, b, c \in R$;
        \item Дистрибутивність: $a \cdot (b + c) = a \cdot b + a \cdot c$ та $(b + c) \cdot a = b \cdot a + c \cdot a$,
              $\forall \, a, b, c \in R$;
        \item Існує нейтральний елемент за множенням: $1 \in R$ такий, що $1 \cdot a = a \cdot 1 = a$, $\forall\, a \in R$.
    \end{enumerate}
    Якщо ще $a \cdot b = b \cdot a$, $\forall \, a, b \in R$, то таке кільце називається \textit{комутативним}.
\end{definition}

\begin{definition}[Кільце многочленів]
    \label{def:3-1-2}
    ~\par Нехай $R$ -- комутативне кільце з одиницею. Кільце многочленів $R[x]$ складається з усіх виразів виду
    \begin{equation*}
        f(x) = a_{n} x^{n} + a_{n-1} x^{n-1} + \ldots + a_{1} x + a_{0},
    \end{equation*}
    де $\forall \, i : a_{i} \in \mathbb{R}$, $a_{n} \neq 0$ та $n \in \mathbb{Z}$.

    Число $n$ називається \textit{степенем} многочлена $f(x)$, позначається $\deg(f)$.
\end{definition}

Операції додавання та множення многочленів наступним чином:
\begin{itemize}
    \item $(f + g)(x) = \sum\limits_{i=0}^{\max(\deg(f), \deg(g))} (a_i + b_i) x^i$, де $a_i, b_i$ -- коефіцієнти $f$ та $g$ відповідно;
    \item $(f \cdot g)(x) = \sum\limits_{k=0}^{\deg(f) + \deg(g)} c_k x^k$, де $c_k = \sum\limits_{i=0}^{k} a_i b_{k-i}$.
\end{itemize}

\subsection{Факторкільця многочленів}
\label{subsec:3-1-2}

\begin{definition}[Факторкільце]
    \label{def:3-1-3}
    ~\par Нехай $R$ -- кільце та $I$ -- його ідеал. Факторкільце $R/I$ складається з класів еквівалентності
    $a + I = \{a + r : r \in I\}$ для $a \in R$, з операціями:
    \begin{equation*}
        (a + I) + (b + I) = (a + b) + I, \quad (a + I) \cdot (b + I) = (a \cdot b) + I.
    \end{equation*}
\end{definition}

\noindent У Lattice-based cryptography найчастіше використовується факторкільце многочленів за ідеалом, що породжений
циклотомічним многочленом.

\begin{definition}[Циклотомічний многочлен]
    \label{def:3-1-4}
    ~\par $n$-ий циклотомічний многочлен (Cyclotomic polynomial) $\Phi_n(x)$ визначається як мінімальний многочлен над $\mathbb{Q}$, коренями
    якого є примітивні корені $n$-го степеня з одиниці:
    \begin{equation*}
        \Phi_n(x) = \prod_{\substack{1 \leq k \leq n \\ \gcd(k, n) = 1}} \left(x - e^{2\pi i k / n}\right).
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{lemma:3-1-1}
    Для $n = 2^k$, де $k \in \mathbb{N}$, циклотомічний многочлен має вигляд:
    \begin{equation*}
        \Phi_n(x) = x^{n/2} + 1.
    \end{equation*}
\end{lemma}

\begin{proof}
    При $n = 2^k$ примітивними коренями $n$-го степеня з одиниці є $e^{2\pi i m / n}$ для непарних $m$. З
    $(x^{n/2} + 1) = (x^n - 1)/(x^{n/2} - 1)$ випливає твердження леми.
\end{proof}

\subsection{Кільце многочленів у TiGER}
\label{subsec:3-1-3}

В алгоритмі TiGER використовується кільце многочленів виду:
\begin{equation*}
    \label{eq:3-1-1}
    R_q = \frac{\mathbb{Z}_q[x]}{(x^n + 1)},
\end{equation*}
де $n$ -- степінь двійки (зазвичай $n = 512$ або $n = 1024$), а $q$ -- модуль, що також є степенем двійки
($q = 256$ у всіх варіаціях алгоритму TiGER).

Елементами $R_q$ є многочлени степеня не вище $n-1$ з коефіцієнтами з $\mathbb{Z}_q$:
\begin{equation*}
    f(x) = \sum\limits_{i=0}^{n-1} a_i x^i, \quad a_i \in \mathbb{Z}_q.
\end{equation*}

Вибір саме такого $n$ та многочлена $x^n + 1$ забезпечує:
\begin{itemize}
    \item Ефективність множення многочленів (без потреби в NTT);
    \item Редукцію за модулем $x^n + 1$, що спрощує обчислення;
    \item Зв'язок з циклотомічними многочленами та решітковими задачами.
\end{itemize}

\subsection{Операції в кільці \texorpdfstring{$R_q$}{ring Q}}
\label{subsec:3-1-4}

Для $f(x), g(x) \in R_q$ операції в кільці визначаються наступним чином:

\textbf{Додавання:} покоефіцієнтне за модулем $q$:
\begin{equation*}
    (f + g)(x) = \sum_{i=0}^{n-1} ((f_i + g_i) \bmod q) x^i.
\end{equation*}

\textbf{Множення:} спочатку виконується звичайне множення многочленів, потім взяття за модулем $(x^n + 1)$ та $q$.
Оскільки $x^n \equiv -1 \pmod{x^n + 1}$, то маємо:
\begin{equation*}
    \label{eq:3-1-2}
    h_i = \left(\sum_{j=0}^{i} f_j g_{i-j} - \sum_{j=i+1}^{n-1} f_j g_{n+i-j}\right) \bmod q,
\end{equation*}
де $h(x) = (f \cdot g)(x) = \sum_{i=0}^{n-1} h_i x^i$.

\section{Задачі на решітках}
\label{sec:3-2}

Безпека TiGER базується на обчислювальній складності певних задач на решітках. У цьому підпункті зазначимо основні
решіткові задачі, що лежать в основі постквантової криптографії.

\subsection{Решітки та базові задачі}
\label{subsec:3-2-1}

\begin{definition}[Решітка]
    \label{def:3-2-1}
    ~\par Нехай $\mathbf{b}_1, \mathbf{b}_2, \ldots, \mathbf{b}_m \in \mathbb{R}^n$ -- лінійно незалежні вектори.
    Решітка $\Lambda$, породжена цими векторами, визначається як:
    \begin{equation*}
        \Lambda = \Lambda(\mathbf{b}_1, \ldots, \mathbf{b}_m) = \left\{ \sum_{i=1}^{m} a_i \mathbf{b}_i : a_i \in \mathbb{Z} \right\}.
    \end{equation*}
    Вектори $\mathbf{b}_1, \ldots, \mathbf{b}_m$ називаються базисом решітки, а $m$ -- розмірністю решітки.
\end{definition}

\begin{definition}[Мінімальна відстань решітки(shortest vector)]
    \label{def:3-2-2}
    ~\par Мінімальна відстань решітки $\Lambda$ визначається як:
    \begin{equation*}
        \lambda_1(\Lambda) = \min_{\mathbf{v} \in \Lambda \setminus \{\mathbf{0}\}} \|\mathbf{v}\|,
    \end{equation*}
    де $\|\cdot\|$ -- евклідова норма.
\end{definition}

\begin{definition}[SVP]
    \label{def:3-2-3}
    ~\par \textit{Shortest Vector Problem (SVP):} Для заданого базису решітки $\Lambda$ знайти ненульовий вектор
    $\mathbf{v} \in \Lambda$ такий, що $\|\mathbf{v}\| = \lambda_1(\Lambda)$.
\end{definition}

\noindent SVP є NP-складною задачею~\cite{ajtai1998}. Для криптографічних цілей часто використовується наступна версія:

\begin{definition}[Апроксимаційна задача SVP]
    \label{def:3-2-4}
    ~\par \textit{$\gamma$-approximate SVP ($\gamma$-SVP):} Для заданого базису решітки $\Lambda$ та параметра
    наближення $\gamma \geq 1$, знайти ненульовий вектор $\mathbf{v} \in \Lambda$ такий, що
    $\|\mathbf{v}\| \leq \gamma \cdot \lambda_1(\Lambda)$.
\end{definition}

\subsection{Задача Learning With Errors (LWE)}
\label{subsec:3-2-2}

Задача Learning With Errors була введена Одедом Регєвим у 2005 році~\cite{regev2005} і стала основою для багатьох
постквантових криптосистем.

\begin{definition}[LWE задача (search version)]
    \label{def:3-2-5}
    ~\par Нехай $n, q \geq 1$ -- цілі числа, $\chi$ -- розподіл ймовірностей на $\mathbb{Z}_q$. Пошукова задача
    $\text{LWE}_{n,q,\chi}$ визначається наступним чином:

    Для невідомого секрету $\mathbf{s} \in \mathbb{Z}_q^n$ та заданої послідовності пар $(\mathbf{a}_i, b_i) \in \mathbb{Z}_q^n \times \mathbb{Z}_q$,
    де
    \begin{equation*}
        b_i = \langle \mathbf{a}_i, \mathbf{s} \rangle + e_i \pmod{q},
    \end{equation*}
    з випадково обраними $\mathbf{a}_i \in \mathbb{Z}_q^n$, $\langle \cdot, \cdot \rangle$ -- операція векторного
    добутку та $e_i \xleftarrow{p} \chi$, знайти секрет $\mathbf{s}$.
\end{definition}

\begin{definition}[LWE задача (detection version)]
    \label{def:3-2-6}
    ~\par Розпізнавальна задача $\text{Decision-LWE}_{n,q,\chi}$ полягає у розрізненні наступних двох розподілів:
    \begin{itemize}
        \item $(\mathbf{a}, \langle \mathbf{a}, \mathbf{s} \rangle + e \bmod q)$, де 
            $\mathbf{a} \leftarrow \mathbb{Z}_q^n$, $\mathbf{s} \in \mathbb{Z}_q^n$ фіксоване, 
            $e \xleftarrow{p} \chi$;
        \item $(\mathbf{a}, u)$, де $\mathbf{a}, u$ -- рівноймовірно розподілені на $\mathbb{Z}_q^n$ та $\mathbb{Z}_q$ відповідно.
    \end{itemize}
\end{definition}

\begin{theorem}[Регєва]
    \label{theorem:3-2-1}
    ~\par Для певних параметрів $n, q, \chi$, розв'язання задачі Decision-LWE за поліноміальний час у середньому
    випадку еквівалентно розв'язанню наближеної задачі $\gamma$-SVP за квантовий поліноміальний час у найгіршому
    випадку для деякого $\gamma = \tilde{O}(n/\sigma)$.
\end{theorem}

\subsection{Задача Ring Learning With Errors (RLWE)}
\label{subsec:3-2-3}

Ring-LWE є алгебраїчною версією LWE, що вже використовує кільця многочленів для більшої
ефективності~\cite{lyubashevsky2010}.

\begin{definition}[RLWE задача]
    \label{def:3-2-7}
    ~\par Нехай $R = \mathbb{Z}[x]/(x^n + 1)$, $R_q = \mathbb{Z}_q[x]/(x^n + 1)$, та $\chi$ -- розподіл ймовірностей
    на $R_q$. Розпізнавальна задача $\text{Decision-RLWE}_{n,q,\chi}$ полягає у розрізненні наступних розподілів:
    \begin{itemize}
        \item $(a, a \cdot s + e)$, де обрано $a \in R_q$ (рівномірний розподіл), $s \in R_q$ фіксоване, $e \xleftarrow{p} \chi$;
        \item $(a, u)$, де $a, u$ обрані рівномірно з $R_q$.
    \end{itemize}
\end{definition}

Важливим є те, що RLWE дозволяє представляти $n$ секретів (LWE-зразків) у вигляді одного многочлена в $R_q$, що
значно зменшує розмір ключів та шифротекстів. Для TiGER використовується $n \in \{512, 1024\}$ та $q = 256$.

\subsection{Задача Learning With Rounding (LWR)}
\label{subsec:3-2-4}

Learning With Rounding є детермінованим варіантом LWE, де замість додавання випадкової помилки використовується
округлення~\cite{banerjee2012}.

\begin{definition}[LWR задача]
    \label{def:3-2-8}
    ~\par Нехай $n, q, p$ -- цілі числа, $p < q$. Визначимо функцію округлення $\lfloor \cdot \rceil_p : \mathbb{Z}_q \to \mathbb{Z}_p$ як
    \begin{equation*}
        \lfloor x \rceil_p = \left\lfloor \frac{p}{q} \cdot x \right\rceil \bmod p,
    \end{equation*}
    де $\lfloor \cdot \rceil$ позначатиме округлення до найближчого цілого.

    Розпізнавальна задача $\text{Decision-LWR}_{n,q,p}$ полягає у розрізненні наступних розподілів:
    \begin{itemize}
        \item $(\mathbf{a}, \lfloor \langle \mathbf{a}, \mathbf{s} \rangle \rceil_p)$, де
              $\mathbf{a} \leftarrow \mathbb{Z}_q^n$, $\mathbf{s} \in \mathbb{Z}_q^n$ -- фіксоване;
        \item $(\mathbf{a}, u)$, де $\mathbf{a} \leftarrow \mathbb{Z}_q^n$, $u \leftarrow \mathbb{Z}_p$.
    \end{itemize}
\end{definition}

\begin{theorem}[Редукція (взяття за модулем) LWR до LWE~\cite{banerjee2012}]
    \label{theorem:3-2-2}
    Для відповідних параметрів $n, q, p$ та достатньо малого розподілу помилок $\chi$, задача Decision-LWR$_{n,q,p}$
    зводиться до задачі Decision-LWE$_{n,q,\chi}$.
\end{theorem}

\begin{remark}
    (Ідея теореми) При достатньо великому відношенні $q/p$, округлення $\lfloor \langle \mathbf{a}, \mathbf{s} \rangle \rceil_p$
    стає еквівалентно до додавання малої помилки округлення, яка розподілена майже рівномірно на інтервалі $(-q/(2p), q/(2p)]$.
\end{remark}

\subsection{Задача Ring Learning With Rounding (RLWR)}
\label{subsec:3-2-5}

RLWR поєднує переваги RLWE (компактність -- за рахунок алгебраїчної структури) та LWR (детермінованість,
та відсутність потреби у відборі помилок(sampling)).

\begin{definition}[RLWR задача]
    \label{def:3-2-9}
    ~\par Нехай $R_q = \mathbb{Z}_q[x]/(x^n + 1)$, $R_p = \mathbb{Z}_p[x]/(x^n + 1)$, де $p < q$. Функція округлення
    застосовуються для кожного коефіцієнта окремо:
    \begin{equation*}
        \lfloor f \rceil_p = \sum\limits_{i=0}^{n-1} \left\lfloor \frac{p}{q} \cdot f_i \right\rceil x^i \bmod p.
    \end{equation*}

    Розпізнавальна задача $\text{Decision-RLWR}_{n,q,p}$ полягає у розрізненні:
    \begin{itemize}
        \item $(a, \lfloor a \cdot s \rceil_p)$, де $a \in R_q$ обрано рівномірно, $s \in R_q$ фіксоване;
        \item $(a, u)$, де $a \in R_q$, $u \in R_p$ обрані рівномірно.
    \end{itemize}
\end{definition}

\begin{claim}
    \label{claim:3-2-1}
    ~\par При певних параметрах $n,q,p$, задача RLWR$_{n,q,p}$ є не легшою за задачу RLWE$_{n,q,\chi}$ з розподілом помилок
    $\chi$, що відповідає помилці округлення.
\end{claim}

У TiGER використовується комбінація: RLWR -- для генерації відкритого ключа (компактність) та RLWE -- для шифрування
(гнучкості у контролі помилок). Модулі обираються як степені двійки: $q = 256$, $p \in \{64, 128\}$, що дозволяє
реалізувати округлення через побітові зсуви. Про це поговоримо детальніше наступному,~\ref{chapter:4} розділі.

\section{"Сімейство"{} алгоритмів на базі RLWE/RLWR}
\label{sec:3-3}

TiGER належить до сімейства алгоритмів на решітках, які базуються на задачах RLWE та RLWR. Опишемо основні алгоритми
цього сімейства, які вплинули на дизайн TiGER (далі). Далі їх буде порівняно у розділі~\ref{chapter:6} та попередньо
у таблиці~\ref{table:3-3-1}.

\subsection{Lizard}
\label{subsec:3-3-1}

Lizard~\cite{lizard2018} був одним з перших алгоритмів, що комбінував у собі LWE та LWR для досягнення балансу між
безпекою та ефективністю.

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} LWE для генерації відкритого ключа, LWR для шифрування;
    \item \textbf{Простір:} Цілочисельні решітки над $\mathbb{Z}_q^n$ без використання кільцевої структури;
    \item \textbf{Модуль:} Малий модуль $q$ для покращення коректності;
    \item \textbf{Розміри:} Великі ключі (через відсутність алгебраїчної структури).
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Консервативна безпека (базується на стандартній LWE);
    \item Низька ймовірність помилки дешифрування.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Великі розміри ключів та шифротекстів;
    \item Повільніше множення векторів (порівняно з кільцевими варіантами).
\end{itemize}

\subsection{RLizard}
\label{subsec:3-3-2}

RLizard~\cite{rlizard2018} є кільцевою версією попереднього алгоритму, оптимізованою для IoT-пристроїв.

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} RLWE для генерації ключів, RLWR для шифрування;
    \item \textbf{Простір:} $R_q = \mathbb{Z}_q[x]/(x^n + 1)$, $n = 512$ або $n = 1024$;
    \item \textbf{Модуль:} Малий модуль $q$ (наприклад, $q = 1024$);
    \item \textbf{Помилки:} Дискретний гаусівський розподіл помилок з високою точністю (CDT-sampling).
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Компактні ключі та шифротексти завдяки кільцевій структурі;
    \item Швидке шифрування/дешифрування;
    \item Висока коректність;
    \item Підходить для пристроїв з обмеженим ресурсом.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Відносно велика пропускна здатність порівняно з найкомпактнішими схемами;
    \item Залежність від якісного(справді випадкового) семплювання гаусівських помилок.
\end{itemize}

\subsection{CRYSTALS-Kyber}
\label{subsec:3-3-3}

Kyber~\cite{kyber2018} є одним з фіналістів конкурсу NIST PQC і базується на Module-LWE (MLWE).

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} MLWE для обох операцій -- генерації ключів та шифрування повідомлення;
    \item \textbf{Простір:} Модульні решітки $R_q^k$, де $k \in \{2, 3, 4\}$ (залежно від рівня безпеки);
    \item \textbf{Модуль:} $q = 3329$ (просте число для ефективного NTT);
    \item \textbf{Оптимізація:} Number Theoretic Transform (NTT) для швидкого множення многочленів (хах, тут
          порівнюючи з чим саме і що вважати швидко);
    \item \textbf{Компресія:} Агресивне "стиснення"{} шифротексту.
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Стандартизовано під NIST (FIPS 203);
    \item Непоганий баланс між розмірами, швидкістю та безпекою;
    \item Ефективна реалізація з NTT.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Використання простого модуля ускладнює деякі оптимізації;
    \item Більший шифротекст порівняно з деякими MLWR-схемами.
\end{itemize}

\subsection{Saber}
\label{subsec:3-3-4}

Saber~\cite{saber2018} є Module-LWR схемою, фіналістом NIST PQC Round 3.

\textbf{Основні характеристики:}
\begin{itemize}
    \item \textbf{Структура:} MLWR для обох операцій;
    \item \textbf{Простір:} Модульні решітки $R_q^k$, $k \in \{2, 3, 4\}$;
    \item \textbf{Модуль:} $q = 8192 = 2^{13}$;
    \item \textbf{Оптимізація:} Відсутність NTT (округлення завдяки побітовим операціям);
    \item \textbf{Помилки:} Детерміністичні (через застосування округлення).
\end{itemize}

\textbf{\textit{Переваги:}}
\begin{itemize}
    \item Компактний шифротекст;
    \item Простота реалізації (без потреби в NTT чи гаусівському семплюванні);
    \item Ефективні побітові операції;
    \item Хороша стійкість до side-channel атак.
\end{itemize}

\textbf{\textit{Недоліки:}}
\begin{itemize}
    \item Більший(за розміром) відкритий ключ порівняно з Kyber;
\end{itemize}

\newpage %FORCED
\subsection{Порівняння алгоритмів, і що з них взяв TiGER}
\label{subsec:3-3-5}

\begin{table}[ht]
    \centering
    \begin{tblr}{
            colspec = {Q[l,m] Q[c,m] Q[c,m] Q[c,m] Q[c,m]},
            hlines, vlines,
            row{1} = {font=\bfseries}
        }
        Характеристика & Lizard  & RLizard   & Kyber             & Saber        \\
        Структура      & LWE/LWR & RLWE/RLWR & MLWE              & MLWR         \\
        Розмірність    & $n$     & $n$       & $n \times k$      & $n \times k$ \\
        Модуль $q$     & малий   & малий     & 3329              & 8192         \\
        NTT            & Ні      & Ні        & Так               & Ні           \\
        Семплювання    & Гаусс   & Гаусс/CDT & Centered binomial & Округлення   \\
        Компресія      & Помірна & Помірна   & Агресивна         & Помірна      \\
    \end{tblr}
    \caption{Порівняння підходів у сімействі RLWE/RLWR алгоритмів}
    \label{table:3-3-1}
\end{table}

\noindent TiGER об'єднує в собі найкращі ідеї з попередніх доробок:

\textbf{Позиція TiGER:}
\begin{itemize}
    \item Базується на \textbf{RLWE/RLWR} (як RLizard);
    \item Використовує \textbf{степені двійки} для $q, p$ (як Saber);
    \item \textbf{Розріджені секрети} для ефективності;
    \item \textbf{Корекція помилок} (XEf, D2) для мінімізації DFP/R;
    \item \textbf{Без NTT} для простоти;
    \item Фокусування на \textbf{мінімальному шифротексті} для легшого впровадження в існуючі протоколи.
\end{itemize}

\section{Криптографічні примітиви}
\label{sec:3-4}

У цій частині розділу розглянемо базові криптографічні примітиви, що використовуються для безпосередньо при побудові 
TiGER: схеми шифрування з відкритим ключем (PKE) та механізми інкапсуляції ключа (KEM).

\subsection{Схема шифрування з відкритим ключем (PKE)}
\label{subsec:3-4-1}

\begin{definition}[PKE схема]
    \label{def:3-4-1}
    ~\par Схема шифрування з відкритим ключем (Public Key Encryption, PKE) складається з трьох алгоритмів:
    \begin{itemize}
        \item $\mathsf{KeyGen}(1^\lambda) \to (\mathsf{pk}, \mathsf{sk})$ --- ймовірнісний алгоритм генерації 
            ключів, що на вході приймає параметр безпеки $\lambda$ і повертає пару: відкритий ключ $\mathsf{pk}$ та 
            секретний ключ $\mathsf{sk}$;
        \item $\mathsf{Enc}(\mathsf{pk}, m; r) \to c$ --- ймовірнісний алгоритм шифрування, що приймає відкритий 
            ключ $\mathsf{pk}$, повідомлення $m$ з простору повідомлень $\mathcal{M}$ та випадкове число $r$, і 
            повертає шифротекст $c$;
        \item $\mathsf{Dec}(\mathsf{sk}, c) \to m'$ --- детермінінований алгоритм дешифрування, що приймає 
            секретний ключ $\mathsf{sk}$ і шифротекст $c$, та повертає повідомлення $m'$ або помилку -- $\bot$.
    \end{itemize}
\end{definition}

\begin{definition}[Коректність PKE]
    \label{def:3-4-2}
    ~\par PKE схема є $(1-\delta)$-коректною, якщо для будь-якої пари ключів 
    $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ та будь-якого повідомлення $m \in \mathcal{M}$ виконується:
    \begin{equation*}
        \mathbb{P}[\mathsf{Dec}(\mathsf{sk}, \mathsf{Enc}(\mathsf{pk}, m)) \neq m] \leq \delta,
    \end{equation*}
    де ймовірність визначається через випадковість алгоритму $\mathsf{Enc}$. Параметр $\delta$ називається 
    \textit{ймовірністю помилки дешифрування} (Decryption Failure Probability/Rate, DFP/R)
\end{definition}

У задачах на решітках, через наявність помилок у RLWE/RLWR, коректність не завжди є ідеальною. Тому для практичних 
застосувань необхідно, щоб $\delta$ було незначним ($\delta \leq 2^{-128}$).

\subsection{Механізм інкапсуляції ключа (KEM)}
\label{subsec:3-4-2}

\begin{definition}[KEM схема]
    \label{def:3-4-3}
    ~\par Механізм інкапсуляції ключа (Key Encapsulation Mechanism, KEM) складається з трьох кроків:
    \begin{itemize}
        \item $\mathsf{KeyGen}(1^\lambda) \to (\mathsf{pk}, \mathsf{sk})$ --- алгоритм генерації ключів 
            (аналогічно до PKE);
        \item $\mathsf{Encaps}(\mathsf{pk}) \to (c, K)$ --- ймовірнісний алгоритм інкапсуляції, що приймає 
            відкритий ключ $\mathsf{pk}$ і повертає шифротекст $c$ та спільний секретний ключ $K \in \mathcal{K}$;
        \item $\mathsf{Decaps}(\mathsf{sk}, c) \to K'$ --- детермінований алгоритм декапсуляції, що приймає 
        секретний ключ $\mathsf{sk}$ і шифротекст $c$, та повертає прихований секретний ключ $K'$ або символ 
            помилки $\bot$.
    \end{itemize}
\end{definition}

\begin{definition}[Коректність KEM]
    \label{def:3-4-4}
    ~\par KEM схема є $(1-\delta)$-коректною, якщо для будь-якої пари ключів 
    $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ справджується таке:
    \begin{equation*}
        \mathbb{P}[\mathsf{Decaps}(\mathsf{sk}, c) \neq K : (c, K) \gets \mathsf{Encaps}(\mathsf{pk})] \leq \delta.
    \end{equation*}
\end{definition}

\subsection{Побудова KEM з PKE}
\label{subsec:3-4-3}

Стандартний спосіб побудови KEM з PKE полягає у шифруванні випадкового повідомлення та використанні геш-функції 
для отримання спільного ключа.

\begin{claim}[Нативна побудова KEM]
    \label{claim:3-4-1}
    ~\par Нехай $\mathsf{PKE} = (\mathsf{KeyGen}, \mathsf{Enc}, \mathsf{Dec})$ -- PKE це ось така трійка, що містить 
    у собі простір повідомлень $\mathcal{M}$, та $H: \mathcal{M} \to \mathcal{K}$ -- деяка геш-функція. Тоді можна 
    побудувати KEM 
    таким способом:
    \begin{itemize}
        \item Спосіб генерації $\mathsf{KeyGen}$ такий же, як у PKE;
        \item $\mathsf{Encaps}(\mathsf{pk})$: обирають $m \in \mathcal{M}$, а далі обчислюють 
            $c \gets \mathsf{Enc}(\mathsf{pk}, m)$ та $K \gets H(m)$. На виході отримано пару: $(c, K)$;
        \item $\mathsf{Decaps}(\mathsf{sk}, c)$: обчислюють $m' \gets \mathsf{Dec}(\mathsf{sk}, c)$ та на виході 
            отримуємо $K' \gets H(m')$.
    \end{itemize}
\end{claim}

Така побудова не забезпечує IND-CCA безпеки навіть якщо базова PKE схема є IND-CPA безпечною, але для нас головне 
щоб було зрозуміло як цей механізм працює). А для досягнення IND-CCA безпеки вже необхідно застосувати перетворення 
Fujisaki-Okamoto (розглянемо його у секції~\ref{sec:3-6}).

\subsection{Криптографічні геш-функції}
\label{subsec:3-4-4}

\begin{definition}[Криптографічна геш-функція]
    \label{def:3-4-5}
    ~\par Функція $H: \{0,1\}^* \to \{0,1\}^n$ називається криптографічною геш-функцією, якщо вона задовольняє 
    наступні умови:
    \begin{enumerate}
        \item \textbf{Стійкість до знаходження прообразу:} Для випадкового $y \in \{0,1\}^n$ обчислювально 
            важко знайти $x$ такий, що $H(x) = y$;
        \item \textbf{Стійкість до знаходження другого прообразу:} Для заданого $x$ обчислювально важко знайти 
            $x' \neq x$ такий, що $H(x') = H(x)$;
        \item \textbf{Стійкість до колізій:} Обчислювально важко знайти дві різні величини $x, x'$ 
            такі, що $H(x) = H(x')$.
    \end{enumerate}
\end{definition}

У TiGER використовуються геш-функції з сімейства SHA-3 -- SHAKE256 (або SHA3-256) для генерації випадковості, обчислення 
спільних ключів та інших криптографічних операцій. SHAKE256 є функцією з розширеним виходом (XOF), що дозволяє 
генерувати вихід довільної довжини.

\subsection{Зв'язок PKE та KEM у TiGER}
\label{subsec:3-4-5}

TiGER складається з двох рівнів:
\begin{enumerate}
    \item \textbf{TiGER.PKE} -- являє собою базову IND-CPA безпечну схему шифрування, що базується на RLWE(R);
    \item \textbf{TiGER.KEM} -- KEM, отриманий застосуванням перетворення Fujisaki-Okamoto (FO) до TiGER.PKE 
        для досягнення IND-CCA безпеки.
\end{enumerate}
Це дозволяє:
\begin{itemize}
    \item Окремо аналізувати безпеку PKE (на базі RLWE/RLWR);
    \item Використовувати загальні результати про перетворення FO для доведення IND-CCA безпеки KEM;
\end{itemize}

\section{Основні поняття безпеки, що стосуються TiGER}
\label{sec:3-5}

\subsection{IND-CPA безпека}
\label{subsec:3-5-1}

\begin{definition}[IND-CPA (Indistinguishability under Chosen-Plaintext Attack) гра для PKE]
    \label{def:3-5-1}
    ~\par Розглянемо наступну "гру"{} між претендентом (challenger) $\mathcal{C}$ та супротивником (adversary) $\mathcal{A}$:
    \begin{enumerate}
        \item $\mathcal{C}$ генерує $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ і передає 
            $\mathsf{pk}$ супротивнику $\mathcal{A}$;
        \item $\mathcal{A}$ обирає два повідомлення $m_0, m_1 \in \mathcal{M}$ однакової довжини і передає їх 
            $\mathcal{C}$;
        \item $\mathcal{C}$ Випадковим чином обирає біт $b \xleftarrow{p} \{0,1\}$, обчислює 
            $c \gets \mathsf{Enc}(\mathsf{pk}, m_b)$ і передає $c$ супротивнику $\mathcal{A}$;
        \item $\mathcal{A}$ виводить біт $b'$.
    \end{enumerate}
    Перевага супротивника визначається наступним чином:
    \begin{equation*}
        \mathsf{Adv}^{\text{IND-CPA}}_{\mathsf{PKE}}(\mathcal{A}) = \left| \mathbb{P}[b' = b] - \frac{1}{2} \right| 
        + \varepsilon(\lambda).
    \end{equation*}

    PKE схема є IND-CPA безпечною, якщо для будь-якого ефективного (PPT) супротивника $\mathcal{A}$ перевага 
    $\mathsf{Adv}^{\text{IND-CPA}}_{\mathsf{PKE}}(\mathcal{A})$ є незначною функцією від $\lambda$.
\end{definition}

IND-CPA безпечність означає нерозрізненість шифротекстів: супротивник маючи доступ до відкритого ключа (а отже, 
має можливість шифрувати будь-які повідомлення), не може визначити, яке з двох повідомлень було зашифроване. Це 
вимагає від шифрування, щоб воно було ймовірнісним.

\begin{definition}[IND-CPA (Indistinguishability under Chosen-Plaintext Attack) безпека для KEM]
    \label{def:3-5-2}
    ~\par Для KEM "гра"{} IND-CPA визначається аналогічно:
    \begin{enumerate}
        \item $\mathcal{C}$ генерує пару $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ і 
            передає $\mathsf{pk}$ супротивнику $\mathcal{A}$;
        \item $\mathcal{C}$ обирає $b \xleftarrow{p} \{0,1\}$. Якщо обрано $b = 0$, то обчислює 
            $(c, K_0) \gets \mathsf{Encaps}(\mathsf{pk})$; а якщо $b = 1$, обчислює 
            $(c, K_0) \gets \mathsf{Encaps}(\mathsf{pk})$ та $K_1 \xleftarrow{p} \mathcal{K}$. 
            Опісля передає пару $(c, K_b)$ супротивнику;
        \item $\mathcal{A}$ виводить біт $b'$.
    \end{enumerate}
    Перевага cупротивника $\mathsf{Adv}^{\text{IND-CPA}}_{\mathsf{KEM}}(\mathcal{A})$ визначається аналогічно як і в PKE.
\end{definition}

Безпека KEM тісно пов'язана з:
\begin{itemize}
    \item IND-CPA безпекою базової PKE схеми;
    \item Ймовірністю помилки дешифрування $\varepsilon$;
    \item Параметрами випадкових оракулів (про трохи далі).
\end{itemize}

Важливим є те, що навіть за наявності помилок дешифрування (що неминуче для схем на решітках), можна довести 
IND-CCA безпеку за умови достатньо малого $\varepsilon(\lambda)$.

\subsection{IND-CCA безпека}
\label{subsec:3-5-2}

\begin{definition}[IND-CCA для PKE]
    \label{def:3-5-3}
    ~\par "Гра"{} IND-CCA відрізняється від IND-CPA тим, що противник $\mathcal{A}$ має додатково доступ до оракула 
    дешифрування (decryption oracle) $\mathsf{Dec}(\mathsf{sk}, \cdot)$:
    \begin{enumerate}
        \item $\mathcal{C}$ генерує $(\mathsf{pk}, \mathsf{sk}) \gets \mathsf{KeyGen}(1^\lambda)$ і передає 
            $\mathsf{pk}$ супротивнику $\mathcal{A}$;
        \item $\mathcal{A}$ робить запити до оракула дешифрування, подаючи на вхід довільні шифротексти $c_i$ і 
            отримувати $m_i = \mathsf{Dec}(\mathsf{sk}, c_i)$;
        \item $\mathcal{A}$ обирає $m_0, m_1$ і отримує challenge шифротекст 
            $c^{*} \gets \mathsf{Enc}(\mathsf{pk}, m_b)$ для випадкового $b$;
        \item $\mathcal{A}$ продовжує робити запити до оракула дешифрування, але не може запитувати $c^{*}$ -- випадок 
            \textbf{IND-CCA2} (а якщо запити заборонені вже після отримання $c^{*}$ -- це \textbf{IND-CCA1});
        \item $\mathcal{A}$ виводить біт $b'$.
    \end{enumerate}
    Перевага $\mathsf{Adv}^{\text{IND-CCA}}_{\mathsf{PKE}}(\mathcal{A})$ визначається аналогічно.
\end{definition}

\begin{definition}[IND-CCA безпека для KEM]
    \label{def:3-5-4}
    ~\par Для KEM схеми противник має доступ до оракула декапсуляції $\mathsf{Decaps}(\mathsf{sk}, \cdot)$ і 
    \textbf{не може} запитувати challenge шифротекст $c^*$ після його отримання.
\end{definition}

IND-CCA (Indistinguishability under Chosen Ciphertext Attack) безпека є значно сильнішою, ніж IND-CPA, оскільки 
моделює активного противника, який може маніпулювати шифротекстами та спостерігати результати дешифрування. Для 
практичних застосувань зазвичай потрібна IND-CCA2 безпека.

\subsection{Ймовірність помилки дешифрування (DFP/R)}
\label{subsec:3-5-3}

\begin{definition}[Decryption Failure Probability/Rate]
    \label{def:3-5-5}
    ~\par Для PKE схеми ймовірність помилки дешифрування (DFP/R) визначається як:
    \begin{equation*}
        \delta = \max_{m \in \mathcal{M}} \mathbb{P}_{(\mathsf{pk},\mathsf{sk}),r}
        [\mathsf{Dec}(\mathsf{sk}, \mathsf{Enc}(\mathsf{pk}, m; r)) \neq m],
    \end{equation*}
    де ймовірність береться за випадковістю генерації ключів та шифрування.

    Для KEM схеми:
    \begin{equation*}
        \delta = \mathbb{P}_{(\mathsf{pk},\mathsf{sk}),(c,K)}[\mathsf{Decaps}(\mathsf{sk}, c) \neq K].
    \end{equation*}
\end{definition}

У решіткових схемах помилки дешифрування виникають природнім шляхом (наявність шуму у RLWE/RLWR), тому параметри 
схеми (розміри модулів, розподіл помилок, коефіцієнт стиснення) мають бути підібрані так, щоб забезпечити мале $\delta$.

\noindent (!) Висока ймовірність помилки дешифрування може призвести до наступних атак:
\begin{itemize}
    \item \textbf{Failure boosting attacks~\cite{dhooghe2018}:} Супротивник може ітеративно створювати шифротексти, 
        що мають високу ймовірність помилки, щоб витягувати поступово інформацію про секретний ключ;
    \item \textbf{Multi-target attacks~\cite{danvers2022}:} При наяності багатьох публічних ключів або сесій, 
        навіть відносно мала DFP/R може стати проблемою.
\end{itemize}

\noindent Для реалізацій TiGER цільова DFP/R становить:
\begin{itemize}
    \item TiGER128: $\delta \approx 2^{-120}$;
    \item TiGER192: $\delta \approx 2^{-136}$;
    \item TiGER256: $\delta \approx 2^{-167}$.
\end{itemize}
P.S. Ці значення вважаються достатньо малими для практичного застосування.

\subsection{Квантова безпека a.k.a. QROM}
\label{subsec:3-5-4}

\begin{definition}[Quantum Random Oracle Model]
    \label{def:3-5-6}
    ~\par Модель квантового випадкового оракула (скорочено QROM) -- це розширення класичної моделі випадкового 
    оракула (ROM), де противник має квантовий доступ до геш-функцій, тобто може ще робити запити у суперпозиції.
\end{definition}

\noindent Для TiGER необхідно, щоб перетворення Fujisaki-Okamoto забезпечувало IND-CCA безпеку у QROM, це гарантуватиме 
стійкість проти квантових атак.

\section{Перетворення Fujisaki-Okamoto}
\label{sec:3-6}

Перетворення Fujisaki-Okamoto (скорочено FO)~\cite{fo1999,fo2013} є загальним методом перетворення IND-CPA безпечної 
PKE схеми у IND-CCA безпечну KEM схему. В цьому підпункті наведемо просте класичне FO перетворення та його модифікацію -- 
варіант з неявним відхиленням, що використовується в TiGER.

\subsection{Класичне перетворення FO}
\label{subsec:3-6-1}

\begin{theorem}[Fujisaki-Okamoto]
    \label{theorem:3-6-1}
    ~\par Нехай $\mathsf{PKE} = (\mathsf{KeyGen}, \mathsf{Enc}, \mathsf{Dec})$ -- IND-CPA безпечна PKE схема з
    однозначним детермінованим дешифруванням. Нехай $G: \mathcal{M} \to \mathcal{R} \times \mathcal{K}$ та
    $H: \mathcal{M} \times \mathcal{C} \to \mathcal{K}$ -- випадкові оракули. Тоді наступна конструкція є
    IND-CCA безпечною KEM у моделі випадкового оракула~\cite{fo1999}:
    \begin{algorithm}[H]
        \caption{KeyGen()}
        \begin{algorithmic}[1]
            \State Generate $(pk, sk) \gets $ PKE.KeyGen$(1^\lambda)$
            \State \Return $(pk, sk)$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Encaps$(pk)$}
        \begin{algorithmic}[1]
            \State Choose $m \xleftarrow{p} \mathcal{M}$
            \State Calculate $(r, K) \gets G(m)$
            \State Calculate $c \gets$ PKE.Enc$(pk, m; r)$
            \State \Return $(c, K)$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Decaps$(sk, c)$}
        \begin{algorithmic}[1]
            \State Calculate $m' \gets$ PKE.Dec$(sk, c)$
            \State Calculate $(r', K') \gets G(m')$
            \State Calculate $c' \gets$ PKE.Enc$(pk, m'; r')$
            \If{$c = c'$}
            \State \Return $K'$
            \Else
            \State \Return $\bot$
            \EndIf
        \end{algorithmic}
    \end{algorithm}
\end{theorem}

\noindent \textbf{Ключова ідея перетворення FO} полягає у \textbf{\textit{повторному шифруванні}} (re-encryption): 
після дешифрування повідомлення $m'$ воно повторно шифрується з тією ж випадковістю, і результат порівнюється з 
отриманим шифротекстом. Це дозволяє виявити модифікації шифротексту.

\subsection{Перетворення \texorpdfstring{$\mathsf{FO}^{\not\bot}_m$}{FO} з неявним відхиленням}
\label{subsec:3-6-2}

Для схем на решітках з ненульовою ймовірністю помилки дешифрування було розроблено модифікацію -- варіант FO з 
\textit{неявним відхиленням} (implicit rejection)~\cite{hofheinz2017}.

\begin{definition}[Перетворення $\mathsf{FO}^{\not\bot}_m$]
    \label{def:3-6-1}
    ~\par Нехай $\mathsf{PKE}$ -- IND-CPA безпечна PKE схема. Конструкція $\mathsf{FO}^{\not\bot}_m$ відрізняється 
    від класичного FO у додатковій декапсуляції:

    \begin{algorithm}[H]
        \caption{KeyGen()}
        \begin{algorithmic}[1]
            \State Generate $(pk, sk') \gets$ PKE.KeyGen$(1^\lambda)$
            \State Choose $z \xleftarrow{p} \mathcal{Z}$ \Comment{Додатковий випадковий ключ}
            \State \Return $(pk, sk = (sk', z))$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Encaps$(pk)$}
        \begin{algorithmic}[1]
            \State Choose $m \xleftarrow{p} \mathcal{M}$
            \State Calculate $r \gets G(m, pk)$
            \State Calculate $c \gets$ PKE.Enc$(pk, m; r)$
            \State Calculate $K \gets H(m, c)$
            \State \Return $(c, K)$
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Decaps$(sk, c)$}
        \begin{algorithmic}[1]
            \State Split $sk = (sk', z)$
            \State Calculate $m' \gets$ PKE.Dec$(sk', c)$
            \State Calculate $r' \gets G(m', pk)$
            \State Calculate $c' \gets$ PKE.Enc$(pk, m'; r')$
            \If{$c = c'$}
            \State \Return $K' \gets H(m', c)$
            \Else
            \State \Return $\bar{K} \gets H(z, c)$ \Comment{Неявне відхилення}
            \EndIf
        \end{algorithmic}
    \end{algorithm}
\end{definition}

\noindent \textbf{Ключова відмінність:} замість повернення $\bot$ при невдалій перевірці, алгоритм повертає 
псевдовипадковий ключ $\bar{K} = H(z, c)$, де $z$ -- секретний випадковий ключ. Це має дві переваги:
\begin{itemize}
    \item \textbf{Захист від side-channel атак:} Оскільки зовнішньому спостерігачу стає важче визначити, чи 
        відбулася помилка при декапсуляції;
    \item \textbf{Постійний час виконання:} Обидва варіанти (успіх/невдача) тепер виконують однакові операції гешування.
\end{itemize}

\subsection{Застосування у алгоритмі TiGER}
\label{subsec:3-6-4}

TiGER.KEM побудовано із застосуванням варіанту перетворення $\mathsf{FO}^{\not\bot}_m$ до TiGER.PKE:

\begin{itemize}
    \item \textbf{TiGER.PKE:} Базується на RLWR (для відкритого ключа) та RLWE (для шифрування), забезпечує 
        IND-CPA безпеку;
    \item \textbf{геш-функції:} Використовуються $G = H = \mathsf{SHAKE256}$ (функція з розширеним виходом) 
        для генерації випадковості та спільних ключів;
    \item \textbf{Додаткове гешування:} Відкритий ключ $\mathsf{pk}$ гешується разом з повідомленням: 
        $r \gets G(m, H(\mathsf{pk}))$, що забезпечує захист від multi-target атак;
    \item \textbf{Неявне відхилення:} При невдалій декапсуляції повертається $\bar{K} = H(z, c)$, що захищає від 
        витоку інформації про помилки та розкритті хоч і мізерної, та інформації, про ключ.
\end{itemize}

\chapter{\large{Повний опис алгоритму TiGER}}
\label{chapter:4}

\chapter{\large{Результати досліджень}}
\label{chapter:5}

% TODO: Заповнити розділ

\chapter{\large{Аналіз атак на TiGER}}
\label{chapter:6}

% TODO: Заповнити розділ

\chapter{\large{Порівняльний аналіз}}
\label{chapter:7}

% TODO: Заповнити розділ

\chapter{\large{Перенесення атак та можливі покращення}}
\label{chapter:8}

% TODO: Заповнити розділ
